<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Excel</title>
      <link href="2020/11/05/Excel%E5%87%BD%E6%95%B0/"/>
      <url>2020/11/05/Excel%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1、求和函数SUM"><a href="#1、求和函数SUM" class="headerlink" title="1、求和函数SUM()"></a>1、求和函数SUM()</h3><blockquote><p><strong>SUM</strong>函数将为值求和。 可以将单个值、单元格引用或是区域相加，或者将三者的组合相加。</p></blockquote><p>1、指定数值求和</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(10,20,30)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求和：输入=sum()，在括号中间按住ctrl连续点击即可选择需要求和的数据</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(C5,C9,C3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、也可以将指定单元格直接相加</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(C2 + C4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、区域求和，输入=sum()，在括号中间按住ctrl选中所需要求和的数据</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、多个区域求和，输入=sum()，在括号中间分别按住ctrl选中所需要的多个区域的数据</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(C2:C4,C6:C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、配合固定值进行求和，中间使用英文的逗号分隔</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUM(C2:C11,100)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、条件求和函数SUMIF"><a href="#2、条件求和函数SUMIF" class="headerlink" title="2、条件求和函数SUMIF()"></a>2、条件求和函数SUMIF()</h3><blockquote><p>按条件求和</p></blockquote><p>sumif函数的语法格式</p><blockquote><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&gt;&#x3D;sumif(range，criteria，sum_range)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sumif（条件区域，求和条件，实际求和区域），第二个求和条件参数在第一个条件区域里。</p></blockquote><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;SUMIF(D2:D11,D4,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>求和所有性别中性别为女的年龄</p><h3 id="3、求平均值函数AVERAGE"><a href="#3、求平均值函数AVERAGE" class="headerlink" title="3、求平均值函数AVERAGE()"></a>3、求平均值函数AVERAGE()</h3><blockquote><p>获取平均值</p></blockquote><p>1、指定数值求平均值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;AVERAGE(10,20)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求平均值:括号内按ctrl选择需要求平均值的单元格</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;AVERAGE(C2,C8)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、范围单元格求平均值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;AVERAGE(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、求最大值函数MAX"><a href="#4、求最大值函数MAX" class="headerlink" title="4、求最大值函数MAX()"></a>4、求最大值函数MAX()</h3><blockquote><p>获取最大值</p></blockquote><p>1、指定数值求最大值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MAX(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最大值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MAX(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最大值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MAX(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最大值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MAX(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、求最小值函数MIN"><a href="#5、求最小值函数MIN" class="headerlink" title="5、求最小值函数MIN()"></a>5、求最小值函数MIN()</h3><blockquote><p>获取最小值</p></blockquote><p>1、指定数值求最小值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MIN(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最小值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MIN(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最小值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MIN(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最小值</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;MIN(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、计数函数COUNT"><a href="#6、计数函数COUNT" class="headerlink" title="6、计数函数COUNT()"></a>6、计数函数COUNT()</h3><blockquote><p>获取指定单元格非空数据数值类型的个数，对于空单元格、逻辑值或者文本数据将被忽略。可以用来判断是否有空白单元格</p></blockquote><p>1、指定数值获取非空数值的个数</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;COUNT(1,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格中非空数值的个数</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;COUNT(C10,F10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围获取非空数值的个数</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;COUNT(C10:C12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格获取非空数值的个数</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;COUNT(C8,C10,C12,F4:F12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7、非空计数函数COUNTA"><a href="#7、非空计数函数COUNTA" class="headerlink" title="7、非空计数函数COUNTA()"></a>7、非空计数函数COUNTA()</h3><blockquote><p>统计区域内包含文本和逻辑值的单元格个数。</p><p>注意counta函数与count函数的区别。</p><p>Count函数只统计区域内包含数字的单元格个数。</p></blockquote><p>1、指定多个范围单元格获取非空数据的个数</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;COUNTA(E4:E7,C2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8、四舍五入函数ROUND"><a href="#8、四舍五入函数ROUND" class="headerlink" title="8、四舍五入函数ROUND()"></a>8、四舍五入函数ROUND()</h3><blockquote><p>对数值进行四舍五入</p></blockquote><p>ROUND函数语法格式：</p><blockquote><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&gt;ROUND(number, num_digits)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中</p><p>number表示需要进行四舍五入的数值或单元格内容。</p><p>num_digits表示需要取多少位的参数。</p><p>num_digits&gt;0时，表示取小数点后对应位数的四舍五入数值。</p><p>num_digits=0时，表示则将数字四舍五入到最接近的整数。</p><p>num_digits&lt; 0时，表示对小数点左侧前几位进行四舍五入。</p></blockquote><p>1、对指定单元格进行四舍五入</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;ROUND(E7,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK"><a href="#9、排名次函数RANK" class="headerlink" title="9、排名次函数RANK()"></a>9、排名次函数RANK()</h3><blockquote><p>返回一列数字的数字排位。 数字的排位是相对于列表中的其他值的大小。</p></blockquote><p>语法：RANK(number,ref,[order])</p><blockquote><p>RANK 函数语法具有下列参数：</p><ul><li><p><strong>Number</strong>   必需。 要找到其排位的数字。</p></li><li><p><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</p></li><li><p><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</p><p>如果 order 为 0（零）或省略，Microsoft Excel 对数字的排位是基于 ref 为按照降序排列的列表。</p><p>如果 order 不为零，Microsoft Excel 对数字的排位是基于 ref 为按照升序排列的列表。</p></li></ul></blockquote><p>1、获取指定单元格在范围内进行排名</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;RANK(C3,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK-EQ"><a href="#9、排名次函数RANK-EQ" class="headerlink" title="9、排名次函数RANK.EQ()"></a>9、排名次函数RANK.EQ()</h3><p><code>与RANK函数用法一致</code></p><blockquote><p>返回一列数字的数字排位。 其大小与列表中其他值相关；如果多个值具有相同的排位，则返回该组值的最高排位。</p><p>如果要对列表进行排序，则数字排位可作为其位置。</p></blockquote><p>语法</p><blockquote><p>RANK.EQ(number,ref,[order])</p><p>RANK.EQ 函数语法具有下列参数：</p><ul><li><strong>Number</strong>   必需。 要找到其排位的数字。</li><li><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</li><li><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</li></ul><p>【注意】</p><ul><li>如果 Order 为 0（零）或省略，Excel 对数字的排位是基于 Ref 为按降序排列的列表。</li><li>如果 Order 不为零， Excel 对数字的排位是基于 Ref 为按照升序排列的列表。</li></ul></blockquote><p>1、升序排名</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;RANK.EQ(C3,C2:C11,1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、降序排名(0可以省略)</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;RANK.EQ(C3,C2:C11,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10、取整函数INT"><a href="#10、取整函数INT" class="headerlink" title="10、取整函数INT()"></a>10、取整函数INT()</h3><blockquote><p>将数字向下舍入到最接近的整数。</p></blockquote><p>1、对指定单元格进行取整，忽略小数位</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;INT(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11、求字符串长度函数LEN"><a href="#11、求字符串长度函数LEN" class="headerlink" title="11、求字符串长度函数LEN()"></a>11、求字符串长度函数LEN()</h3><blockquote><p>返回文本字符串中的字符个数</p><p>【注意】数字，字符，汉字都属于一个字符，包括小数点</p></blockquote><p>1、对指定单元格获取长度</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;LEN(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12、左取字符串函数LEFT"><a href="#12、左取字符串函数LEFT" class="headerlink" title="12、左取字符串函数LEFT()"></a>12、左取字符串函数LEFT()</h3><blockquote><p>从文本字符串的第一个字符开始返回指定个数的字符</p></blockquote><p>语法</p><blockquote><p>LEFT(text, [num_chars])</p><p>该函数语法具有下列参数：</p><ul><li><strong>Text</strong>  必需。 包含要提取的字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定要由 LEFT 提取的字符的数量。<ul><li>num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 LEFT 返回全部文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></li></ul></blockquote><p>1、获取指定单元格从左开始的第一个字符</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;LEFT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;LEFT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13、右取字符串函数RIGHT"><a href="#13、右取字符串函数RIGHT" class="headerlink" title="13、右取字符串函数RIGHT()"></a>13、右取字符串函数RIGHT()</h3><blockquote><p>根据所指定的字符数返回文本字符串中最后一个或多个字符</p></blockquote><p>语法</p><blockquote><p>RIGHT(text,[num_chars])</p><p>RIGHT  函数具有下列参数：</p><ul><li><strong>文本</strong>  必需。 包含要提取字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定希望 RIGHT 提取的字符数。</li><li>Num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 RIGHT 返回所有文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></blockquote><p>1、获取指定单元格从右开始的第一个字符</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;RIGHT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;RIGHT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="14、日函数DAY"><a href="#14、日函数DAY" class="headerlink" title="14、日函数DAY()"></a>14、日函数DAY()</h3><blockquote><p>返回以序列数表示的某日期的天数。 天数是介于 1 到 31 之间的整数。</p></blockquote><p>语法</p><blockquote><p>DAY(serial_number)</p><p>DAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=DAY(A2)</td><td>单元格 A2 (15) 中日期的天数</td><td>15</td></tr></tbody></table></div><h3 id="15、月函数MONTH"><a href="#15、月函数MONTH" class="headerlink" title="15、月函数MONTH()"></a>15、月函数MONTH()</h3><blockquote><p>返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。</p></blockquote><p>语法</p><blockquote><p>MONTH(serial_number)</p><p>MONTH 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的月份的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>说明</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=MONTH(A2)</td><td>单元格 A2 中日期的月份</td><td>4</td></tr></tbody></table></div><h3 id="16、年函数YEAR"><a href="#16、年函数YEAR" class="headerlink" title="16、年函数YEAR()"></a>16、年函数YEAR()</h3><blockquote><p>返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。</p></blockquote><p>语法</p><blockquote><p>YEAR(serial_number)</p><p>YEAR 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 要查找的年份的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td>2008-7-5</td><td></td><td></td></tr><tr><td>2010-7-5</td><td></td><td></td></tr><tr><td><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td>=YEAR(A3)</td><td>单元格 A3 中日期的年份 (2008)</td><td>2008</td></tr><tr><td>=YEAR(A4)</td><td>单元格 A4 中日期的年份 (2010)</td><td>2010</td></tr></tbody></table></div><h3 id="17、星期函数WEEKDAY"><a href="#17、星期函数WEEKDAY" class="headerlink" title="17、星期函数WEEKDAY()"></a>17、星期函数WEEKDAY()</h3><blockquote><p>返回对应于某个日期的一周中的第几天。 默认情况下，天数是 1（星期日）到 7（星期六）范围内的整数。</p></blockquote><p>语法</p><blockquote><p>WEEKDAY(serial_number,[return_type])</p><p>WEEKDAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 一个序列号，代表尝试查找的那一天的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li><li><strong>Return_type</strong>  可选。 用于确定返回值类型的数字。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Return_type</strong></th><th style="text-align:left"><strong>返回的数字</strong></th></tr></thead><tbody><tr><td style="text-align:left">1 或省略</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。 同 Microsoft Excel 早期版本。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">数字 0（星期一）到 6（星期日）。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">数字 1（星期二）到数字 7（星期一）。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">数字 1（星期三）到数字 7（星期二）。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">数字 1（星期四）到数字 7（星期三）。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">数字 1（星期五）到数字 7（星期四）。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">数字 1（星期六）到数字 7（星期五）。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。</td></tr></tbody></table></div></blockquote><p>备注</p><blockquote><ul><li>Microsoft Excel 可将日期存储为可用于计算的序列号。 默认情况下，1900 年 1 月 1 日的序列号是 1，而 2008 年 1 月 1 日的序列号是 39448，这是因为它距 1900 年 1 月 1 日有 39448 天。</li><li>如果当前日期基值的 serial_number 超出范围，则 #NUM！ 返回错误。</li><li>如果 return_type 超出了上表中指定的范围，则 #NUM！ 返回错误。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>数据</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2008-2-14</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=WEEKDAY(A2)</td><td>使用数字 1（星期日）到 7（星期六）表示的一周中的第几天 (5)</td><td>5</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 2)</td><td>使用数字 1（星期一）到 7（星期日）表示的一周中的第几天 (4)</td><td>4</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 3)</td><td>使用数字 0（星期一）到 6（星期日）表示的一周中的第几天 (3)</td><td>3</td></tr></tbody></table></div><h3 id="18、日期函数-DATE"><a href="#18、日期函数-DATE" class="headerlink" title="18、日期函数 DATE()"></a>18、日期函数 DATE()</h3><blockquote><p>返回表示特定日期的连续序列号。</p></blockquote><p>语法：</p><blockquote><p>DATE(year,month,day)</p><p>DATE 函数语法具有下列参数：</p><ul><li><strong>Year</strong>  ：必需。<strong><em>year\</em></strong> 参数的值可以包含一到四位数字。Excel 将根据计算机正在使用的日期系统来解释 <strong><em>year\</em></strong> 参数。默认情况下，Microsoft Excel for Windows 使用的是 1900 日期系统，这表示第一个日期为 1900 年 1 月 1 日。</li></ul><p><strong>提示:</strong> 为避免出现意外结果，请对 <strong><em>year\</em></strong> 参数使用四位数字。例如，“07”可能意味着“1907”或“2007”。因此，使用四位数的年份可避免混淆。</p><ul><li>如果 <strong><em>year\</em></strong> 介于 0（零）到 1899 之间（包含这两个值），则 Excel 会将该值与 1900 相加来计算年份。例如，DATE(108,1,2) 返回 2008 年 1 月 2 日 (1900+108)。</li><li>如果 <strong><em>year\</em></strong> 介于 1900 到 9999 之间（包含这两个值），则 Excel 将使用该数值作为年份。例如，DATE(2008,1,2) 将返回 2008 年 1 月 2 日。</li><li><p>如果 <strong><em>year\</em></strong> 小于 0 或大于等于 10000，则 Excel 返回 错误值 #NUM!。</p></li><li><p><strong>Month</strong>  必需。一个正整数或负整数，表示一年中从 1 月至 12 月（一月到十二月）的各个月。</p></li><li><p>如果 <strong><em>month\</em></strong> 大于 12，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始加上该月份数。例如，DATE(2008,14,2) 返回表示 2009 年 2 月 2 日的序列数。</p></li><li><p>如果 <strong><em>month\</em></strong> 小于 1，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始减去该月份数，然后再加上 1 个月。例如，DATE(2008,-3,2) 返回表示 2007 年 9 月 2 日的序列号。</p></li><li><p><strong>Day</strong>  必需。一个正整数或负整数，表示一月中从 1 日到 31 日的各天。</p></li><li><p>如果 <strong><em>day\</em></strong> 大于指定月中的天数，则 <strong><em>day\</em></strong> 会从该月的第一天开始加上该天数。例如，DATE(2008,1,35) 返回表示 2008 年 2 月 4 日的序列数。</p></li><li>如果 <strong><em>day\</em></strong> 小于 1，则 <strong><em>day\</em></strong> 从指定月份的第一天开始减去该天数，然后再加上 1 天。例如，DATE(2008,1,-15) 返回表示 2007 年 12 月 16 日的序列号。</li></ul><p><strong>注意:</strong> Excel 可将日期存储为连续序列号，以便能在计算中使用它们。1900 年 1 月 1 日的序列号为 1，2008 年 1 月 1 日的序列号为 39448，这是因为它与 1900 年 1 月 1 日之间相差 39,447 天。需要更改数字格式（设置单元格格式）以显示正确的日期。</p></blockquote><p>用法</p><p><strong>=DATE(C2,A2,B2)</strong> 将单元格 C2 中的年、单元格 A2 中的月以及单元格 B2 中的日合并在一起，并将它们放入一个单元格内作为日期。</p><pre class="line-numbers language-excel" data-language="excel"><code class="language-excel">&#x3D;DATE(C2,A2,B2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Excel函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的创建及使用</title>
      <link href="2020/11/04/MySQL%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>2020/11/04/MySQL%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>第一步肯定是创建数据库了.看下图操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224153.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224722.png" alt=""></p><p>先创建一个名字为 <font color='red'>company的数据库</font> 输入以下内容然后全选右键运行，如图（最好先保存防止下次找不到上次所写内容）</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224844.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104225129.png" alt=""></p><p> 点击最下方的刷新</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091503.png" alt=""></p><p>然后自己所创建的数据库就出来了，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091636.png" alt=""></p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>以下为添加数据的内容，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105092334.png" alt=""></p><p>选中添加内容，运行，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101502.png" alt=""></p><h2 id="查询emp表"><a href="#查询emp表" class="headerlink" title="查询emp表"></a>查询emp表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101742.png" alt=""></p><h2 id="修改表内容"><a href="#修改表内容" class="headerlink" title="修改表内容"></a>修改表内容</h2><h3 id="注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样"><a href="#注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样" class="headerlink" title="注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样"></a>注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101854.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102729.png" alt=""></p><h2 id="删除表内容"><a href="#删除表内容" class="headerlink" title="删除表内容"></a>删除表内容</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101935.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103100.png" alt=""></p><h2 id="更改表名"><a href="#更改表名" class="headerlink" title="更改表名"></a>更改表名</h2><h3 id="运行后到最左方右键，点击刷新就可看到更改的表名"><a href="#运行后到最左方右键，点击刷新就可看到更改的表名" class="headerlink" title="运行后到最左方右键，点击刷新就可看到更改的表名"></a>运行后到最左方右键，点击刷新就可看到更改的表名</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102030.png" alt=""></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103458.png" alt=""></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105030.png" alt=""></p><h2 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102148.png" alt="image-20201105102145614"></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105239.png" alt="image-20201105105238598"></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105500.png" alt="image-20201105105459408"></p><h2 id="添加列及删除列"><a href="#添加列及删除列" class="headerlink" title="添加列及删除列"></a>添加列及删除列</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102228.png" alt="image-20201105102227470"></p><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105635.png" alt="image-20201105105632391"></p><p>删除列</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105726.png" alt="image-20201105105725397"></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110012.png" alt="image-20201105110011837"></p><h2 id="创建新表添加新内容"><a href="#创建新表添加新内容" class="headerlink" title="创建新表添加新内容"></a>创建新表添加新内容</h2><p>注意：逐条运行   出现如下图最下方受影响及时间为运行成功！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110906.png" alt="image-20201105110904752"></p><p>运行结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105111129.png" alt="image-20201105111128007"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的安装</title>
      <link href="2020/11/02/MySQL%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>2020/11/02/MySQL%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>想学MySQL首先要学会安装，安装包如下：</p><p><a href="https://share.weiyun.com/NvbChzFu">传送门</a></p><h2 id="一、-什么是数据库"><a href="#一、-什么是数据库" class="headerlink" title="一、 什么是数据库"></a>一、 什么是数据库</h2><p>数据库是用来存储数据的仓库，互联的数据中心(idc ),绝大部分数据是通过数据库存储的。</p><h2 id="二、-数据库的种类"><a href="#二、-数据库的种类" class="headerlink" title="二、 数据库的种类"></a>二、 数据库的种类</h2><p>数据库有两大类：第一类是关系型数据库，第二类非关系型数据库</p><p>关系型数据库：mysql、oracle、sql server、mariadb</p><p>非关系型数据库：redis </p><h2 id="三、-数据库的安装"><a href="#三、-数据库的安装" class="headerlink" title="三、 数据库的安装"></a>三、 数据库的安装</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124903.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124926.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124936.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124958.png" alt=""></p><p>点击finish安装完成，开始对mysql进行配置</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125028.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125037.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125053.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125109.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125124.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125139.png" alt=""></p><p>这一步是调整允许数据库最大并发连接数</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125203.png" alt=""></p><p>这一步是设置mysql的端口号，默认是3306</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125219.png" alt=""></p><p>这一步是设置数据库的编码格式，改为了utf-8</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125236.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125246.png" alt=""></p><p>这一步设置数据库的密码，要输入两次一样的密码，不要设置过于复杂的密码</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125304.png" alt=""></p><p>四个对号安装成功，并且启动成功</p><h2 id="四、mysql服务器与客户端"><a href="#四、mysql服务器与客户端" class="headerlink" title="四、mysql服务器与客户端"></a>四、mysql服务器与客户端</h2><p>​    以上的过程安装的是mysql服务器。如果想对mysql服务器进行操作，还需要安装客户端连接上mysql服务器。比较常用的客户端有navicat、sql yog.</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125348.png" alt=""></p><h2 id="五、mysql数据库的名词解释"><a href="#五、mysql数据库的名词解释" class="headerlink" title="五、mysql数据库的名词解释"></a><strong>五、mysql数据库的名词解释</strong></h2><h3 id="数据库与数据表"><a href="#数据库与数据表" class="headerlink" title="数据库与数据表"></a>数据库与数据表</h3><p>​    数据库不直接存放数据，而先把数据存放到一张张数据表里，然后再把表放到数据库里。一个数据库里表都是相互有关系的。</p><h3 id="数据表的字段属性、记录"><a href="#数据表的字段属性、记录" class="headerlink" title="数据表的字段属性、记录"></a><strong>数据表的字段属性、记录</strong></h3><p> 数据表的列称为字段或属性，数据表的行称为记录。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a><strong>实体</strong></h3><p> 实体就是客观存在并可以相互区别的事物。表就是用来记录实体的信息的。</p><h2 id="六、创建数据库"><a href="#六、创建数据库" class="headerlink" title="六、创建数据库"></a>六、创建数据库</h2><p>​    Mysql服务器上默认有三个数据库，其中mysql数据库里边存储着用户信息等重要内容。当然也可以自己创建数据库。</p><h2 id="七、mysql数据库的数据类型"><a href="#七、mysql数据库的数据类型" class="headerlink" title="七、mysql数据库的数据类型"></a><strong>七、mysql数据库的数据类型</strong></h2><p>  <strong>整型：</strong> int</p><p>  <strong>浮点型</strong>： float(默认有七位小数)  double(默认有15位小数)  decimal(P,S) S是保留的小数位数，P数值的长度</p><p>  <strong>字符型：</strong>char(固定长度的类型) varchar(可变长度的类型)  text</p><p>​        固定长度和可变长度的区别：以char(20) varchar(20)为例。Char(20)不管存储内容长度是几个字节，都占内存的20个字节。Varchar(20) 存储的内容长度是几个字节，就占内存的几个字节。</p><p>  <strong>日期时间：</strong></p><p>​    日期： date（YYYY-MM-DD）</p><p>​    时间： time (HH:MM:SS)</p><p>​    日期时间：datetime (YYYY-MM-DD HH:MM:SS)</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github图床搭建</title>
      <link href="2020/10/26/github%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/"/>
      <url>2020/10/26/github%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>由于平时在写markdown文档时会引用很多的图片，但是图片是不可以直接粘贴上去的，所以我一般都要把图片放在一个文件夹里面，再导入图片。这样做比较繁琐，而且还存在如果我修改了路径，图片就不显示的问题。<br> 于是就发现了这个神器——<strong>PicGo</strong></p><h3 id="1、先下载个PicGo，如下"><a href="#1、先下载个PicGo，如下" class="headerlink" title="1、先下载个PicGo，如下"></a>1、先下载个PicGo，如下</h3><p><a href="https://share.weiyun.com/mSUFa7MN">传送门</a></p><h3 id="2-安装软件，打开软件，图床设置"><a href="#2-安装软件，打开软件，图床设置" class="headerlink" title="2 安装软件，打开软件，图床设置"></a><strong>2 安装软件，打开软件，图床设置</strong></h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;repo&quot;: &quot;&quot;, &#x2F;&#x2F; 仓库名，格式是username&#x2F;reponame  &quot;token&quot;: &quot;&quot;, &#x2F;&#x2F; github token  &quot;path&quot;: &quot;&quot;, &#x2F;&#x2F; 自定义存储路径，比如img&#x2F;  &quot;customUrl&quot;: &quot;&quot;, &#x2F;&#x2F; 自定义域名，注意要加http:&#x2F;&#x2F;或者https:&#x2F;&#x2F;  &quot;branch&quot;: &quot;&quot; &#x2F;&#x2F; 分支名，默认是master&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-首先你得有一个GitHub账号。注册GitHub就不用我多言。"><a href="#1-首先你得有一个GitHub账号。注册GitHub就不用我多言。" class="headerlink" title="1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。"></a><strong>1.</strong> 首先你得有一个GitHub账号。注册GitHub就不用我多言。</h4><h4 id="2-新建一个仓库"><a href="#2-新建一个仓库" class="headerlink" title="2. 新建一个仓库"></a><strong>2.</strong> 新建一个仓库</h4><p>记下你取的仓库名。</p><p>如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031123905.png" alt="1"></p><h4 id="3-生成一个token用于PicGo操作你的仓库："><a href="#3-生成一个token用于PicGo操作你的仓库：" class="headerlink" title="3. 生成一个token用于PicGo操作你的仓库："></a><strong>3.</strong> 生成一个token用于PicGo操作你的仓库：</h4><p>访问：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><h4 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4. 配置PicGo"></a><strong>4.</strong> 配置PicGo</h4><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>  中间不能出现空格，比如我创建了一个叫做Picture的仓库，在PicGo里我要设定的仓库名就是<code>wind-qin/Picture</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031124250.png" alt="图床1"></p><h4 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="5. 配置Typora"></a><strong>5.</strong> 配置Typora</h4><p>然后点击Typora左上角文件     偏好设置 点击图像</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120628.png" alt="image-20201106120619756"></p><p>点击验证图片上传选项为true则配置正确</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120714.png" alt="image-20201106120711559"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p>如想了解其他图床的安装请前往：</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A</a></p>]]></content>
      
      
      <categories>
          
          <category> github图床搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora写法</title>
      <link href="2020/10/15/Typora%E7%9A%84%E5%86%99%E6%B3%95/"/>
      <url>2020/10/15/Typora%E7%9A%84%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora的下载"><a href="#Typora的下载" class="headerlink" title="Typora的下载"></a>Typora的下载</h1><p><a href="https://share.weiyun.com/QOIBRwsr">下载</a></p><h1 id="Typora的写法"><a href="#Typora的写法" class="headerlink" title="Typora的写法"></a>Typora的写法</h1><h3 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h3><h4 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h4><p># 一阶标题 或者快捷键Ctrl+1</p><p>##二阶标题 或者快捷键Ctrl+2</p><p>###三阶标题 或者快捷键Ctrl+3</p><p>####四阶标题 或者快捷键Ctrl+4</p><p>#####五阶标题 或者快捷键Ctrl+5</p><p>######六阶标题 或者快捷键Ctrl+6</p><h4 id="标题Typora显示形式是"><a href="#标题Typora显示形式是" class="headerlink" title="标题Typora显示形式是"></a>标题Typora显示形式是</h4><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图01.png" alt=""></p><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><h4 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h4><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;这是要居中的文本内容&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="文本居中显示形式是"><a href="#文本居中显示形式是" class="headerlink" title="文本居中显示形式是"></a>文本居中显示形式是</h4><p><center>这是要居中的文本内容</center><br>注：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。 </p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><h4 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h4><pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;下划线的内容&lt;u&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者快捷键Ctrl+U</p><h4 id="下划线在Typora显示形式是"><a href="#下划线在Typora显示形式是" class="headerlink" title="下划线在Typora显示形式是"></a>下划线在Typora显示形式是</h4><p> <u>这就是我亲测的下划线</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>删除线使用格式</p><pre class="line-numbers language-none"><code class="language-none">~~删除线的内容~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除线在Typora显示形式是"><a href="#删除线在Typora显示形式是" class="headerlink" title="删除线在Typora显示形式是"></a>删除线在Typora显示形式是</h4><p><del>这是删除线的内容</del></p><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><h4 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h4><pre class="line-numbers language-none"><code class="language-none">**加粗字体** <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 或者快捷键Ctrl+B </p><h4 id="字体加粗在Typora显示形式是"><a href="#字体加粗在Typora显示形式是" class="headerlink" title="字体加粗在Typora显示形式是"></a>字体加粗在Typora显示形式是</h4><p><strong>加粗字体 This is a bold font</strong></p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><h4 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h4><pre class="line-numbers language-none"><code class="language-none">*字体倾斜了*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 或者快捷键Ctrl+I </p><h4 id="字体倾斜在Typora的显示形式"><a href="#字体倾斜在Typora的显示形式" class="headerlink" title="字体倾斜在Typora的显示形式"></a>字体倾斜在Typora的显示形式</h4><p> <em>字体倾斜了 This is a alanted font</em> </p><h3 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h3><p> 最简单粗暴的图片插入方式如图 :</p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图05.gif" alt=""></p><h3 id="视频的插入"><a href="#视频的插入" class="headerlink" title="视频的插入"></a>视频的插入</h3><p>方法一：</p><pre class="line-numbers language-none"><code class="language-none">&lt;video src&#x3D;&quot;地址&quot;&gt;&lt;&#x2F;video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-none"><code class="language-none">&lt;&#x2F;iframe height&#x3D;498 width&#x3D;510 src&#x3D;&quot;http:&#x2F;&#x2F;player.youku.com&#x2F;embed&#x2F;XNjcyMDU4Njg0&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：方法一可如插入图片般直接拉入，方法二由于插入视频后在博客中会将视频以下内容顶掉，在此将不再添加，如有兴趣可在Typora中添加尝试</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h4><p>第一种：<a href="http://www.simba.com">http://www.simba.com</a></p><p>第二种：快捷键Ctrl+K</p><pre class="line-numbers language-none"><code class="language-none">[自定义内容](超链接地址) 例如：[百度一下](www.baidu.com) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="超链接在Typora显示形式是：（必须以http开头）"><a href="#超链接在Typora显示形式是：（必须以http开头）" class="headerlink" title="超链接在Typora显示形式是：（必须以http开头）"></a>超链接在Typora显示形式是：（必须以http开头）</h4><p>第一种：<a href="http://www.simba.com">http://www.simba.com</a></p><p>第二种：<a href="https://blog.csdn.net/SIMBA1949/article/details/www.baidu.com">百度一下</a></p><p>按住Ctrl键+点击上面链接就可以直接访问该链接</p><h3 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h3><p> Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。 </p><h4 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h4><pre class="line-numbers language-none"><code class="language-none">&#96; &#96; &#96;+编程语言：例如java代码：&#96; &#96; &#96;java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在代码块的右下角写所用的编程语言</p><h4 id="代码区域在typora中显示形式"><a href="#代码区域在typora中显示形式" class="headerlink" title="代码区域在typora中显示形式"></a>代码区域在typora中显示形式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class simba&#123;  public static void main(String[] args)&#123;    System.out.println(&quot;梦回大唐&quot;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h3><h4 id="表格的二种使用格式"><a href="#表格的二种使用格式" class="headerlink" title="表格的二种使用格式"></a>表格的二种使用格式</h4><p> 第一种：快捷键<strong>Ctrl+T</strong>，会自动跳出设置行和列的设置框，如下图 </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图06.jpg" alt=""></p><p>第二种：</p><p>|国籍|省份|市区|</p><h3 id="表格在typora中显示形式"><a href="#表格在typora中显示形式" class="headerlink" title="表格在typora中显示形式"></a>表格在typora中显示形式</h3><p>第一种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>李太白</td><td>123456</td></tr></tbody></table></div><p>第二种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><p>右键  如图：</p><p> <img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图07.png" alt=""></p><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li><p>[x] JAVA</p></li><li><p>[x]  C</p></li><li><p>[ ]  C++</p></li><li><p>[ ]  Python</p><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图08.png" alt=""></p></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h4><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</p><h4 id="列表在typora中的显示形式"><a href="#列表在typora中的显示形式" class="headerlink" title="列表在typora中的显示形式"></a>列表在typora中的显示形式</h4><ul><li>java</li><li>C</li><li>C++</li><li>Python</li></ul><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><h4 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h4><p><em>*</em>或者- - -</p><h4 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h4><hr><hr><p> 注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图03.png" alt=""></p><h3 id="改变字体的颜色"><a href="#改变字体的颜色" class="headerlink" title="改变字体的颜色"></a>改变字体的颜色</h3><h4 id="改变颜色的格式"><a href="#改变颜色的格式" class="headerlink" title="改变颜色的格式"></a>改变颜色的格式</h4><pre class="line-numbers language-none"><code class="language-none">&lt;font color&#x3D;&#39;red&#39;&gt;改变字体的颜色&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="字体在typora中显示形式"><a href="#字体在typora中显示形式" class="headerlink" title="字体在typora中显示形式"></a>字体在typora中显示形式</h4><font color='red'>改变字体的颜色</font><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="注释的格式"><a href="#注释的格式" class="headerlink" title="注释的格式"></a>注释的格式</h4><pre class="line-numbers language-none"><code class="language-none">&lt;!--才能够显示--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：注释后Typora中显示注释的内容，但展示页面中不显示</p><h3 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table></div><p>注：一些实体符号需要在实体符号之前加””</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="2020/10/14/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/10/14/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>方法中的返回值有两种情况，即有返回值和无返回值，如果定义方法时有返回值类型，就需要返回相对应的数据类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">基本数据类型    值传递，不改变自身引用数据类型    引用传递，改变自身void    无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、一个方法只能有一个返回值2、分支结构的每一个分支都需要正确的返回值3、返回值可以接收也可以不接收<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h4><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>结束当前方法，返回至调用方法处，如果定义了返回值类型就返回对应类型的数据</p><p>【注意】<a href="">数据类型一致化</a></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">return 需要返回的数据;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、单一职能原则，一个方法只做一件事2、注意形参和实参数据类型一致化3、返回值类型和参数没有关系4、方法名要符合小驼峰命名规则5、return的下一行代码不会执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有返回值方法调用"><a href="#有返回值方法调用" class="headerlink" title="有返回值方法调用"></a>有返回值方法调用</h3><h4 id="无参有返回值的方法：give-me-five"><a href="#无参有返回值的方法：give-me-five" class="headerlink" title="无参有返回值的方法：give me five"></a>无参有返回值的方法：give me five</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TestMethod1 &#123;public static void main(String[] args) &#123;System.out.println(giveMeFive());&#125;&#x2F;*** 返回一个整数 5** @return 5 int类型*&#x2F;public static int giveMeFive() &#123;return 5;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="有参有返回值的方法：两个数求和"><a href="#有参有返回值的方法：两个数求和" class="headerlink" title="有参有返回值的方法：两个数求和"></a>有参有返回值的方法：两个数求和</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodDemo6 &#123;public static void main(String[] args) &#123;&#x2F;* * 调用自定义getSumOfTwoNumber方法，需要两个int类型的参数，并得到一个int类型的返回值 *  * 参数列表一定要和方法声明上的参数类型完全一致 *&#x2F; int total &#x3D; getSumOfTwoNumber(1, 2);System.out.println(total);    &#125;        &#x2F;** * 两个整数进行求和 *  * @param num1 求和的第一个数 * @param num2 求和的第二个数 * @return 返回两个参数的和，int类型 *&#x2F;public static int getSumOfTwoNumber(int num1, int num2)&#123;return num1 + num2;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】调用带有多参数的方法，要求传入的参数数据类型，个数和顺序还有数据类型必须和方法声明一致</p><h4 id="规范化return"><a href="#规范化return" class="headerlink" title="规范化return"></a>规范化return</h4><p>在一个方法中，return出现的次数要尽可能得少，为了提高阅读性和逻辑性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TestMethod4 &#123;public static void main(String[] args) &#123;System.out.println(getCompare(3,2));&#125;&#x2F;*** 比较大小，返回较大的那个数** @param num1 int类型* @param num2 int类型* @return int类型的结果*&#x2F;public static int getCompare(int num1, int num2) &#123;return num1 &gt; num2 ? num1 : num2;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、break 是退出当前循环结构，return 是退出当前方法2、如果返回值类型是 void ，可以返回 null 或者不返回或者 return;3、一个方法可以有多个 return，但只能有一个返回值4、返回值可以接收也可以不接收，由调用者决定如何调用5、分支结构里的每一个分支都需要有正确的返回值6、对返回值的处理方式因情况而定，可以打印、参与运算或者当做其他方法的实参7、调用带有多参数的方法，要求传入的参数数据类型，个数和顺序和类型必须和方法声明一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】方法具有单一职能原则，一个函数只做一件事</p><h3 id="方法重载【Overload】"><a href="#方法重载【Overload】" class="headerlink" title="方法重载【Overload】"></a>方法重载【Overload】</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一个类或者接口中定义多个相同名称的方法</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、必须在同一个类中2、方法名必须一致3、参数必须不一致(个数，顺序，类型)4、与访问修饰符、返回值类型无关<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodDemo9 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 调用同名方法，传入不同的参数列表，即可实现方法的重载play();play(&quot;英雄联盟&quot;);play(&quot;红色警戒&quot;, 2);play(1, &quot;DNF&quot;);&#125;public static void play() &#123;System.out.println(&quot;玩王者荣耀&quot;);&#125;public static void play(String gameName) &#123;System.out.println(&quot;玩&quot; + gameName);&#125;public static void play(String gameName, int time) &#123;System.out.println(&quot;玩&quot; + gameName + time + &quot;小时&quot;);&#125;public static void play(int time, String gameName) &#123;System.out.println(&quot;玩&quot; + gameName + time + &quot;小时&quot;);&#125;&#x2F;*  * Duplicate method play(String, int) in type MethodDemo9 *  * 跟返回值类型无关，只关注方法名和参数类型 *&#x2F;&#x2F;&#x2F;public static String play(String gameName, int time) &#123;&#x2F;&#x2F;return &quot;玩&quot; + gameName + time + &quot;小时&quot;;&#x2F;&#x2F;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>满足需求多样化，屏蔽使用差异，灵活、方便</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p>方法的重载我们只关注方法名和参数类型，要求方法名必须一致，参数列表必须不一致（个数，顺序，类型）</p></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在方法内部或者形参列表上定义的变量（包括mian方法）</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>从定义局部变量的那一行到所在的代码块结束</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;    &#125;for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】两个for循环中，i 循环变量分别属于不同的大括号以内，不同的作用域空间，并不冲突</p><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>从方法被调用的时刻算起到函数返回调用处的时刻结束</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;    &#125;System.out.println(i); &#x2F;&#x2F; 报错，找不到符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】for 循环结束时局部变量 i 的生存期结束，在 for 循环外无法使用 i</p><h4 id="单一性，不能重名"><a href="#单一性，不能重名" class="headerlink" title="单一性，不能重名"></a>单一性，不能重名</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 报错！for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;    for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】在一个方法内局部变量不能多次定义</p><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Test &#123;public static void main(String[] args) &#123;        int num &#x3D; 5;        test(num);                System.out.println(num);&#x2F;&#x2F; 5    &#125;        public static void test(int num) &#123;        num &#x3D; 10;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】基本数据类型作为参数传递给局部变量时，传递的是值，局部变量的更改不影响实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">值传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\值传递.jpg" alt="值传递"></td></tr></tbody></table></div><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MethodDemoC &#123;public static void main(String[] args) &#123;int[] arr &#x3D; new int[5];System.out.println(&quot;调用方法前：&quot; + arr[0]);test(arr);System.out.println(&quot;调用方法后：&quot; + arr[0]);&#125;public static void test(int[] arr) &#123;arr[0] &#x3D; 1;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】引用数据类型传递时传递的是地址，局部变量直接作用于实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">引用传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\引用传递.jpg" alt="引用传递"></td></tr></tbody></table></div><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">局部变量声明在函数中，从定义的那一行开始到函数结束时被销毁局部变量必须先赋值再使用局部变量不能重复定义值传递：基本数据类型的传递不改变实参引用传递：引用数据类型的传递会改变实参Java中只有值传递，引用传递传递的是地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="学习要求"><a href="#学习要求" class="headerlink" title="学习要求"></a>学习要求</h4><blockquote><p>1、听不懂没关系，不影响写代码，读着代码就会写了。</p><p>2、先会用，在用的过程中逐渐加深对面向对象的理解。</p><p>3、利用不断地练习，形成<code>肌肉记忆</code>(代码格式)和<code>意识记忆</code>(要啥给啥)。（<font color='red'>开发中重要的思想而不是语法</font>）</p></blockquote><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><blockquote><p>面向过程编程（POP —&gt; <strong>Process-Oriented Programming</strong>）代表：C语言</p><p>面向对象编程（OOP —&gt; <strong>Object-Oriented Programming</strong>）代表：C++、Java</p><p>面向切面编程（AOP —&gt; <strong>Aspect-Oriented Programming</strong>）代表：Java</p></blockquote><h4 id="面向对象的定义"><a href="#面向对象的定义" class="headerlink" title="面向对象的定义"></a>面向对象的定义</h4><p>面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p><a href="">找合适的人做合适的事</a></p><h4 id="生活中的面向对象和面向过程"><a href="#生活中的面向对象和面向过程" class="headerlink" title="生活中的面向对象和面向过程"></a>生活中的面向对象和面向过程</h4><p>举例：<strong>想吃烤羊排</strong></p><blockquote><p>面向对象：找个店铺吃</p><p>​    1、去羊排店</p><p>​    2、点一斤羊排</p><p>​    3、等25分钟</p><p>​    4、吃</p><p>​    5、付款走人</p><p>面向过程：自己做着吃</p><p>​    1、自己做羊排</p><p>​        1.准备材料（羊、辅料、调料）</p><p>​        2.备料</p><p>​        3.烤箱预热，开烤</p><p>​        4.15分钟翻面一次</p><p>​        5.取出</p><p>​    2、吃</p><p>​    3、洗锅刷碗，打扫卫生</p></blockquote><h4 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、面向对象是基于面向过程的编程思想2、万物皆对象3、对象具有唯一性4、任何对象都具有一定的特征和行为；特征是事物的基本描述，行为是事物的功能5、类是一组相关的属性和方法的集合，是一个抽象的概念6、对象是类的具体存在7、在一组相同或相似的对象中，抽取出共性的特征和行为，保留所关注的部分就是类的抽取8、类是模板、图纸，通过类创造的对象就是实体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面向对象的优点"><a href="#面向对象的优点" class="headerlink" title="面向对象的优点"></a>面向对象的优点</h4><ul><li>直观，高效，与人类的思维习惯一致</li><li>信息隐藏，提高了程序的可维护性和安全性</li><li>提高了程序的可重用性</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><blockquote><p>面向过程：亲力亲为，自力更生，所有过程都要经历（诸葛亮是怎么死的，累死的）</p><p>面向对象：找合适的人做合适的事，直观高效（烤羊排）</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="生活中的类和对象"><a href="#生活中的类和对象" class="headerlink" title="生活中的类和对象"></a>生活中的类和对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">对象</th></tr></thead><tbody><tr><td style="text-align:center">人类</td><td style="text-align:center">马云爸爸，麻花藤（<font color='red'>隔壁老王、女朋友</font>）</td></tr><tr><td style="text-align:center">狗类</td><td style="text-align:center">史努比，忠犬八公，高飞，斯派克，小白，王可可（<font color='red'>单身狗、旺财、金毛、哈士奇</font>）</td></tr><tr><td style="text-align:center">英雄类</td><td style="text-align:center">Faker的劫，The Shy的卢锡安，霸哥的石头人，马老师的螳螂（<font color='red'>盖伦、锤石、EZ</font>）</td></tr><tr><td style="text-align:center">化妆品类</td><td style="text-align:center">我的洗面奶（<font color='red'>阿玛尼405唇釉，chill小辣椒口红，黛珂水乳，雅诗兰黛粉底液，nars腮红</font>）</td></tr></tbody></table></div><p>这些对象有什么特点？</p><blockquote><p>人类：</p><ul><li>马云爸爸，麻花藤</li></ul><p>​    都是特立独行的个体，我们一提起这个个体脑海中就能浮现出他的形象，</p><ul><li>隔壁老王、女朋友</li></ul><p>​    这些都不是对象，因为每个人都会有自己的隔壁老王，都有自己的女朋友，你脑海中的隔壁老王和你同桌脑海中的隔壁老王是同一个人吗？除非你们是同一个邻居还姓王那就不说了。但你们的女朋友总不会也是同一个吧？所以说，女朋友，隔壁老王都不是对象，你的隔壁老王，你的女朋友才是个对象！！！</p><p>狗类：</p><ul><li>史努比，忠犬八公，高飞，斯派克，小白，王可可</li></ul><p>​    这些都是独一无二的</p><ul><li>单身狗、旺财、金毛、哈士奇</li></ul><p>​    这些全都是类</p></blockquote><h4 id="Java中的类和对象"><a href="#Java中的类和对象" class="headerlink" title="Java中的类和对象"></a><font color='red'>Java中的类和对象</font></h4><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类是对某一类事物的描述，是抽象的、概念上的定义。<strong>类是模板，包含了一类事物所共有的特征(属性)和行为(方法)</strong></p><p>以人类为例：</p><blockquote><p>属性描述：学号、姓名、性别、年龄、身高、体重、地址、电话、微信、QQ…</p><p>行为描述：吃饭、睡觉、上班、学习、娱乐…</p></blockquote><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>对象是类的具体体现（<a href="">属性和方法</a>），是具体的、独一无二的个体。</strong></p><p>以班长为例：</p><blockquote><p>属性描述：班长的学号、班长的姓名、班长的身高…</p><p>行为描述：班长吃饭、班长睡觉、班长学习…</p></blockquote><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是对象的抽象，对象是类的具体实现</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><font color='red'>类的定义</font></h4><p>类是一种自定义的数据类型</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">格式：class 类名 &#123;成员变量;&#x2F;&#x2F; Field成员方法;&#x2F;&#x2F; Method&#125;class：定义类的关键字类名：大驼峰命名，首字母大写，见名知意类名就是一种数据类型（自定义引用的数据类型），就是模板的名字成员变量（属性&#x2F;特征描述）：定义在类中，方法外的变量，用来描述类的特征成员方法（行为描述）：定义在类中，用来描述类的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Student &#123;    &#x2F;&#x2F; 成员变量【Field】String name;int age;char sex;    &#x2F;&#x2F; 成员方法【Method】public void eat() &#123;System.out.println(&quot;吃&quot;);&#125;public void sleep() &#123;System.out.println(&quot;睡&quot;);&#125;public void play() &#123;System.out.println(&quot;玩&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类和对象-1"><a href="#类和对象-1" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><font color='red'>对象的创建</font></h4><p>参考Scanner的创建，依葫芦画瓢</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner sc &#x3D; new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 格式：    类名 对象名 &#x3D; new 类名([参数...]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person person &#x3D; new Person();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a><font color='red'>对象的使用</font></h4><p>参考数组和 Scanner 的使用，依葫芦画瓢</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] array &#x3D; new int[10];array.length    &#x2F;&#x2F; 注意：这里没有 ()，说明这不是方法，那它是什么？我们用它来表示数组的长度，数组的长度是数组的一个属性    Scanner sc &#x3D; new Scanner(System.in);sc.nextInt();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">格式：使用成员变量：对象名.成员变量    使用成员方法：    对象名.成员方法()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 通过Person类对象person操作name、sex、age属性&#x2F;&#x2F; 进行赋值操作person.name &#x3D; &quot;张三&quot;;person.age &#x3D; 25;person.sex &#x3D; &#39;男&#39;;&#x2F;&#x2F; 通过person进行取值操作System.out.println(person.name);System.out.println(person.age);System.out.println(person.sex);person.eat();person.sleep();person.play(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>. 的含义是 “的”</p><p>person.name：person的name</p><p>person.age：person的年龄</p><p>person.sex：person的性别</p><p>扩展：</p><p>如果直接打印对象名，会得到一个对象的【地址】，这个地址包含两部分：1、完整的包名；2、当前对象存储在堆区内存中的空间首地址</p></blockquote><h4 id="对象内存分析图"><a href="#对象内存分析图" class="headerlink" title="对象内存分析图"></a>对象内存分析图</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\java面向对象01.png" alt=""></td></tr></tbody></table></div><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><blockquote><p>没听懂没关系，多敲代码，读着代码就懂了</p><p>生活中的类和对象</p><ul><li>类是事物的统称，是一个抽象的概念</li><li>对象是事物的表现，是具体的，独一无二的</li></ul><p>Java中的类和对象</p><ul><li>类是对象的抽象，具有公共的特征和行为，对象是类的具体实现，具有唯一的特征和行为</li></ul><p>基础数据类型与类和对象</p><ul><li>类就是一种自定义的数据类型，由类名，属性和方法构成</li><li>对象就是一种数据类型的数据，由对象名，属性和方法构成</li></ul><p>类和对象的定义和使用</p><ul><li>格式和规范，一定要按照标准</li></ul><p><strong>注意</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;大写开头的都是类&gt;小写开头的都是变量&gt;带()的都是方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><blockquote><p>构造方法很重要，但是比较鸡肋</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构造方法（<code>Constructor</code>）的名称和类名相同，没有返回值类型。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>类中的特殊方法，用于<font color='red'>创建对象</font>，在创建对象的时候会执行一些初始化操作，如给成员属性赋初值</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">格式：    类名([参数...])&#123;&#125;    Student()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><font color='red'>注意</font>：格式问题>1、构造方法的方法名与类名完全相同>>2、构造方法没有返回值类型>>3、创建对象时，触发构造方法的调用，不可手动调用>>4、如果没有声明构造方法，编译器默认生成无参构造方法>>5、如果定义了有参构造方法，编译器就不会创建无参构造方法>>【<font color='red'>强制要求</font>】>><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&gt;无论什么时候，都要加上一个无参构造方法！！！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>#### 构造方法的使用<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 自定义有参构造方法，并给name属性赋值Dog(String n) &#123;name &#x3D; n;&#125;&#x2F;&#x2F; 自定义无参构造方法Dog()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>### 构造方法的重载<pre class="line-numbers language-java" data-language="java"><code class="language-java">public Dog(String n)&#123;    name &#x3D; n;&#125;public Dog(String n, int i)&#123;    name &#x3D; n;    age &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>#### 总结>1. 构造方法是用来创建对象，在创建对象的过程中会进行初始化操作（为对象赋值）>>2. 构造方法也是方法，除了没有返回值，其他的都跟方法一样>>按照方法参数列表的类型、个数、顺序去匹配，如果没有找到对应的就会报错>>3. 无论什么时候，都一定要给一个无参构造方法#### 扩展：反编译<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">javap -c -l -private 类名.class<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>#### 扩展：对象的创建过程<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、类加载2、内存中开辟对象空间3、为各个属性赋予初始值4、执行构造方法中的代码5、将对象的地址赋值给变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>### this关键字#### 概述this代表所在类的对象引用，即当前对象>new 创建出来的对象>>调用方法的对象#### 作用1、<font color='red'>调用本类中的属性和方法（区别成员变量和局部变量）</font><p>2、调用本类中的其他构造方法：this()</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">格式：this([参数...]);会根据参数列表调用对应的构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Rabbit(String color) &#123;&#x2F;&#x2F; 调用本类中的属性this.color &#x3D; color;&#125;public Rabbit(String color, int age, double weight) &#123;    &#x2F;&#x2F; 调用本类中的其他构造方法this(color);this.age &#x3D; age;this.weight &#x3D; weight;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、this()只能在构造方法中使用2、this()只能在第一行3、构造方法中不能同时出现两个this()，因为24、不能自己调用自己，不能相互调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="规范化this"><a href="#规范化this" class="headerlink" title="规范化this()"></a>规范化this()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Son &#123;String name;int age;float salary;public Son() &#123;&#125;public Son(String name) &#123;        &#x2F;&#x2F; 调用Son(String name, int age, float salary)this(name, 0, 0.0F);&#125;public Son(String name, int age) &#123;        &#x2F;&#x2F; 调用Son(String name, int age, float salary)this(name, age, 0.0F);&#125;public Son(String name, int age, float salary) &#123;this.name &#x3D; name;this.age &#x3D; age;this.salary &#x3D; salary;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>this表示的是当前对象</li><li>this可以调用本类中的属性和方法，最常用与区分成员变量和局部变量</li><li>this还可以调用本类中的构造方法，但是要注意有坑</li></ul></blockquote><h3 id="访问-权限-修饰符"><a href="#访问-权限-修饰符" class="headerlink" title="访问(权限)修饰符"></a>访问(权限)修饰符</h3><h4 id="private-私有-关键字"><a href="#private-私有-关键字" class="headerlink" title="private(私有)关键字"></a>private(私有)关键字</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">1、可以修饰成员变量和成员方法2、被private修饰的变量和方法仅本类中可用3、被private修饰的变量需要提供get、set方法供类外调用使用    4、boolean类型的 get 方法比较特殊：        public boolean isName(String name)&#123;        return name;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Dog &#123;private String name;int age;public String getName() &#123;return this.name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;private void function() &#123;System.out.println(&quot;method be execute!&quot;);&#125;public void executeFunction() &#123;this.function();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java中的访问修饰符"><a href="#Java中的访问修饰符" class="headerlink" title="Java中的访问修饰符"></a>Java中的访问修饰符</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">类内部</th><th style="text-align:center">同包下</th><th style="text-align:center">子类中</th><th style="text-align:center">非同包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">默认不写</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></div><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、一般我们最常用的就是private和public，建议任何情况下都使用访问修饰符对变量和方法进行限制</p><p>2、public权限最高，整个项目中都可以访问（同一个项目），private权限最小，只能在本类中使用</p><p>3、被private修饰的变量和方法可以通过提供公共的方法对其进行访问</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><blockquote><p>封装</p><p>继承</p><p>多态</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。核心是<font color='red'>归纳总结</font></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>提高代码的复用度、安全性，不必关心具体细节，便于开发</p><h4 id="JavaBean-规范化封装"><a href="#JavaBean-规范化封装" class="headerlink" title="JavaBean 规范化封装"></a>JavaBean 规范化封装</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1. 要求Java中的所有实体类成员变量全部私有化，最少提供一个无参数构造方法，对应成员变量实现setter和getter方法2. JavaBean规范，是为了后期开发汇总更好的代码适配度，提高代码运行的统一性，能够满足框架的使用3. JavaBean规范只是一个规范，而且是作为一个基础规范，操作都是可以使用快捷键来完成的！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person &#123;private String name;private int age;private char sex;private boolean alive;public Person() &#123;&#125;public String getName() &#123;return this.name;&#125;public int getAge() &#123;return this.age;&#125;public char getSex() &#123;return this.sex;&#125;public boolean isAlive() &#123;return alive;&#125;public void setAlive(boolean alive) &#123;this.alive &#x3D; alive;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;public void setAge(int age) &#123;this.age &#x3D; age;&#125;public void setSex(char sex) &#123;this.sex &#x3D; sex;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>没有名字的对象，是对象的一种简化表示形式</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>一次性，每次使用都是一个新的对象</p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><blockquote><p>1、对象调用方法仅使用一次，然后等待销毁</p><p>2、作为实际参数传递</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestDog&#123;public static void main(String[] args) &#123;        &#x2F;&#x2F; 对象调用方法仅使用一次new Dog().sleep();        &#x2F;&#x2F; 作为实际参数传递useDog(new Dog());&#125;public static void useDog(Dog dog) &#123;dog.sleep();&#125;&#125;class Dog &#123;String name;int age;public void sleep() &#123;System.out.println(&quot;小狗睡觉.....&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>提高开发效率，简化代码结构</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容。这个关系叫继承。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">关键字：extends格式:class Son extends Father &#123;    &#125;一个孩子只能有一个父亲一个父亲可以有多个孩子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、Java为单继承，一个类只能有一个直接父类，但可以多级继承，属性和方法逐级叠加2、构造方法只可服务于本类，不可继承，子类执行构造方法前会默认调用父类的无参构造方法。可以通过super()去访问父类的构造方法3、private 修饰的属性和方法不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 创建一个父类对象Father father &#x3D; new Father();&#x2F;&#x2F; 父类调用父类的属性和方法father.name &#x3D; &quot;父&quot;;System.out.println(father.name);father.game();System.out.println(&quot;-------------&quot;);&#x2F;&#x2F; 创建一歌子类对象Son son &#x3D; new Son();&#x2F;&#x2F; 子类调用子类的属性和方法son.age &#x3D; 16;System.out.println(son.age);son.study();&#x2F;&#x2F; 子类调用父类的属性和方法(public修饰)son.name &#x3D; &quot;子&quot;;System.out.println(son.name);son.game();&#x2F;* * 子类调用父类private修饰的属性和方法 *  * 报错 * The field Father.suffer is not visible * The method cook() from the type Father is not visible *  * 由此可知子类不能调用父类私有化的属性和方法 *&#x2F;&#x2F;&#x2F;son.suffer &#x3D; 10;&#x2F;&#x2F;son.cook();&#125;&#125;public class Father &#123;public String name;private int suffer;public void game() &#123;System.out.println(&quot;下棋&quot;);&#125;private void cook() &#123;System.out.println(&quot;做饭&quot;);&#125;&#125;public class Son extends Father&#123;public int age;public void study() &#123;System.out.println(&quot;子类 -- 学习&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="子类构造方法执行前默认先执行父类的无参构造方法"><a href="#子类构造方法执行前默认先执行父类的无参构造方法" class="headerlink" title="子类构造方法执行前默认先执行父类的无参构造方法"></a>子类构造方法执行前默认先执行父类的无参构造方法</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Father &#123;String name;public Father() &#123;System.out.println(&quot;Father&#39;s Constrator be performed&quot;);&#125;&#125;class Son extends Father &#123;int age;public Son() &#123;System.out.println(&quot;Son&#39;s Constrator be performed&quot;);&#125;&#125;public class TestSon &#123;public static void main(String[] args) &#123;Son son &#x3D; new Son();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Father&#39;s Constrator be performedSon&#39;s Constrator be performed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】Son 的构造方法中编译器默认生成 super(); 用来调用父类的构造方法，目的是为了初始化父类字段，因为子类可能会用到</p><div class="table-container"><table><thead><tr><th style="text-align:center">继承内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\继承内存分析图.jpg" alt="继承内存分析图"></td></tr></tbody></table></div><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、提高了代码的复用性2、提高了代码的维护性3、让类与类之间产生了一个关系，是多态的前提<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、让类的耦合性增强。这样某个类的改变，就会影响到其他和该类相关的类2、打破了封装性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Java中只有单继承</p><p>子类可以继承父类的非私有属性和方法（非private修饰的）</p><p>执行子类的构造方法前会默认执行父类的无参构造方法</p></blockquote><h3 id="方法重写【Override】"><a href="#方法重写【Override】" class="headerlink" title="方法重写【Override】"></a>方法重写【Override】</h3><h4 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h4><p>开发中父类的方法不一定适用于子类，因为父类方法不能更改，在子类中新增方法会造成代码的冗余，而且不符合逻辑</p><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、应用于继承和实现接口2、方法的返回值类型，方法名，形参列表与父类一致3、使用@Override注解来标识4、重写方法的访问修饰符权限不能低于父类private &lt; 默认(什么都不写) &lt; protected &lt; public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Son extends Father&#123;public int age;@Overridepublic void game() &#123;System.out.println(&quot;玩红色警戒&quot;);&#125;public void study() &#123;System.out.println(&quot;子类 -- 学习&quot;);&#125;&#125;public class Father &#123;public String name;private int suffer;public void game() &#123;System.out.println(&quot;下棋&quot;);&#125;private void cook() &#123;System.out.println(&quot;做饭&quot;);&#125;&#125;public class Demo1 &#123;public static void main(String[] args) &#123;Son son &#x3D; new Son();son.game();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>既沿袭了父类的方法名，又实现了子类的扩展</p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、方法的重写能够在不新增方法的情况下实现子类的扩展</p><p>2、方法重写要求方法声明格式和父类完全一致（访问修饰符不能小于父类）</p><p>3、@Overrid关键字用来开启格式检测，如果不一致就会报错</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote><p>super指父类对象，用来区分父类和子类，用于调用父类的属性和方法</p><p>用法和this非常类似：this指当前对象，super指父类对象</p></blockquote><h4 id="调用父类的属性和方法"><a href="#调用父类的属性和方法" class="headerlink" title="调用父类的属性和方法"></a>调用父类的属性和方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Father &#123;public int age &#x3D; 60;public void play() &#123;System.out.println(&quot;下象棋&quot;);&#125;&#125;public class Son extends Father &#123;public int age &#x3D; 16;@Overridepublic void play() &#123;System.out.println(&quot;玩游戏&quot;);&#125;public void showAge() &#123;int age &#x3D; 20;System.out.println(&quot;局部变量：&quot; + age);System.out.println(&quot;当前对象成员变量：&quot; + this.age);System.out.println(&quot;父类对象成员变量：&quot; + super.age);&#125;public void callPlay() &#123;&#x2F;&#x2F; 调用当前对象的方法this.play();&#x2F;&#x2F; 调用父类对象的方法super.play();&#125;&#125;public class Demo &#123;public static void main(String[] args) &#123;Son son &#x3D; new Son();son.showAge();son.callPlay();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h4><p>默认调用父类的无参构造，且必须在代码的第一行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Father &#123;private String name;public Father() &#123;System.out.println(&quot;Father&#39;s Constrator be performed&quot;);&#125;        public Father(String name) &#123;        System.out.println(&quot;Father&#39;s Constrator be performed with name&quot;);    &#125;&#125;class Son extends Father &#123;private int age;public Son() &#123;        super();System.out.println(&quot;Son&#39;s Constrator be performed&quot;);&#125;        public Son(String name, int age) &#123;        super(name);        this.age &#x3D; age;System.out.println(&quot;Son&#39;s Constrator be performed with name and age&quot;);&#125;&#125;public class TestSon &#123;public static void main(String[] args) &#123;Son son &#x3D; new Son();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、super指父类对象，对比this关键字，使用方法都一样</p><p>2、super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><p>3、父类的属性要交给父类的构造方法去操作，没什么事就不要去使用 super() 来调用父类的构造方法了</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>final表示最终的，用来修饰变量，方法和类</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、final 修饰的局部变量只能被赋值一次2、final 修饰的成员变量只能被赋值一次，并且必须在声明时就赋值3、final 修饰的基本类型变量是一个常量(只能被赋值一次)，引用类型变量不可修改地址，如对象4、final 修饰的方法不能被重写5、final 修饰的类不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.fc.j._final;&#x2F;* * final修饰的局部变量 *&#x2F;public class FinalDemo1 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 测试final修饰的修饰的变量final int num;num &#x3D; 10;System.out.println(num);&#x2F;* * 被final修饰的变量只能赋值一次 *  * The final local variable num may already have been assigned *  * 被final修饰的局部变量num可能已经被赋值 *&#x2F;&#x2F;&#x2F; num &#x3D; 20;&#125;&#125;&#x2F;&#x2F; final修饰的类不能被继承，断子绝孙class Father &#123;&#x2F;* * final 修饰的成员变量必须在声明时就赋值 *  * The blank final field age may not have been initialized * 空白的final成员变量可能未被初始化 *&#x2F; &#x2F;&#x2F; final int age;final int age &#x3D; 16;public final void play() &#123;System.out.println(&quot;下棋&quot;);&#125;&#125;class Son extends Father &#123;&#x2F;* *  Cannot override the final method from Father *  无法重写被final修饰的方法 *&#x2F;&#x2F;&#x2F;@Override&#x2F;&#x2F;public final void play() &#123;&#x2F;&#x2F;&#x2F;&#x2F;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>final修饰可以保证安全性，比如数组的长度属性，String类，这些都是final修饰的，保证不可变</p><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、final表示最终的，可以修饰变量，属性和方法</p><p>2、final修饰的基本数据类型的成员变量只能被赋值一次</p><p>3、final修饰的引用数据类型的成员变量地址不可变，但不影响地址所指向的对象的操作</p><p>4、final修饰的方法不能被重写</p><p>5、final修饰的类不能被继承</p></blockquote><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>static 关键字方便在<strong>没有创建对象的情况下来进行调用方法和变量</strong>(优先级高于对象)，可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能</p><h4 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PersonDemo &#123;public static void main(String[] args) &#123;Person person1 &#x3D; new Person(&quot;张三&quot;, 16);Person person2 &#x3D; new Person(&quot;李四&quot;, 17);Person person3 &#x3D; new Person(&quot;王五&quot;, 18);Person person4 &#x3D; new Person(&quot;赵六&quot;, 19);&#x2F;* * The static field Person.address should be accessed in a static way * 静态成员变量应该通过静态的方式访问（注意这里是应该，不是必须） *  * Change access to static using &#39;Person&#39; (declaring type) * 使用Person声明类型来更改对静态的访问 * 通过类名来操作成员变量：Person.address *&#x2F;System.out.println(&quot;姓名：&quot; + person1.name + &quot; 年龄：&quot; + person1.age + &quot; 地址：&quot; + Person.address);System.out.println(&quot;姓名：&quot; + person2.name + &quot; 年龄：&quot; + person2.age + &quot; 地址：&quot; + Person.address);System.out.println(&quot;姓名：&quot; + person3.name + &quot; 年龄：&quot; + person3.age + &quot; 地址：&quot; + Person.address);System.out.println(&quot;姓名：&quot; + person4.name + &quot; 年龄：&quot; + person4.age + &quot; 地址：&quot; + Person.address);&#x2F;&#x2F; 通过类名直接调用static修饰的成员变量，此时是没有对象的System.out.println(&quot;没有对象：&quot; + Person.address);&#x2F;* *  Cannot make a static reference to the non-static field Person.name *   *  将name添加static后没有报错 *&#x2F;&#x2F;&#x2F;System.out.println(&quot;没有对象：&quot; + Person.name);&#x2F;* * 通过对象调用statice修饰的成员方法 *  * The static method test() from the type Person should be accessed in a static way *&#x2F;&#x2F;&#x2F; person1.testStatic();&#x2F;&#x2F; 通过类名直接调用静态方法Person.testStatic();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、通过类名调用静态成员变量，因为静态变量与对象无关2、静态变量被所有对象共享，一处更改处处更改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h4><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person &#123;public String name &#x3D; &quot;张三&quot;;public int age;public static String address &#x3D; &quot;郑州&quot;;public Person() &#123;super();&#125;public Person(String name, int age) &#123;super();this.name &#x3D; name;this.age &#x3D; age;&#125;&#x2F;&#x2F; 自定义static修饰的成员方法public static void testStatic() &#123;&#x2F;* * 静态方法不能调用非静态方法 * Cannot make a static reference to the non-static method test() from the type Person *&#x2F;&#x2F;&#x2F; test();System.out.println(&quot;static mothed&quot;);&#x2F;* * 不能再静态方法中使用this关键字 *  * Cannot use this in a static context *&#x2F;&#x2F;&#x2F; this.name;&#125;public void test() &#123;System.out.println(&quot;method&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、static修饰的方法不能访问本类中的非静态变量和方法，不能使用this2、通过类名来调用静态成员方法，工具类的应用很广泛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、static修饰的成员变量和方法都是对象所共享的资源，对其进行的操作回作用于所有对象。</p><p>2、static修饰的成员变量和方法依赖于类不依赖于对象，即没有对象</p><p>3、static修饰的成员变量和成员方法都可以通过类名调用，没有对象</p><p>4、静态不能调用费静态，不能使用this关键字，没有对象</p><p>5、静态变量常和final关键字搭配作为常量使用，静态方法常用于工具类</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">static成员变量内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\static成员变量内存分析图.jpg" alt="static成员变量内存分析图"></td></tr></tbody></table></div><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>在 Java 中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)</p><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">格式：&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、用于给对象初始化，多个构造方法中相同的代码存放到一起，每次调用构造方法都会执行，并且在构造方法前执行2、只有创建对象时调用，类不能调用3、构造代码块可以有多个，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person &#123;&#123;System.out.println(&quot;Person构造代码块执行&quot;);&#125;public Person() &#123;System.out.println(&quot;Person构造方法执行&quot;);&#125;&#125;public class TestPerson &#123;public static void main(String[] args) &#123;System.out.println(&quot;main方法&quot;);new Person();new Person();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">格式：    static &#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、用于给类进行初始化，在加载的时候就执行，并且只执行一次2、优先级高于主函数3、静态代码块可以有多个，顺序执行，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person &#123;static &#123;System.out.println(&quot;Person静态代码块执行&quot;);&#125;public Person() &#123;System.out.println(&quot;Person构造方法执行&quot;);&#125;&#125;public class TestPerson &#123;static &#123;System.out.println(&quot;静态代码块1执行&quot;);&#125;public static void main(String[] args) &#123;System.out.println(&quot;main方法&quot;);new Person();new Person();&#125;static &#123;System.out.println(&quot;静态代码块2执行&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">静态代码块1执行静态代码块2执行main方法Person静态代码块执行Person构造方法执行Person构造方法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码块相关执行顺序"><a href="#代码块相关执行顺序" class="headerlink" title="代码块相关执行顺序"></a>代码块相关执行顺序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Father &#123;public Father() &#123;System.out.println(&quot;父类构造方法执行~~~&quot;);&#125;&#123;System.out.println(&quot;父类构造代码块执行~~~&quot;);&#125;static &#123;System.out.println(&quot;父类静态代码块执行~~~&quot;);&#125;public static void function() &#123;System.out.println(&quot;父类静态成员方法执行~~~&quot;);&#125;&#125;public class Son extends Father&#123;public Son() &#123;System.out.println(&quot;子类构造方法执行~~~&quot;);&#125;&#123;System.out.println(&quot;子类构造代码块执行~~~&quot;);&#125;static &#123;System.out.println(&quot;子类静态代码块执行~~~&quot;);&#125;public static void function() &#123;System.out.println(&quot;子类静态成员方法执行~~~&quot;);&#125;public static void main(String[] args) &#123;System.out.println(&quot;main方法执行~~~&quot;);new Son();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">父类静态代码块执行~~~子类静态代码块执行~~~main方法执行~~~父类构造代码块执行~~~父类构造方法执行~~~子类构造代码块执行~~~子类构造方法执行~~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>执行顺序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;static Test test1 &#x3D; new Test();static Test test2 &#x3D; new Test();static &#123;System.out.println(&quot;静态代码块&quot;);&#125;&#123;System.out.println(&quot;构造代码块&quot;);&#125;public Test() &#123;System.out.println(&quot;构造方法&quot;);&#125;public static void main(String[] args) &#123;        System.out.println(&quot;main方法&quot;);new Test();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">构造代码块构造方法构造代码块构造方法静态代码块main方法构造代码块构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、构造代码块用于给对象初始化，每次创建对象都会调用构造代码块，并且执行顺序在构造方法之前</p><p>2、静态代码块用于给类初始化，当类被加载的时候就会调用静态代码块（只执行一次），执行顺序在main方法之前</p></blockquote><h2 id="abstract关键字【抽象类】"><a href="#abstract关键字【抽象类】" class="headerlink" title="abstract关键字【抽象类】"></a>abstract关键字【抽象类】</h2><p>不能实例化的类就是抽象类，用 abstract 修饰</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">abstract class 类名 &#123;    成员变量    构造方法    成员方法        非抽象方法        抽象方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、抽象类和抽象方法必须用关键字 abstract 修饰2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类3、abstract 修饰的方法没有方法体，且子类必须重写4、抽象类不能实例化，因为 abstract 类中有 abstract 方法5、抽象类的子类也可以是一个抽象类，可以重写也可以不重写父类的抽象方法。可以是一个具体类。这个类必须重写抽象类中的所有抽象方法。(可以实例化)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestSon &#123;public static void main(String[] args) &#123;Son son &#x3D; new Son();son.play();&#125;&#125;&#x2F;&#x2F; 抽象类abstract class Father &#123;String name;int age;public Father() &#123;&#125;public void eat() &#123;System.out.println(&quot;吃饭&quot;);&#125;    &#x2F;&#x2F; 抽象方法abstract public void play();&#125;class Son extends Father &#123;    &#x2F;&#x2F; 抽象方法的重写@Overridepublic void play() &#123;System.out.println(&quot;玩游戏&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p><h3 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h3><p>interface ：用来声明接口的关键字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">声明格式：    interface 接口名 &#123;    静态常量;    抽象方法;&#125;实现格式：    class 类名 implements 接口名 &#123;            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">1、接口中的成员变量只能是静态常量，定义时必须初始化。默认修饰符：public static final2、接口中没有构造方法，因为接口不能实例化对象3、接口中的成员方法只能是抽象方法，没有方法体。默认修饰符：public abstract4、接口的实现类必须重写接口中方法，或者是一个抽象类(可以重写也可以不重写接口中的方法)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口的声明和实现"><a href="#接口的声明和实现" class="headerlink" title="接口的声明和实现"></a>接口的声明和实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface play&#123;&#x2F;&#x2F; 常量，缺省修饰符：public static finalint time &#x3D; 10;&#x2F;&#x2F; 抽象方法，缺省修饰符：public abstractvoid geme();&#125;public class TestInterface3 implements play&#123;    &#x2F;&#x2F; 重写接口中的方法@Overridepublic void geme() &#123;System.out.println(&quot;玩游戏&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写接口中的方法</p><h3 id="抽象类实现接口"><a href="#抽象类实现接口" class="headerlink" title="抽象类实现接口"></a>抽象类实现接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface servlet &#123;void init();void service();&#125;abstract class BaseServlet implements servlet &#123;    &#x2F;&#x2F; 重写init()方法@Overridepublic void init() &#123;System.out.println(&quot;初始化&quot;);&#125;&#125;class MyServlet extends BaseServlet &#123;@Overridepublic void service() &#123;System.out.println(&quot;服务方法&quot;);&#125;&#125;public class Test &#123;public static void main(String[] args) &#123;new MyServlet().init();new MyServlet().service();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】抽象类实现接口，可以选择性重写也可以不重写接口中的方法</p><h3 id="类的接口多实现"><a href="#类的接口多实现" class="headerlink" title="类的接口多实现"></a>类的接口多实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Play &#123;void geme();&#125;interface Eat &#123;void noodles();&#125;public class TestInterface3 implements Play, Eat &#123;    &#x2F;&#x2F; 重写Play类中的方法@Overridepublic void geme() &#123;System.out.println(&quot;玩游戏&quot;);&#125;    &#x2F;&#x2F; 重写Eat类中的方法@Overridepublic void noodles() &#123;System.out.println(&quot;吃面条&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写所有接口中的方法</p><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Eat &#123;void noodles();&#125;interface Play &#123;void happy();&#125;&#x2F;&#x2F; 单继承interface Person extends Play &#123;&#125;&#x2F;&#x2F; 多继承interface Animal extends Play, Eat &#123;&#125;&#x2F;&#x2F; 实体类实现Animal接口，重写所有方法class Biology implements Animal &#123;@Overridepublic void happy() &#123;System.out.println(&quot;玩得开心&quot;);&#125;@Overridepublic void noodles() &#123;System.out.println(&quot;面条好吃&quot;);&#125;&#125;public class Test &#123;public static void main(String[] args) &#123;Biology biology &#x3D; new Biology();biology.happy();&#x2F;&#x2F; 玩得开心biology.noodles();&#x2F;&#x2F; 面条好吃&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口之间可以单继承，也可以多继承</p><h3 id="jdk1-8新特性：default接口"><a href="#jdk1-8新特性：default接口" class="headerlink" title="jdk1.8新特性：default接口"></a>jdk1.8新特性：default接口</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Function &#123;void test();default void testDefault() &#123;System.out.println(&quot;default修饰的接口可以有方法体&quot;);&#125;&#125;&#x2F;&#x2F; default 修饰的接口可以不被重写class Base implements Function &#123;@Overridepublic void test() &#123;System.out.println(&quot;Base类重写Function接口中的方法&quot;);&#125;&#125;&#x2F;&#x2F; default 修饰的接口也可以重写class Boost implements Function &#123;@Overridepublic void test() &#123;System.out.println(&quot;Boost类重写Function接口中的方法&quot;);&#125;@Overridepublic void testDefault() &#123;System.out.println(&quot;Boost类重写Function接口中的default方法&quot;);&#125;&#125;public class TestInterface2 &#123;public static void main(String[] args) &#123;Base base &#x3D; new Base();Boost boost &#x3D; new Boost();base.test();&#x2F;&#x2F; Base类重写Function接口中的方法base.testDefault();&#x2F;&#x2F; default修饰的接口可以有方法体boost.test();&#x2F;&#x2F; Boost类重写Function接口中的方法boost.testDefault();&#x2F;&#x2F; Boost类重写Function接口中的default方法&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】default修饰的接口可以不被重写</p><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、接口是对类的扩展，通过接口可以让类拥有更多更强的功能2、接口中只有全局常量和抽象方法，所以不能实例化3、接口的实现类必须重写所有方法，或者是个抽象类4、接口可以多实现5、接口可以单继承，也可以多继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>二者具有直接或间接的继承关系时，父类引用指向子类对象，从而产生多种形态；接口的引用指向实现接口的类对象也是多态</strong></p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>多态场景下，父类引用调用方法，如果被子类重写过，优先执行子类重写过后的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestCar &#123;public static void main(String[] args) &#123;        &#x2F;&#x2F; 父类引用指向子类对象Vehicle vehicle &#x3D; new Car();                &#x2F;&#x2F; 优先执行子类重写过的方法vehicle.run();&#x2F;&#x2F; Car run！！！&#125;&#125;class Vehicle &#123;public void run() &#123;System.out.println(&quot;Vehicle run！！！&quot;);&#125;&#125;class Car extends Vehicle &#123;@Overridepublic void run() &#123;System.out.println(&quot;Car run！！！&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="应用场景一"><a href="#应用场景一" class="headerlink" title="应用场景一"></a>应用场景一</h3><p>使用父类作为方法形参实现多态，使方法参数的类型更为宽泛</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestCar &#123;public static void main(String[] args) &#123;                Vehicle vehicle &#x3D; new Car();        vehicle.type &#x3D; &quot;小汽车&quot;;        Bike bike &#x3D; new Bike();bike.type &#x3D; &quot;自行车&quot;;Bus bus &#x3D; new Bus();bus.type &#x3D; &quot;公交车&quot;;Employee employee &#x3D; new Employee(&quot;你的迪丽热巴&quot;);employee.goHome(vehicle);employee.goHome(bus);&#125;&#125;class Employee &#123;String name;public Employee() &#123;&#125;public Employee(String name) &#123;this.name &#x3D; name;&#125;public void goHome(Vehicle vehicle) &#123;System.out.println(this.name + &quot;乘坐&quot; + vehicle.type + &quot;交通工具回家&quot;);&#125;&#125;class Vehicle &#123;String type;public void run() &#123;System.out.println(&quot;Vehicle run！！！&quot;);&#125;&#125;class Bus extends Vehicle &#123;@Overridepublic void run() &#123;System.out.println(&quot;Bus run！！！&quot;);&#125;&#125;class Car extends Vehicle &#123;@Overridepublic void run() &#123;System.out.println(&quot;Car run！！！&quot;);&#125;&#125;class Bike extends Vehicle &#123;@Overridepublic void run() &#123;System.out.println(&quot;Bike run！！！&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">你的迪丽热巴乘坐小汽车回家Car run！！！你的迪丽热巴乘坐公交车回家Bus run！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="应用场景二"><a href="#应用场景二" class="headerlink" title="应用场景二"></a>应用场景二</h3><p>使用父类作为方法返回值实现多态，使方法可以返回不同子类对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Vehicle buyVehicle(int money) &#123;Vehicle vehicle &#x3D; null;if (money &gt;&#x3D; 100) &#123;Bus bus &#x3D; new Bus();bus.speed &#x3D; 60;bus.price &#x3D; 1230000.0;bus.seatNum &#x3D; 16;bus.type &#x3D; &quot;公交车&quot;;vehicle &#x3D; bus;&#125; else if (money &gt;&#x3D; 30) &#123;Car car &#x3D; new Car();car.price &#x3D; 310000.0;car.speed &#x3D; 90;car.type &#x3D; &quot;小汽车&quot;;car.brand &#x3D; &quot;BMW&quot;;vehicle &#x3D; car;&#125; else if (money &gt;&#x3D; 1) &#123;Bike bike &#x3D; new Bike();bike.type &#x3D; &quot;捷安特自行车&quot;;bike.speed &#x3D; 40;bike.price &#x3D; 2000.0;bike.color &#x3D; &quot;红色&quot;;vehicle &#x3D; bike;&#125;return vehicle;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向上装箱与向下拆箱"><a href="#向上装箱与向下拆箱" class="headerlink" title="向上装箱与向下拆箱"></a>向上装箱与向下拆箱</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Animal&#123;&#125;class Cat extends Animal&#123;&#125;class Dog extends Animal&#123;&#125;class Fish extends Animal &#123;&#125;public class Test &#123;public static void main(String[] args) &#123;showAnimal(new Animal());&#x2F;&#x2F; code.polymorphic.animal.Animal@7852e922&#x2F;&#x2F; 向上转型showAnimal(new Cat());&#x2F;&#x2F; code.polymorphic.animal.Cat@4e25154f&#x2F;&#x2F; 向上转型showAnimal(new Dog());&#x2F;&#x2F; code.polymorphic.animal.Dog@70dea4e&#x2F;&#x2F; 向上转型showAnimal(new Fish());&#x2F;&#x2F; code.polymorphic.animal.Fish@5c647e05System.out.println(&quot;----------------------&quot;);Animal animal &#x3D; getAnimal();&#x2F;&#x2F; 向下转型Cat cat &#x3D; (Cat) getCat();&#x2F;&#x2F; 向下转型Dog dog &#x3D; (Dog) getDog();&#x2F;&#x2F; 向下转型Fish fish &#x3D; (Fish) getFish();System.out.println(animal);&#x2F;&#x2F; code.polymorphic.animal.Animal@33909752System.out.println(cat);&#x2F;&#x2F; code.polymorphic.animal.Cat@55f96302System.out.println(dog);&#x2F;&#x2F; code.polymorphic.animal.Dog@3d4eac69System.out.println(fish);&#x2F;&#x2F; code.polymorphic.animal.Fish@42a57993&#125;&#x2F;** * 展示动物 * @param animal *&#x2F;public static void showAnimal(Animal animal) &#123;System.out.println(animal);&#125;&#x2F;** * 得到动物 * @return 返回一个Animal对象 *&#x2F;public static Animal getAnimal() &#123;return new Animal();&#125;&#x2F;** * 得到猫 * @return 返回一个Cat对象 *&#x2F;public static Animal getCat() &#123;return new Cat();&#125;&#x2F;** * 得到狗 * @return 返回一个Dog对象 *&#x2F;public static Animal getDog() &#123;return new Dog();&#125;&#x2F;** * 得到鱼 * @return 返回一个Fish对象 *&#x2F;public static Animal getFish() &#123;return new Fish();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h3><p>用于判断当前对象是否是某个类，或者其子类、实现类的实例。如果是返回true，否则返回false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 动物类 *&#x2F;class Animal &#123;&#125;&#x2F;** * 老虎类 *&#x2F;class Tiger extends Animal &#123;&#125;&#x2F;** * 熊猫类 *&#x2F;class Panda extends Animal &#123;&#125;&#x2F;** * 猴子类 *&#x2F;class Monkey extends Animal &#123;&#125;public class AnimalDemo &#123;public static void main(String[] args) &#123;Animal ani &#x3D; getAnimal();if (ani instanceof Panda) &#123;&#x2F;&#x2F; ani一定是panda对象或子类对象Panda panda2 &#x3D; (Panda) ani;System.out.println(&quot;这是熊猫：&quot; + panda2);showPanda(panda2);&#125; else &#123;System.out.println(&quot;这是动物：&quot; + ani);&#125;&#125;        &#x2F;&#x2F; 获取动物，返回一个Panda对象public static Animal getAnimal() &#123;return new Panda();&#125;        &#x2F;&#x2F; 展示熊猫对象    public static void showPanda(Panda panda) &#123;System.out.println(panda);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】<strong>使用 instanceof 关键字做判断时， instanceof 操作符的左操作数必须和右操作数存在继承或实现关系</strong></p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、父类引用指向子类对象，接口引用指向实现类对象</p><p>2、instanceof用以比较对象是否是类或父类的实例，接口的实现类</p></blockquote><h2 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h2><blockquote><p>API(Application Programming Interface) 应用程序编程接口</p></blockquote><p>编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑、向后跑、射门、抢球等各种命令，没有编过程序的人很难想象这样的程序如何编写。但是对于有经验的开发人员来说，知道机器人厂商一定会提供一些用于控制机器人的Java类，这些类中定义好了操作机器人各种动作的方法。其实，这些Java类就是机器人厂商提供给应用程序编程的接口，大家把这些类称为Xxx Robot API。本章涉及的Java API指的就是JDK中提供的各种功能的Java类。</p><h2 id="学习汉语和学习编程的异同点"><a href="#学习汉语和学习编程的异同点" class="headerlink" title="学习汉语和学习编程的异同点"></a>学习汉语和学习编程的异同点</h2><p>相同点</p><ul><li>基本语法</li><li>大量成语</li><li>写文章的手法和技巧</li></ul><p>不同点</p><ul><li>学习汉语 必须先学后用</li><li>学习编程 可以现用现学</li></ul><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p>Object类是类层次结构的根类，所有类都直接或者间接的继承自该类</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Object()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】Object 只有一个无参构造方法</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>用来返回对象的字符串表示形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String toString()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值为：包名.类名@当前对象在内存空间中的首地址</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写toString"><a href="#重写toString" class="headerlink" title="重写toString()"></a>重写toString()</h4><p>由于默认情况下的数据对我们来说没有意义，一般会重写该方法用以展示对象的字段信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;String name;int age;        &#x2F;&#x2F; 重写 toString 方法    @Overridepublic String toString() &#123;return &quot;Student [name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;]&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestStudent &#123;public static void main(String[] args) &#123;Student student &#x3D; new Student(&quot;Buffer&quot;,23);System.out.println(student);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Student [name&#x3D;Buffer, age&#x3D;23]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><blockquote><p>toString方法用来展示一些对象的基本信息：完整的包名.类名@堆内存地址，通常我们用快捷键来重写这个方法来获取我们需要的数据信息</p></blockquote><h2 id="Object-类-1"><a href="#Object-类-1" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>用来比较两个对象的地址是否相同</p><pre class="line-numbers language-none"><code class="language-none">public boolean equals(Object obj) &#123;        return (this &#x3D;&#x3D; obj);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果调用此方法的对象与 obj 的地址相同(即为同一个对象)，返回true，否则返回false</p><h4 id="重写equals-思路"><a href="#重写equals-思路" class="headerlink" title="重写equals()思路"></a>重写equals()思路</h4><p>一般需要重写 equals() 方法用以判断两个对象的字段是否相同</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、判断两个对象的地址是否相同2、判断两个对象的类型是否一致3、判断两个对象所存储的数据是否相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;String name;int age;        &#x2F;&#x2F; 重写 equals 方法    @Overridepublic boolean equals(Object obj) &#123;        &#x2F;&#x2F; 判断是否是同一个对象(地址相同)，如果是返回 trueif (this &#x3D;&#x3D; obj) &#123;return true;&#125;        &#x2F;&#x2F; 判断数据类型是否一致，如果不一致返回 falseif (!(obj instanceof Student)) &#123;return false;&#125;        &#x2F;&#x2F; 强制类型转换为当前类对象Student student &#x3D; (Student) obj;        &#x2F;&#x2F; 所有字段全部满足时返回 true ，否则返回falsereturn this.name.equals(student.name) &amp;&amp; this.age &#x3D;&#x3D; student.age;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestStudent &#123;public static void main(String[] args) &#123;Student student1 &#x3D; new Student(&quot;Buffer&quot;,23);Student student2 &#x3D; new Student(&quot;Banlance&quot;,22);Student student3 &#x3D; new Student(&quot;Buffer&quot;,23);System.out.println(student1.equals(student2));System.out.println(student1.equals(student3));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">falsetrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】基本数据类型不能使用 equals() 方法</p><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、equals方法用来判断两个对象是否相同，默认比较的是两个对象的内存首地址。我们可以通过重写equals方法实现对两个对象的比较</p><p>2、注意equals方法的调用者，不同的调用者调用方法是不一样的</p></blockquote><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>返回对象的哈希码值，<strong>具有唯一指向性</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int hashCode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写hashCode"><a href="#重写hashCode" class="headerlink" title="重写hashCode()"></a>重写hashCode()</h4><p>hashCode方法要求必须和 equals() 方法的结果是对应的，如果两个对象的 equals 的结果为 true ，那这两个对象的 hashCode 的值一定相同，所以<strong>只要重写了 equals 方法，就必须重写 hashCode 方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student &#123;String name;int age;        &#x2F;&#x2F; 重写 equals 方法    @Overridepublic boolean equals(Object obj) &#123;if (this &#x3D;&#x3D; obj) &#123;return true;&#125;if (!(obj instanceof Student)) &#123;return false;&#125;Student student &#x3D; (Student) obj;return this.name.equals(student.name) &amp;&amp; this.age &#x3D;&#x3D; student.age;&#125;        &#x2F;&#x2F; 重写 hashCode 方法    @Overridepublic int hashCode() &#123;        &#x2F;&#x2F; 调用 Objects 工具类的 hash 方法，根据传入的参数生成一个指定的 hashCode 值return Objects.hash(name, age);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestStudent &#123;public static void main(String[] args) &#123;Student student1 &#x3D; new Student(&quot;Buffer&quot;,23);Student student2 &#x3D; new Student(&quot;Banlance&quot;,22);Student student3 &#x3D; new Student(&quot;Buffer&quot;,23);System.out.println(student1.equals(student2));System.out.println(student1.equals(student3));System.out.println(student1.hashCode());System.out.println(student2.hashCode());System.out.println(student3.hashCode());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">falsetrue18926508722470635951892650872<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>student1 和 student3 的 equals 方法返回值是 true ，所以他们的 hashCode 值相同</p><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、hashCode()用来获取当前对象的哈希值，表示对象的唯一标识。如果重写equals()则必须重写hashCode()方法</p><p>2、equals相同hashCode一定相同，hashCode相同equals不一定相同</p></blockquote><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>获取当前对象的 Class 对象（字节码对象），直接打印会显示包含完整的包名,类名的信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final native Class&lt;?&gt; getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Cat &#123;&#125;public class GetClassDemo &#123;public static void main(String[] args) &#123;Cat cat &#x3D; new Cat();System.out.println(cat.getClass());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void finalize()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Object类是所有类的基类，提供了一个无参的构造方法和一些公共方法</p><p>通过重写toString方法来获取对象中的数据</p><p>通过重写equals方法和hashCode方法来判断两个对象是否相同，这两个方法必须同时重写</p><p>getClass用来获取Class对象</p><p>finalize方法用于垃圾回收，不可控</p></blockquote><h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p><code>System</code> 类包含一些有用的类字段和方法。它不能被实例化。 </p><p>在 <code>System</code>  类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 标准输入流，常用于键盘录入public final static InputStream in &#x3D; null    &#x2F;&#x2F; 标准输出流，常用于打印信息public final static PrintStream out &#x3D; null;&#x2F;&#x2F; 标准错误输出流，常用于打印错误信息public final static PrintStream err &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SystemFieldDemo &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 通过Scanner测试标准输入Scanner sc &#x3D; new Scanner(System.in);String next &#x3D; sc.next();&#x2F;&#x2F; 通过System.out.print测试标准输出流System.out.println(next);sc.close();&#x2F;&#x2F; 通过System.err.print测试标准输出流System.err.println(&quot;打印错误报告&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法私有化，无法创建对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** Don&#39;t let anyone instantiate this class *&#x2F;private System() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h3><p>这个方法表示复制数组，从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数解释</p><blockquote><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArraycopyDemo &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 创建一个长度为5的int类型数组arrint[] arr &#x3D; new int[5];&#x2F;&#x2F; 为数组arr赋值for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;arr[i] &#x3D; i;&#125;&#x2F;&#x2F; 遍历数组arrfor (int i &#x3D; 0; i &lt; arr.length; i++) &#123;System.out.println(arr[i]);&#125;System.out.println(&quot;------------------&quot;);&#x2F;&#x2F; 创建一个新的长度为5的int类型数组newArrint[] newArr &#x3D; new int[5];&#x2F;&#x2F; 调用System的arraycopy方法，分别传入对应的参数System.arraycopy(arr, 0, newArr, 0, 5);&#x2F;&#x2F; 遍历newArr数组for (int i &#x3D; 0; i &lt; newArr.length; i++) &#123;System.out.println(newArr[i]);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><p>返回以毫秒为单位的当前时间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static native long currentTimeMillis();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】</p><blockquote><p>1、这个方法的返回值是long类型</p><p>2、当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CurrentTimeMillsDemo &#123;public static void main(String[] args) &#123;long currentTimeMillis &#x3D; System.currentTimeMillis();System.out.println(&quot;毫秒：&quot; + currentTimeMillis);System.out.println(&quot;年：&quot; + currentTimeMillis&#x2F;1000&#x2F;60&#x2F;60&#x2F;24&#x2F;365);SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String date &#x3D; sdf.format(currentTimeMillis);System.out.println(date); &#x2F;&#x2F; 2020-10-06 17:53:02&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h3><p>运行垃圾回收器。在此之前会调用Object的finalize()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void gc()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>System.gc()可用于垃圾回收。当使用System.gc()回收某个对象所占用的内存之前，通过要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，Java提高了默认机制来清理该对象的资源，就是调用Object类的finalize()方法。finalize()方法的作用是释放一个对象占用的内存空间时，会被JVM调用。而子类重写该方法，就可以清理对象占用的资源，该方法有没有链式调用，所以必须手动实现。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person &#123;private String name;private int age;&#x2F;&#x2F; 构造方法，getter、setter方法、toString方法    &#x2F;* * 通过重写finalize方法验证调用gc会执行此方法 *&#x2F;@Overrideprotected void finalize() throws Throwable &#123;System.out.println(&quot;执行finalize方法回收垃圾：&quot; + this);super.finalize();&#125;&#125;public class GcDemo &#123;public static void main(String[] args) &#123;System.out.println(new Person(&quot;张三&quot;, 16));System.gc();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从程序的运行结果可以发现，执行System.gc()前，系统会自动调用finalize()方法清除对象占有的资源，通过super.finalize()方式可以实现从下到上的finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。</p><p>但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的Java程序运行争抢资源，只有在执行大量的对象的释放，才调用垃圾回收最好</p></blockquote><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void exit(int status)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExitDemo &#123;public static void main(String[] args) &#123;System.out.println(&quot;程序执行开始&quot;);&#x2F;&#x2F; 执行此方法后关闭虚拟机，程序不会再向下执行System.exit(0);System.out.println(&quot;程序执行结束&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><blockquote><p>System类提供了一些和系统相关的类字段和方法，便于我们和底层进行交互。</p><p>比较常用的就是arraycopy()和currentTimeMills()，其他不需要关注</p></blockquote><h2 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h2><p>一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 </p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Scanner implements Iterator&lt;String&gt;, Closeable &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里我们需要关注三个点：</p><p>1、final修饰，不能被继承</p><p>2、实现了 Iterator 接口(迭代器接口)，主要使用其中的 hasNext 方法和 next 方法</p><p>3、实现了 Closeable 接口，主要使用其中的 close 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&gt;&#x2F;&#x2F; 用来判断是否还有下一个元素录入&gt;public boolean hasNext()&gt;&#x2F;&#x2F; 用来接收录入的数据&gt;public String next()&gt;&#x2F;&#x2F; 用来关闭资源(输入流)&gt;public void close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><p>从指定的扫描输入流构造一个 Scanner</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Scanner(InputStream source)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo1 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; java.util.Scanner.Scanner(InputStream source)        &#x2F;&#x2F; 使用构造方法，传入一个标准输入流，创建一个Scanner对象Scanner sc &#x3D; new Scanner(System.in);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 此方法用于接收从键盘录入的字符串public String next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo1 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);                &#x2F;&#x2F; 从键盘录入一个字符串        String str &#x3D; sc.next();        System.out.println(str);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nextInt"><a href="#nextInt" class="headerlink" title="nextInt()"></a>nextInt()</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 此方法用于从键盘获取一个int类型的数据public int nextInt()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo1 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);                &#x2F;&#x2F; 从键盘录入一个字符串        int num &#x3D; sc.nextInt();        System.out.println(num);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法的重载：nextInt-int-radix"><a href="#方法的重载：nextInt-int-radix" class="headerlink" title="方法的重载：nextInt(int radix)"></a>方法的重载：nextInt(int radix)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 指定进制数从键盘录入一个int类型的数据public int nextInt(int radix)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>int radix参数表示一个进制数，如果从键盘录入的数据超过了指定的进制数就会报错，默认是10</p></blockquote><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo5 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);&#x2F;* * 8表示接收8进制内的数，及0~7 *  * 从键盘录入的数据中不能出现8及其以上的数字，如果有会报错： * InputMismatchException 输入类型不匹配异常 *&#x2F;int num &#x3D; sc.nextInt(8);System.out.println(num);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相关方法：用法类似，要求触类旁通"><a href="#相关方法：用法类似，要求触类旁通" class="headerlink" title="相关方法：用法类似，要求触类旁通"></a>相关方法：用法类似，要求触类旁通</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String nextLine()public byte nextByte()public byte nextByte(int radix)public short nextShort()public long nextLong()public float nextFloat()public double nextDouble()public BigInteger nextBigInteger()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hasNextInt"><a href="#hasNextInt" class="headerlink" title="hasNextInt()"></a>hasNextInt()</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。public boolean hasNext()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>此方法可用于合法性判断</p></blockquote><p>案例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo2 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);        if (sc.hasNextInt()) &#123;System.out.println(sc.nextInt());&#125; else &#123;System.out.println(&quot;输入的数据类型有误&quot;);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他相关方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean hasNext()public boolean hasNextLine()public boolean hasNextBoolean()public boolean hasNextByte()public boolean hasNextShort()public boolean hasNextLong()public boolean hasNextFloat()public boolean hasNextDouble()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展：回车换行问题"><a href="#扩展：回车换行问题" class="headerlink" title="扩展：回车换行问题"></a>扩展：回车换行问题</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo3 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);        int num &#x3D; sc.nextInt();String str &#x3D; sc.nextLine();System.out.println(&quot;str:&quot; + str + &quot;，num:&quot; + num);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当从键盘录入第一个数字后，敲下的回车键实际是两个字符：\r\n，所以键盘实际是录入了这两个字符并且结束，显示的效果和没有录入字符串相同</p><p>补充：</p><p>\r：回车，回到行首</p><p>\n：换行</p><p>电脑上的回车键(Enter键)实际上是回车式换行，会先执行回车，后执行换行</p></blockquote><p>扩展：多行录入</p><p>可以通过hasNext的重载方法来实现多行录入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果从键盘录入指定的pattern标记，则返回true，否则返回falsepublic boolean hasNext(String pattern)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo4 &#123;public static void main(String[] args) &#123;Scanner sc &#x3D; new Scanner(System.in);StringBuffer sb &#x3D; new StringBuffer();        &#x2F;&#x2F; 将#作为结束的标记，当遇到#时结束循环while (!sc.hasNext(&quot;#&quot;)) &#123;sb.append(sc.next());&#125;        System.out.println(sb);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><blockquote><p>Scanner 通过标准输入流来从键盘输入，后期不会用到，目前常用的方法为nextXxx()和hasNextXxx()</p></blockquote><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><blockquote><p>静态常量，全大写，通过类名调用</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 比任何其他值都更接近 e（即自然对数的底数）的 double 值public static final double E &#x3D; 2.7182818284590452354;&#x2F;&#x2F; 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值public static final double PI &#x3D; 3.14159265358979323846;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><blockquote><p>构造方法私有化，不能创建对象</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Math() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><blockquote><p>所有方法全部都被 static 修饰，可以通过类名直接调用</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取绝对值public static int abs(int a)&#x2F;&#x2F; 对数据进行向上取整public static double ceil(double a)&#x2F;&#x2F; 对数据进行向下取整public static double floor(double a)&#x2F;&#x2F; 获取最大值public static int max(int a,int b)     &#x2F;&#x2F; 获取最小值public static int min(int a, int b)&#x2F;&#x2F; 获取a的b次幂public static double pow(double a,double b)&#x2F;&#x2F; 随机数，范围：[0.0, 1.0)，注意左闭右开，包含左边不包含右边，public static double random()&#x2F;&#x2F; 四舍五入public static int round(float a)&#x2F;&#x2F; 获取正平方根public static double sqrt(double a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.fc.r.math;public class MathDemo1 &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 自然对数的底System.out.println(&quot;Math.E:&quot; + Math.E);&#x2F;&#x2F; πSystem.out.println(&quot;Math.PI:&quot; + Math.PI);System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 绝对值System.out.println(&quot;abs:&quot; + Math.abs(-1));System.out.println(&quot;abs:&quot; + Math.abs(1));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 向上取整System.out.println(&quot;ceil:&quot; + Math.ceil(12.34));System.out.println(&quot;ceil:&quot; + Math.ceil(12.56));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 向下取整System.out.println(&quot;floor:&quot; + Math.floor(12.34));System.out.println(&quot;floor:&quot; + Math.floor(12.56));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 最大最小值System.out.println(&quot;max:&quot; + Math.max(12.34, 56.78));System.out.println(&quot;max:&quot; + Math.max(12.34, Math.max(56.78, 100)));System.out.println(&quot;min:&quot; + Math.min(12.34, 56.78));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; a的b次方System.out.println(&quot;pow:&quot; + Math.pow(2, 10));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 随机数1~10System.out.println(&quot;random:&quot; + (int) (Math.random() * 10 + 1));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 四舍五入System.out.println(&quot;round:&quot; + Math.round(12.34));System.out.println(&quot;round:&quot; + Math.round(12.56));System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 获取正平方根System.out.println(&quot;sqrt:&quot; + Math.sqrt(16));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>Java泛型是JavaSE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型在定义的时候是宽泛的，而在使用的时候是确定的。可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><h3 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、提高了程序的安全性(类型安全)2、提高了程序的可扩展性、可重用性3、将运行期遇到的问题转移到了编译期4、省去了类型强转的麻烦(Object类对象)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型格式"><a href="#泛型格式" class="headerlink" title="泛型格式"></a>泛型格式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">泛型标识符：&lt;自定义无意义英文大写单字母占位符&gt;    常用格式：&lt;T&gt; Type &lt;E&gt; Element&lt;K&gt; Key&lt;V&gt; Value泛型类：把泛型定义在类上格式:class 类名&lt;泛型类型1,…&gt;    【注意】泛型类型必须是引用类型        泛型方法：把泛型定义在方法上格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)        泛型接口：把泛型定义在接口上格式:public  interface 接口名&lt;泛型类型1…&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>案例代码1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericityMethodDemo &#123;public static void main(String[] args) &#123;System.out.println(getData(100));System.out.println(getData(&quot;Java&quot;));System.out.println(getData(&#39;A&#39;));System.out.println(getData(false));&#125;&#x2F;** * 泛型方法 * 格式： * 泛型限定符 返回值类型 方法名(泛型类型 参数名) &#123;&#125; *  * @param &lt;T&gt; 泛型限定符 * @param t 任意类型的参数 * @return 返回任意类型参数 *&#x2F;public static &lt;T&gt; T getData(T t) &#123;return t;&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericityMethodDemo2 &#123;public static void main(String[] args) &#123;Integer[] intArr &#x3D; &#123;1, 2, 3&#125;;String[] stringArr &#x3D; &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;;        &#x2F;&#x2F; 自定义学生类，其中包含name和age两个成员变量        Student[] students &#x3D; &#123;new Student(&quot;张三&quot;, 1), new Student(&quot;李四&quot;, 2), new Student(&quot;王五&quot;, 3)&#125;;printArray(intArr);printArray(stringArr);printArray(students);&#125;&#x2F;** * 遍历任意类型的数组 *  * @param &lt;T&gt; 泛型限定符 * @param t 任意类型的数组 *&#x2F;public static &lt;T&gt; void printArray(T[] t) &#123;for (int i &#x3D; 0; i &lt; t.length; i++) &#123;System.out.println(t[i]);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、要求形式参数列表中必须有一个参数是当前自定义泛型，因为需要通过参数来约束当前方法运行过程中泛型对应的具体数据类型是哪一个2、返回值类型可以使用自定义泛型，而且是被形式参数列表中传入的泛型对应具体的数据类型控制3、方法体内也可以使用自定义泛型，同时也是被参数当中泛型对应具体数据类型约束监控<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericityClassDemo &#123;public static void main(String[] args) &#123;Number&lt;Integer&gt; num1 &#x3D; new Number&lt;Integer&gt;(100);Number&lt;String&gt; num2 &#x3D; new Number&lt;String&gt;(&quot;100&quot;);System.out.println(num1.getT());System.out.println(num2.getT());&#125;&#125;&#x2F;** * 泛型类，把泛型定义到类上，整个类内都可以使用。是对泛型方法的封装 * @param &lt;T&gt; 泛型标识符 *&#x2F;class Number&lt;T&gt; &#123;private T t;&#x2F;&#x2F; Constrator、setters、getters&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、类内可以直接使用对应的类名声明泛型2、类内使用的泛型具体数据类型是在创建当前类对象时约束3、在创建当前类对象时没有约束泛型对应的具体数据类型，那么所有使用到泛型的位置都是Object类型，有悖于泛型使用原则4、如果类声明过了泛型，那么类中所有使用此泛型的方法都同时被声明，即无法使用其他类型5、泛型类中定义的静态方法不能直接使用类声明的泛型，因为泛型需要在创建对象时声明，而静态方法在类加载时就加载完成，此时泛型还没有声明。如果静态方法想要使用泛型，只能自己声明自己使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>案例代码1</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface USB &#123;&#125;class Mouse implements USB &#123;&#125;class Keyboard implements USB &#123;&#125;interface PC&lt;T&gt; &#123;&#x2F;&#x2F; 接口中的常量不能使用泛型T use(T t);&#125;&#x2F;* *  实现类实现接口时不指定泛型类型, *  需要在创建对象时明确 *&#x2F;class MyPC&lt;T&gt; implements PC&lt;T&gt; &#123;@Overridepublic T use(T t) &#123;return t;&#125;&#125;&#x2F;* * 实现类实现接口时，接口中泛型的类型已经明确， * 实现的方法也是明确的 *&#x2F;class YourPC implements PC&lt;Mouse&gt; &#123;@Overridepublic Mouse use(Mouse t) &#123;return t;&#125;&#125;public class GenericityInterfaceDemo &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 创建对象时明确泛型的类型MyPC&lt;Keyboard&gt; myPC &#x3D; new MyPC&lt;Keyboard&gt;();Keyboard keyboard &#x3D; myPC.use(new Keyboard());System.out.println(keyboard);System.out.println(&quot;-----------------&quot;);&#x2F;&#x2F; 声明类时已经明确泛型的类型，所以这里的类型已经是明确的YourPC yourPC &#x3D; new YourPC();Mouse mouse &#x3D; yourPC.use(new Mouse());System.out.println(mouse);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 自定义一个比较器接口 * @param &lt;T&gt; 泛型 *&#x2F;interface Comparable&lt;T&gt; &#123;&#x2F;** * 这是一个比较方法，实现类应该实现这个方法以达到比较的目的 *  * @param t 传入被比较的对象 * @return 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 *&#x2F;public abstract int compareTo(T t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 自定义父类，实现比较器接口 *&#x2F;class Father implements Comparable&lt;Father&gt;&#123;private String name;private int age;    &#x2F;&#x2F; Constrator、setters、getters@Overridepublic int compareTo(Father f) &#123;return this.age - f.age;&#125;&#125;public class GenericityInterfaceDemo &#123;public static void main(String[] args) &#123;Father father1 &#x3D; new Father(&quot;小明父亲&quot;, 30);Father father2 &#x3D; new Father(&quot;小红父亲&quot;, 29);if (father1.compareTo(father2) &lt; 0) &#123;System.out.println(&quot;小红父亲年长：&quot; + father2.getAge());&#125; else &#123;System.out.println(&quot;小明父亲年长：&quot; + father1.getAge());&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、接口中的成员变量不能使用泛型，因为static、final2、泛型接口的实现类可以指定泛型的类型，也可以不指定，如果在实现类中明确了数据类型，创建对象时就不需要再进行明确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><blockquote><p>在泛型中，？ 表示未知类型，被称为通配符。通配符可以在各种情况下使用：可以作为形式参数、成员变量、局部变量的类型，也可以作为返回值类型。但是，通配符不能用于泛型方法调用、泛型类实例创建对象或者父类的类型实际参数</p></blockquote><p>表示全部类型，类似Object。区别于T，T只是占位符，而 ？是数据类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【使用场景】</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">1、当一个方法可以用Object类提供的功能来实现时，泛型通配符是使用的2、若代码使用了泛型类中的方法，而这些方法又是不依赖于参数化类型的，可以使用泛型通配符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Grade&lt;T&gt; &#123;private T t;    &#x2F;&#x2F; Constructor、setter and getter、toString    public void show() &#123;System.out.println(&quot;show&quot; + this);&#125;&#125;class School &#123;    &#x2F;&#x2F; 这里使用泛型通配符，表示可以传入任意类型public void showGrade(Grade&lt;?&gt; grade) &#123;grade.show();&#125;&#125;public class GenericityWildCardDemo &#123;public static void main(String[] args) &#123;School school &#x3D; new School();school.showGrade(new Grade&lt;Student&gt;(new Student()));school.showGrade(new Grade&lt;Teacher&gt;(new Teacher()));&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型上限"><a href="#泛型上限" class="headerlink" title="泛型上限"></a>泛型上限</h4><p>表示以T为父类的所有子类（包括父类）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;? extends T&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="泛型下限"><a href="#泛型下限" class="headerlink" title="泛型下限"></a>泛型下限</h4><p>表示以E为子类的所有父类（包括子类）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;? super E&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class School &#123;public void showGrade(Grade&lt;?&gt; grade) &#123;grade.show();&#125;    &#x2F;&#x2F; 泛型上限，Person类本身及其子类都可以使用public void showExtends(Grade&lt;? extends Person&gt; grade) &#123;System.out.println(grade);&#125;    &#x2F;&#x2F; 泛型下限，Person类本身及其父类都可以使用public void showSuper(Grade&lt;? super Person&gt; grade) &#123;System.out.println(grade);&#125;&#125;public class GenericityWildCardDemo &#123;public static void main(String[] args) &#123;School school &#x3D; new School();school.showGrade(new Grade&lt;Student&gt;(new Student()));school.showGrade(new Grade&lt;Teacher&gt;(new Teacher()));        &#x2F;&#x2F; 泛型上限，可以声明子类的类型school.showExtends(new Grade&lt;Student&gt;());        &#x2F;&#x2F; 泛型下限，可以声明父类的类型school.showSuper(new Grade&lt;Object&gt;());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型推断"><a href="#泛型推断" class="headerlink" title="泛型推断"></a>泛型推断</h3><blockquote><p>JDK1.7新特性，可以省略实例化对象时尖括号内的类型</p></blockquote><p>案例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GenericityInferDemo &#123;public static void main(String[] args) &#123;        &#x2F;&#x2F; 泛型推断Grade&lt;Student&gt; grade &#x3D; new Grade&lt;&gt;();        &#x2F;&#x2F; 得到对应的类型Student student &#x3D; grade.getT();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、泛型就是泛化的类型，本质是参数化类型，是jdk1.5引入的新特性，用在类、接口和方法上，即泛型类，泛型接口和泛型方法</p><p>2、为了解决利用继承Object来实现通用性导致的强制类型转换和可能发生的类型转换异常的问题。</p><p>3、泛型的好处是确保了编译时期的类型安全，和避免了强制类型转换的麻烦</p><p>4、缺陷是因为泛型使用了类型擦除机制，jvm运行之前会将泛型信息擦除掉，这样做是为了兼容jdk1.5之前的代码，但是也会导致通过反射可以跳过泛型的问题，因为运行期间并没有泛型的限制</p><p>5、泛型通配符？代表任意类型，泛型上限&lt;? extends T&gt;，泛型下限&lt;? super T&gt;</p><p>6、jdk1.7新特性泛型推断，声明变量时定义过泛型得话，在实例化对象时可以省略类型，但是还要加&lt;&gt;，否则还是原类型</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>甫子寸诗集</title>
      <link href="2020/10/11/%E7%94%AB%E5%AD%90%E5%AF%B8%E8%AF%97%E9%9B%86%E8%8A%82%E9%80%89/"/>
      <url>2020/10/11/%E7%94%AB%E5%AD%90%E5%AF%B8%E8%AF%97%E9%9B%86%E8%8A%82%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p>在此处甫子寸的诗纯个人喜欢的节选。</p><p>世间有些许荒唐，不如与我兴风作浪。</p><h3 id="《天经地义》"><a href="#《天经地义》" class="headerlink" title="《天经地义》"></a>《天经地义》</h3><p>知道吗，</p><p>这世间有很多事</p><p>是不用讲道理的，</p><p>就像我喜欢你，</p><p>不用落笔，</p><p>天经地义.</p><p>​                     —————甫子寸诗歌《天经地义》</p><h3 id="《东坡先生》"><a href="#《东坡先生》" class="headerlink" title="《东坡先生》"></a>《东坡先生》</h3><p> 大宋的明月照耀了千里，<br>却唯独照不到你。<br>你说沙洲寂寥，<br>倒也好过寒枝凄栖。<br>只寻常的入京赴考，<br>一纸策论便横空临世，<br>许是锋芒太盛？<br>竟令那山水醉翁也自叹弗如？</p><p>天才与伟人只差一个悲剧，<br>那权倾朝野的政敌沉迷变法，<br>乌台狂风起于你自由的豪尖，<br>向来墙倒众人推，<br>书生杀人不见血。<br>虎落平阳本就有趣，<br>落井下石是否更大快人心？！</p><p>自京师一贬直下到黄州，<br>耕垦隔绝新党的冷笑，<br>吹散天朝的遗风，<br>给大宋的文坛拆了细看，<br>竟再出不得如此人物，<br>上下五千年的洒脱，<br>败给谁的竹杖芒鞋。<br>把酒问天上宫阙，<br>抬眸见阴晴圆缺，<br>仙心欲归琼楼，<br>落笔却是那烟火人间。</p><p>大江东去，<br>你也随之东去，<br>雄姿英发，谈笑赤壁，<br>究竟是周郎还是你东坡居士？<br>擦去这些年的斜风细雨，<br>仍旧说着诗酒年华忘却鬓角的银发。<br>生平一点浩然气，<br>十年生死别亡妻，<br>门前的流水当真能西行？<br>如今恍惚相遇的互望无言，<br>不过又是一个明月照进松林的夜。 </p><p>​                     —————甫子寸《东坡先生》</p><h3 id="《乡愁其四》"><a href="#《乡愁其四》" class="headerlink" title="《乡愁其四》"></a>《乡愁其四》</h3><p>我问我外公什么是乡愁，</p><p>外公没有说话，</p><p>他在眼中，</p><p>藏入一坛浊酒.</p><p>​                        —————甫子寸《乡愁其四》</p><h3 id="《沉沦》"><a href="#《沉沦》" class="headerlink" title="《沉沦》"></a>《沉沦》</h3><p>你是我今后岁月难舍难分，</p><p>也是我荒凉宇宙明月星辰。</p><p>我爱你冰冷美艳凶险万分，</p><p>也爱你一笑嫣然撩我心魂。</p><p>题得出最美的诗文，</p><p>写不来你清透眼神。</p><p>你微微蹙眉，</p><p>使万物皆醺，英雄饮恨。</p><p>我轻轻一笑，</p><p>道茶还未凉，尚留余温。</p><p>一抹红唇，乱了方寸。</p><p>眉间一吻，我愿沉沦。</p><p>​                        —————甫子寸《沉沦》</p><h3 id="《钓鱼人》"><a href="#《钓鱼人》" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>这一生只想纵横，</p><p>谁又管身后的风？</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《钓鱼人》-1"><a href="#《钓鱼人》-1" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>你不懂我的梦，</p><p>便不知我热冷</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《诗歌之路在何方》"><a href="#《诗歌之路在何方》" class="headerlink" title="《诗歌之路在何方》"></a>《诗歌之路在何方》</h3><p> 舀下一瓢星光，</p><p>浇灌我的豪肠.</p><p>​                        —————甫子寸《诗歌之路在何方》节选</p><h3 id="《说与浮云听》"><a href="#《说与浮云听》" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>在最失意时纵马，</p><p>在最得意处品茶.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《说与浮云听》-1"><a href="#《说与浮云听》-1" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>一生很长，几度春夏?<br>纸张太短，无边风雅.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《随笔》"><a href="#《随笔》" class="headerlink" title="《随笔》"></a>《随笔》</h3><p>少年向来不识天高地厚，</p><p>放眼处皆自负才高八斗.</p><p>虽是自命风流，</p><p>倒也坦诚无忧.</p><p>我爱这样的少年，</p><p>谦和而狂妄，</p><p>骄傲又坦然.</p><p>​                        —————甫子寸《随笔》</p><h3 id="《月下随笔》"><a href="#《月下随笔》" class="headerlink" title="《月下随笔》"></a>《月下随笔》</h3><p>我是此间少年郎，</p><p>你是天上明月光</p><p>​                        —————甫子寸《月下随笔》节选</p><h3 id="《诗人》"><a href="#《诗人》" class="headerlink" title="《诗人》"></a>《诗人》</h3><p>我说诗人啊，</p><p>做自己的将军，</p><p>在自己的世界里统率三军.</p><p>​                        —————甫子寸《诗人》节选</p><h3 id="《诗心》"><a href="#《诗心》" class="headerlink" title="《诗心》"></a>《诗心》</h3><p>忙过了最近的忙，</p><p>醒来已是华灯初上，</p><p>太阳无缘见我，能作陪的只剩月光.</p><p>​                        —————甫子寸《诗心》节选</p><h3 id="《最绝伦的笔墨》"><a href="#《最绝伦的笔墨》" class="headerlink" title="《最绝伦的笔墨》"></a>《最绝伦的笔墨》</h3><p>你是我最绝伦的笔墨，</p><p>也是我诗里最美的传说.</p><p>​                        —————甫子寸《最绝伦的笔墨》节选</p><h3 id="《无题》"><a href="#《无题》" class="headerlink" title="《无题》"></a>《无题》</h3><p>龙有逆鳞不可触，</p><p>人无傲气不可交。</p><p>​                        —————甫子寸《无题》节选</p><h3 id="《劫》"><a href="#《劫》" class="headerlink" title="《劫》"></a>《劫》</h3><p>我于昨晚霸占了所有的月光，<br>等天亮却只想给一人写文章.</p><p>​                        —————甫子寸《劫》节选</p><h3 id="《只是想你》"><a href="#《只是想你》" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>这世间众生皆孤寂，<br>应怪众生未见过你。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《只是想你》-1"><a href="#《只是想你》-1" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>我扛得住所有白天的泪，</p><p>却熬不住漫漫长夜的黑。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《不想》"><a href="#《不想》" class="headerlink" title="《不想》"></a>《不想》</h3><p>我其实一点也不想念，<br>和月色也能相谈甚欢</p><p>​                        —————甫子寸《不想》节选</p><h3 id="《陷半生》"><a href="#《陷半生》" class="headerlink" title="《陷半生》"></a>《陷半生》</h3><p>误把眉目作山河，</p><p>沦陷半生未肯脱。</p><p>​                        —————甫子寸《陷半生》节选</p><h3 id="《野望》"><a href="#《野望》" class="headerlink" title="《野望》"></a>《野望》</h3><p>野心总是在深夜开始酝酿，</p><p>等天亮又黯然收场.</p><p>​                        —————甫子寸《野望》节选</p><h3 id="《格局》"><a href="#《格局》" class="headerlink" title="《格局》"></a>《格局》</h3><p>书生口中三寸兵，</p><p>不斩小人斩不平.</p><p>​                        —————甫子寸《格局》节选</p><h3 id="《随笔·热爱》"><a href="#《随笔·热爱》" class="headerlink" title="《随笔·热爱》"></a>《随笔·热爱》</h3><p> 人生九分只顾开怀，<br>对世界宣泄年轻的爱。<br>留一分写诗感慨，<br>等老去为自己喝彩。<br>到那时你会不会期待，<br>我敛去一身桀骜，<br>淋着星光向你走来，<br>为你捧起世上最温柔的海。 </p><p>​                        —————甫子寸《随笔·热爱》节选</p><h3 id="《我想把余生都送你》"><a href="#《我想把余生都送你》" class="headerlink" title="《我想把余生都送你》"></a>《我想把余生都送你》</h3><p>总有那么一天啊，</p><p>我会向那个不屈的少年告别，</p><p>柴米油盐酱醋茶，</p><p>目睹青丝成白发，</p><p>我不再心怀天下，</p><p>却只想接你回家.</p><p>​                        —————甫子寸《我想把余生都送你》</p><h3 id="《此刻此间》"><a href="#《此刻此间》" class="headerlink" title="《此刻此间》"></a>《此刻此间》</h3><p>你如今回眸看我一眼，</p><p>满天风光尽收你眉间.</p><p>​                        —————甫子寸《此刻此间》节选</p><h3 id="《三寸情书》"><a href="#《三寸情书》" class="headerlink" title="《三寸情书》"></a>《三寸情书》</h3><p>我说，瀚海可尽，明月可鞠，</p><p>落不得太多字句，</p><p>只为你一生眉目清举。</p><p>​                        —————甫子寸《三寸情书》节选</p><h3 id="《青云》"><a href="#《青云》" class="headerlink" title="《青云》"></a>《青云》</h3><p>闻听书中游侠，并无轻剑快马，</p><p>只凭背井离乡，丈量山河天下。</p><p>​                        —————甫子寸《青云》节选</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 甫子寸诗集节选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商管理系统</title>
      <link href="2020/10/10/java%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/10/10/java%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="电商管理系统"><a href="#电商管理系统" class="headerlink" title="电商管理系统"></a>电商管理系统</h3><p>第一步：先创建四大类，分别为 商品类（Article）、商品集合类（ArticleSet）、商品管理类（ArticleManage）、商品测试类（Demo）. </p><p>代码如下：</p><h4 id="商品类"><a href="#商品类" class="headerlink" title="商品类"></a>商品类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 商品类 * *&#x2F;public class Article &#123;public String name;public int amount;public double price;public int number;public void print(int index)&#123;System.out.println(index+&quot;\t&quot;+name+&quot;\t&quot;+price+&quot;\t&quot;+amount+&quot;\t&quot;+number);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品集合类"><a href="#商品集合类" class="headerlink" title="商品集合类"></a>商品集合类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 商品集合类 * *&#x2F;public class ArticleSet &#123;Article[] articles&#x3D;new Article[50];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品管理类"><a href="#商品管理类" class="headerlink" title="商品管理类"></a>商品管理类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;&#x2F;** * 商品管理类 * *&#x2F;public class ArticleManage &#123;ArticleSet articleSet&#x3D;new ArticleSet();Scanner input&#x3D;new Scanner(System.in);&#x2F;** * 初始化商品 *&#x2F;public void initial()&#123;Article xiaoMi9&#x3D;new Article();xiaoMi9.name&#x3D;&quot;小米9&quot;;xiaoMi9.price&#x3D;2799;xiaoMi9.amount&#x3D;60;xiaoMi9.number&#x3D;0;Article xiaoMiMIX3&#x3D;new Article();xiaoMiMIX3.name&#x3D;&quot;小米8&quot;;xiaoMiMIX3.price&#x3D;2049;xiaoMiMIX3.amount&#x3D;40;xiaoMiMIX3.number&#x3D;0;Article redMiNote7Pro&#x3D;new Article();redMiNote7Pro.name&#x3D;&quot;Redmi7&quot;;redMiNote7Pro.price&#x3D;699;redMiNote7Pro.amount&#x3D;80;redMiNote7Pro.number&#x3D;0;Article xiaoMiPlay&#x3D;new Article();xiaoMiPlay.name&#x3D;&quot;小米6x&quot;;xiaoMiPlay.price&#x3D;749;xiaoMiPlay.amount&#x3D;100;xiaoMiPlay.number&#x3D;0;articleSet.articles[0]&#x3D;xiaoMi9;articleSet.articles[1]&#x3D;xiaoMiMIX3;articleSet.articles[2]&#x3D;redMiNote7Pro;articleSet.articles[3]&#x3D;xiaoMiPlay;&#125;public void startMenu()&#123;boolean flag&#x3D;true;do &#123;System.out.println(&quot;欢迎使用前程商城后台管理系统&quot;);System.out.println(&quot;*****************************************&quot;);System.out.println(&quot;1.查看商品信息&quot;);System.out.println(&quot;2.新增商品信息&quot;);System.out.println(&quot;3.删除商品信息&quot;);System.out.println(&quot;4.卖出商品信息&quot;);System.out.println(&quot;5.商品销售排行榜&quot;);System.out.println(&quot;6.退出&quot;);System.out.println(&quot;*****************************************&quot;);Scanner sc&#x3D;new Scanner(System.in);System.out.println(&quot;请选择要执行的操作：&quot;);int choice&#x3D;sc.nextInt();switch (choice) &#123;case 1:System.out.println(&quot;查看商品信息&quot;);search();break;case 2:System.out.println(&quot;新增商品信息&quot;);add();break;case 3:System.out.println(&quot;删除商品信息&quot;);delete();break;case 4:System.out.println(&quot;卖出商品信息&quot;);sell();break;case 5:System.out.println(&quot;商品销售排行榜&quot;);leaderboard();break;case 6:System.out.println(&quot;谢谢使用！&quot;);flag&#x3D;false;break;default:System.out.println(&quot;输入不符合请重新输入：&quot;);break;&#125;&#125; while (flag);&#125;&#x2F;** * 查看商品 *&#x2F;public void search()&#123;System.out.println(&quot;编号\t名称\t价格\t库存\t售出&quot;);for (int i &#x3D; 0; i &lt; articleSet.articles.length; i++) &#123;if (articleSet.articles[i]!&#x3D;null) &#123;articleSet.articles[i].print(i+1);&#125;&#125;&#125;&#x2F;** * 新增商品 *&#x2F;public void add()&#123;System.out.println(&quot;请输入商品名称：&quot;);String name&#x3D;input.next();System.out.println(&quot;请输入价格：&quot;);int price&#x3D;input.nextInt();System.out.println(&quot;请输入库存：&quot;);int amount&#x3D;input.nextInt();Article article&#x3D;new Article();article.name&#x3D;name;article.price&#x3D;price;article.amount&#x3D;amount;article.number&#x3D;0;for (int i &#x3D; 0; i &lt; articleSet.articles.length; i++) &#123;if (articleSet.articles[i]&#x3D;&#x3D;null) &#123;articleSet.articles[i]&#x3D;article;break;&#125;&#125;&#125;&#x2F;** * 删除商品 *&#x2F;public void delete()&#123;System.out.println(&quot;请输入商品编号：&quot;);boolean flag&#x3D;true;int card&#x3D;input.nextInt();for (int i &#x3D; 0; i &lt; articleSet.articles.length; i++) &#123;if (articleSet.articles[i]!&#x3D;null&amp;&amp;(i+1)&#x3D;&#x3D;card) &#123;int j&#x3D;i;while (articleSet.articles[j+1]!&#x3D;null) &#123;articleSet.articles[j]&#x3D;articleSet.articles[j+1];j++;&#125;articleSet.articles[j]&#x3D;null;flag&#x3D;true;break;&#125; &#125;if (flag) &#123;System.out.println(&quot;删除成功！&quot;);&#125;else &#123;System.out.println(&quot;删除失败，请重新操作！&quot;);&#125;&#125;&#x2F;** * 销售业务 *&#x2F;public void sell()&#123;System.out.println(&quot;请输入你要卖出的商品名称：&quot;);String name&#x3D;input.next();boolean flag&#x3D;true;for (int i &#x3D; 0; i &lt; articleSet.articles.length; i++) &#123;if (articleSet.articles[i]!&#x3D;null&amp;&amp;articleSet.articles[i].name.equals(name)) &#123;System.out.println(&quot;请输入你要卖出的数量&quot;);int number&#x3D;input.nextInt();if (number&lt;&#x3D;articleSet.articles[i].amount) &#123;articleSet.articles[i].number&#x3D;articleSet.articles[i].number+number;articleSet.articles[i].amount&#x3D;articleSet.articles[i].amount-number;flag&#x3D;true;&#125; else &#123;System.out.println(&quot;商品数量不够，请抓紧进货！&quot;);flag&#x3D;false;&#125;break;&#125;else&#123;flag&#x3D;false;&#125;&#125;if (flag) &#123;System.out.println(&quot;卖出商品成功！&quot;);&#125; else &#123;System.out.println(&quot;卖出商品失败！&quot;);&#125;&#125;&#x2F;** * 商品销售排行榜 *&#x2F;public void leaderboard() &#123;Article[] articles &#x3D; new Article[50];for (int i &#x3D; 0; i &lt; articles.length; i++) &#123;if (articleSet.articles[i]!&#x3D;null) &#123;articles[i]&#x3D;articleSet.articles[i];&#125;&#125;for (int i &#x3D; 0; i &lt; articles.length-1; i++) &#123;for (int j &#x3D; 0; j &lt; articles.length-i-1; j++) &#123;if (articles[j+1] !&#x3D; null) &#123;if (articles[j].number &lt; articles[j+1].number) &#123;Article tempArticle &#x3D; articles[j];articles[j]&#x3D;articles[j+1];articles[j+1]&#x3D;tempArticle;&#125;&#125;&#125;&#125;System.out.println(&quot;*************************************&quot;);System.out.println(&quot;名次\t销售数量\t商品名称&quot;);for (int i &#x3D; 0; i &lt; articles.length; i++) &#123;if (articles[i]!&#x3D;null) &#123;System.out.println(i+1+&quot;\t&quot;+articles[i].number+&quot;\t&quot;+articles[i].name);&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品测试类"><a href="#商品测试类" class="headerlink" title="商品测试类"></a>商品测试类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** *商品测试类 *&#x2F;public class Demo &#123;public static void main(String[] args) &#123;ArticleManage articleManage&#x3D;new ArticleManage();articleManage.initial();articleManage.startMenu();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的优化</title>
      <link href="2020/10/07/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
      <url>2020/10/07/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>简单写一些关于优化hexo博客的内容，后续陆续补充.</p><hr><h3 id="一-添加动态标题"><a href="#一-添加动态标题" class="headerlink" title="一.添加动态标题"></a>一.添加动态标题</h3><p>在matery/layout/layout.ejs下添加如下内容.</p><pre class="line-numbers language-none"><code class="language-none">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;var OriginTitile&#x3D;document.title,st; document.addEventListener(&quot;visibilitychange&quot;,function()&#123; document.hidden?(document.title&#x3D;&quot;ヽ(●-&#96;Д´-)ノ你要玩捉迷藏嘛&quot;,clearTimeout(st)):(document.title&#x3D;&quot;(Ő∀Ő3)ノ好哦！&quot;,st&#x3D;setTimeout(function()&#123;document.title&#x3D;OriginTitile&#125;,3e3)) &#125;)&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二-配置音乐播放器"><a href="#二-配置音乐播放器" class="headerlink" title="二.配置音乐播放器"></a>二.配置音乐播放器</h3><p> 要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可： </p><pre class="line-numbers language-none"><code class="language-none"># 是否在首页显示音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id &#x2F; playlist id &#x2F; album id &#x2F; search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: &#39;#42b983&#39;  loop: &#39;all&#39;       # 音频循环播放, 可选值: &#39;all&#39;, &#39;one&#39;, &#39;none&#39;  order: &#39;random&#39;   # 音频循环顺序, 可选值: &#39;list&#39;, &#39;random&#39;  preload: &#39;auto&#39;   # 预加载，可选值: &#39;none&#39;, &#39;metadata&#39;, &#39;auto&#39;  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p>id获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="其它内容优化："><a href="#其它内容优化：" class="headerlink" title="其它内容优化："></a>其它内容优化：</h3><p>想查看其它优化博客的内容请移步好友的博客：</p><p><a href="https://ialoe.top/">https://ialoe.top/</a></p><p>此人博客较为详细</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客</title>
      <link href="2020/10/05/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/10/05/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>此人比较懒惰。未填写内容</p><p>如想详细创建博客请移步另博客，链接如下：</p><p><a href="https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242</a></p><p>如想优化博客：</p><p><a href="https://ialoe.top/">https://ialoe.top/</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="2020/10/05/java%E5%9F%BA%E7%A1%80/"/>
      <url>2020/10/05/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java语言的特点："><a href="#java语言的特点：" class="headerlink" title="java语言的特点："></a>java语言的特点：</h3><p>​                1.跨平台（一次开发，到处运行）</p><p>​                2.面向对象（万物皆可对象）</p><h3 id="java开发环境："><a href="#java开发环境：" class="headerlink" title="java开发环境："></a>java开发环境：</h3><p>​                jdk：java开发工具包（开发人员必须安装）</p><p>​                jre：java运行环境（运行java程序必须安装）</p><p>​                注意：java程序最终是运行在jvm虚拟机上的，不同的操作系统上可以安装其对应版本的jvm，这样就实现了跨平台</p><h3 id="java类的结构"><a href="#java类的结构" class="headerlink" title="java类的结构"></a>java类的结构</h3><p>​                1.编写源文件（后缀名    .java）</p><p>​                2.编译            （后缀名    .class）</p><p>​                3.运行</p><h3 id="java类的结构-1"><a href="#java类的结构-1" class="headerlink" title="java类的结构"></a>java类的结构</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class 类名&#123;    public static void main(String[] args)&#123;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <code>注意：main方法是java程序的入口</code></p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>​    输出语句</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.print(&quot;\n&quot;);&#x2F;&#x2F;输出完之后不会换行System.out.println(&quot;\n&quot;);&#x2F;&#x2F;输出完之后换行显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    转义符：</p><p>​    \n    换行，相当于输出完一句话按了回车键</p><p>​    \t    大空格，相当于Tab键</p><p>​    注释：</p><p>​    1.单行注释    //注释的内容</p><p>​    2.多行注释    /<em> 注释内容 </em>/</p><p>​    变量：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">color=red; 内存中一块储存空间的表示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="变量的数据类型："><a href="#变量的数据类型：" class="headerlink" title="变量的数据类型："></a>变量的数据类型：</h3><p>​    1.基本类型</p><p>​        八种基本数据类型</p><p>​        byte(1个字节) short(2个字节) int(4个字节) long(8个字节) </p><p>​        float(4个字节) double(8个字节) char(2个字节) boolean(1个字节)</p><p>​        自动转换 boolean—&gt;byte—&gt;short—&gt;int—&gt;long—&gt;float—&gt;double</p><p>​        short—&gt;float</p><p>​        自动    小—&gt;大</p><p>​        强制    大—&gt;小</p><p>​        float—&gt;int    强制    （int）12.3f</p><p>​    2.引用类型：</p><p>​        String，数组，对象，除了8种基本数据类型之外的都属于引用数据类型</p><p><strong>注意：比较相等</strong></p><ul><li><p>java基本数据类型（8种）</p><p>​    比较相等用==比较，比较不等！=</p></li><li><p>2.String</p><p>​    比较相等用equals（）方法比较内容是否相同    相同  true</p><p>不同 false，</p><p>方式：！字符串 1.equals（字符串2）</p></li></ul><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><p>​    1.字母，数字，下划线，$,但是不能以数字开头，</p><p>​    2.不能与关键字重名</p><p>​    3.见名知义</p><p>​    4.多个单词组成时，第一个单词小于其余单词开头大写    如：myScore键盘接收</p><p>​        1). 初始化Scanner 对象</p><p>​        <code>Scanner input=new Scanner(System.in);</code></p><p>​        2.)在程序中导入Scanner类  在类的外面写</p><p>​        <code>import java.util.Scanner;</code></p><p>​        3.)从键盘接收数据赋值给变量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String name&#x3D;input.next();&#x2F;&#x2F;接收String类型的值int javaScore&#x3D;input.nextInt();&#x2F;&#x2F;接收int类型的值double height&#x3D;input.nextDouble();&#x2F;&#x2F;接收double类型的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="声明和使用步骤"><a href="#声明和使用步骤" class="headerlink" title="声明和使用步骤 :"></a>声明和使用步骤 :</h4><p>​            1.声明  2.分配空间  3.赋值  4.使用</p><p>​            注意: </p><p>​                声明同时分配空间: 数据类型[] 数组名=new 数据类型[数组长度];</p><p>​                数组下标从0开始  数组元素最大下标值是 length-1</p><p>​                声明的时候赋值:  数据类型[] 数组名=new 数据类型[]{值1,值2,值3,….} //注意,后面的括号中不能写长度</p><p>​                          数据类型[] 数组名={值1,值2,值3,….}//不可拆分</p><h4 id="遍历数组元素"><a href="#遍历数组元素" class="headerlink" title="遍历数组元素"></a>遍历数组元素</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(int i&#x3D;0;i&lt;数组名.length;i++)&#123;System.out.println(数组名[下标]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数组的应用"><a href="#数组的应用" class="headerlink" title="数组的应用"></a>数组的应用</h4><p>​            ①    数组排序</p><p>​                            使用Arrays类sort方法排序，默认升序排列</p><p>​                            步骤：</p><p>​                            1）Arrays类导入import java.util.Arrays</p><p>​                            2）Arrays.sort（要排序的数组）；</p><p>​            ②求最大值（打擂台思想）</p><p>​                思路：</p><p>​                        1）.设置数组的一个元素为默认最大值</p><p>​                        2）.循环数组元素依次与最大值比较</p><p>​                关键代码：</p><p>​                                ```</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int max&#x3D;数组[0];for(int i&#x3D;0;i&lt;数组名.lenght;i++)&#123;if(数组名[i]&gt;max)&#123;max&#x3D;数组名[i];  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            ③向数组中插入元素</p><p>​            实现思路</p><p>​            a)找到待插入元素的下标</p><p>​                            循环数组，当满足待插入元素大于当前数组元素的时候，终止循                环，并用变量保存当前下标</p><p>​            b)给待插入的元素腾位置</p><p>​                    从后往前移动元素    否则会元素覆盖，丢失i=lenght-1；i&gt;找到的小标值；i—    前一个的值赋值给后一个</p><p>​            c）插入元素</p><p>​                        数组名[下标]=元素值；</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符:"></a>运算符:</h3><ol><li><p>赋值运算符</p><p>​    符号:  =  </p></li></ol><p>​            把等号右边的值赋给左边</p><p>​            sum+=i;//sum=sum+i;</p><p>​    2.算数运算符</p><p>​        + - * /(求商)  %(求余数)  ++(自增)  —(自减)</p><p>​    3.关系运算符：</p><p>​        >,&lt; ,&gt;=,&lt;=,  == (比较两个数是否相等)  !=（比较两数是否不等）        </p><p>​            注意:比较的结果用boolean 类型 的数据表示</p><p>​    4.逻辑运算符：</p><p>​         &amp;&amp;　　 ||　　！</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>​    ！＞算术运算符＞关系运算符＞＆＆＞｜｜最高小括号,最低赋值运算符</p><h3 id="二-流程控制语句"><a href="#二-流程控制语句" class="headerlink" title="二.流程控制语句"></a>二.流程控制语句</h3><p>​                    流程图—-&gt;表示程序的运行流程    </p><p>​                           ◇  —-&gt;表示判断</p><p>​                        矩形—-&gt;表示代码块</p><p>​            平行四边形—-&gt;输出语句</p><p>​                圆角矩形 —-&gt;开始或者结束</p><h4 id="1-选择结构"><a href="#1-选择结构" class="headerlink" title="1. 选择结构"></a>1. 选择结构</h4><p>1）简单的if选择结构</p><p>​        语法结构：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(boolean类型的值)&#123;       &#x2F;&#x2F;代码块&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）if—else选择结构———用于两种分支判断的情形</p><p>​        语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if()&#123;&#x2F;&#x2F;代码块1&#125;else&#123;&#x2F;&#x2F;代码块2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）多重if语句：用于区间连续情形</p><p>5)switch选择结构—-用于判断价值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">switch(变量)&#123;case常量1：&#x2F;&#x2F;代码块break;case常量2：&#x2F;&#x2F;代码块break;...default:&#x2F;&#x2F;代码块        break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>switch小括号里的变量  —-&gt;整型和字符型,jdk版本1.7以上 支持String</li><li><p>2.break可以省略,但是省略之后case之间会贯穿执行,直到遇到break才结束</p><p>3.各个case之间常量值不能重复的</p><p>4.default 总是在最后执行的,当前面所有的case都匹配不上时,位置不固定    </p></li></ol><h4 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h4><p>1)while循环——-先判断再执行</p><p>​            初始化循环变量</p><p>​            while(判断条件){</p><p>​                //循环操作  </p><p>​                更新循环变量</p><p>​            }</p><p>2)do-while—-先执行再判断  </p><p>​            //定义循环变量</p><p>​            do{</p><p>​                //循环体</p><p>​                循环变量的更新</p><p>​            }while(判断条件);</p><p>3)for循环—-用于固定循环次数</p><p>​            for(循环变量初始化;条件判断;循环变量更新){</p><p>​                循环体</p><p>​               }</p><p>执行顺序：同while    1.变量初始化    2.条件判断    3.循环体    4.变量更新</p><h6 id="注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较"><a href="#注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较" class="headerlink" title="注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较"></a>注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较</h6><p>顺序：</p><p>​                先判断后执行：while for</p><p>​                先执行后判断：do-while</p><h6 id="注意：（1）for循环主要用于循环次数固定"><a href="#注意：（1）for循环主要用于循环次数固定" class="headerlink" title="注意：（1）for循环主要用于循环次数固定"></a>注意：（1）for循环主要用于循环次数固定</h6><h6 id="（2）在循环条件不成立的时候，do-while至少执行一次"><a href="#（2）在循环条件不成立的时候，do-while至少执行一次" class="headerlink" title="（2）在循环条件不成立的时候，do-while至少执行一次"></a>（2）在循环条件不成立的时候，do-while至少执行一次</h6><p>4)二重循环</p><p>​            一个完整的循环结构  再嵌套另一个  </p><p>​            for(){</p><p>​              //循环体</p><p>​              for(){</p><p>​              }</p><p>​            }</p><p>​            外层循环变化一次,内层循环变化一遍</p><h4 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3.流程控制语句"></a>3.流程控制语句</h4><p>break:</p><p>​            1)单层循环中: 终止循环，执行循环外的语句</p><p>​            2)二重循环中:用在内层循环中,只能结束内层循环,执行外层剩下的代码</p><p>continue：  </p><p>​            1)单层循环:跳过本次循环，执行下一次循环</p><p>​            2)结束本层的本次循环 执行本层下一次    </p><h6 id="解决代码中的异常"><a href="#解决代码中的异常" class="headerlink" title="解决代码中的异常:"></a>解决代码中的异常:</h6><h6 id="常见的错误信息"><a href="#常见的错误信息" class="headerlink" title="常见的错误信息:"></a>常见的错误信息:</h6><h6 id="1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用"><a href="#1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用" class="headerlink" title="1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用"></a>1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用</h6><h6 id="2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明"><a href="#2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明" class="headerlink" title="2.num cannot be resolved to a variable===&gt;变量没有声明"></a>2.num cannot be resolved to a variable===&gt;变量没有声明</h6><h6 id="3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException"><a href="#3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException" class="headerlink" title="3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException"></a>3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException</h6><h6 id="当访问超出了数组下标范围"><a href="#当访问超出了数组下标范围" class="headerlink" title="当访问超出了数组下标范围"></a>当访问超出了数组下标范围</h6><h6 id="Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常"><a href="#Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常" class="headerlink" title="Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常"></a>Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常</h6><p>简单的异常处理</p><p>​        input.hasNextInt()  判断用户输入的内容是否是合法整数,合法为true,否则为false</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    要在变量赋值之前判断</p><p>​    程序调试  程序在我们的控制下一步一步执行</p><p>​     *    1.调试代码之前,要先分析可能出错的位置    </p><p>​     *    2.在可能出错的地方  打断点—-代码执行到断点处会暂停   行号前双击</p><p>​     *    3.以debug模式启动程序  debug as—-java application</p><pre><code> *    4.单步执行,查找错误(F6) &#123;程序运行到断点处才会启动调试模式&#125;</code></pre><p>​     *    5.找到错误,修改代码</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="一-什么叫面向对象"><a href="#一-什么叫面向对象" class="headerlink" title="一.什么叫面向对象"></a>一.什么叫面向对象</h4><p>相对于面向过程</p><p>​    在完成某件事情的时候,找到一个能完成该功能的对象,而不关心内部细节</p><p>​    如:数组排序的时候,我们只是调用了Arrays类的sort()方法就可以完成排序,但是具体是怎么实现的并没有过多的关心</p><h4 id="二-类和对象"><a href="#二-类和对象" class="headerlink" title="二.类和对象"></a>二.类和对象</h4><h5 id="1-现实中各类分类及描述"><a href="#1-现实中各类分类及描述" class="headerlink" title="1.现实中各类分类及描述"></a>1.现实中各类分类及描述</h5><p>手机:</p><p>​            属性(静态特征):    颜色,品牌,内存,处理器  </p><p>​            功能(动态行为): 打电话,发短信,上网</p><p>学生:</p><p>​            属性(静态特征) ;姓名,性别,身高,体重,学号,班级</p><p>​            功能(动态行为):学习,打代码</p><p>电脑:</p><p>​         属性(静态特征):品牌,外观,cpu,硬盘,内存</p><p>​            功能(动态行为); 开机,关机,运行各种软件</p><h5 id="2-怎么用java语言来描述现实生活中的分类"><a href="#2-怎么用java语言来描述现实生活中的分类" class="headerlink" title="2.怎么用java语言来描述现实生活中的分类"></a>2.怎么用java语言来描述现实生活中的分类</h5><p>public class 类名{</p><p>​            //属性——描述类的静态的特征</p><p>​            String 属性名;</p><p>​            int  属性名;</p><p>​            //方法——描述类的动态的行为</p><p>​            public void 方法名(){</p><p>​            }</p><p>​        }</p><h5 id="3-什么是对象"><a href="#3-什么是对象" class="headerlink" title="3.什么是对象"></a>3.什么是对象</h5><p>对象是用来描述客观事物的一个实,是具体的,能够看得见摸得着的</p><p>​            汽车—-类     我家楼下停着的那辆白色的宝马—-对象</p><p>​         *             手机—-类     我的这部手机——对象</p><p>​         *             椅子—-类     我现在正坐的椅子—-对象</p><p>​         *             演员—-类   女演员—-类     年龄是20到30岁之间的女演员 -类   迪丽热巴—对象 </p><p>​         *             作家—类   男作家—-类   郭敬明—对象</p><h5 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4.类和对象的关系"></a>4.类和对象的关系</h5><p>​        类定义了对象将会拥有的特征（属性）和行为（方法）———相当于图纸/模板</p><p>​        类是抽象的,对象是具体的</p><p>​        类是对象的类型,对象是类的实例</p><p>​        Car c=new Car();</p><p>​        int a=19;</p><h5 id="5-如何创建对象"><a href="#5-如何创建对象" class="headerlink" title="5.如何创建对象"></a>5.如何创建对象</h5><p>类名  对象名=new 类名();</p><h5 id="6-调用对象的属性"><a href="#6-调用对象的属性" class="headerlink" title="6.调用对象的属性"></a>6.调用对象的属性</h5><p>​    对象名.属性名;</p><h5 id="7-调用对象的方法"><a href="#7-调用对象的方法" class="headerlink" title="7.调用对象的方法"></a>7.调用对象的方法</h5><p>​    对象名.方法名();</p><h4 id="三-封装"><a href="#三-封装" class="headerlink" title="三.封装"></a>三.封装</h4><p>1.对象同时具有属性和方法两项特性</p><p>2.对象的属性和方法通常被封装在一起，共同体现事物的特性， 二者相辅相承，不能分割 </p><p>​    </p><p>​    如:一辆汽车，有完好的零件和特定的颜色还应具备开动、刹车等方法行为 </p><h4 id="四-面向对象的好处"><a href="#四-面向对象的好处" class="headerlink" title="四.面向对象的好处"></a>四.面向对象的好处</h4><p>​    1.与人类的思维习惯一致`</p><p>​    2.提高了程序的可重用性 </p><p>​    3.信息隐藏，提高了程序的可维护性和安全性  </p><h3 id="五、类的无参方法"><a href="#五、类的无参方法" class="headerlink" title="五、类的无参方法"></a>五、类的无参方法</h3><p>​    定义格式</p><p>​        public  返回值类型  方法名(){</p><p>​            //方法主体</p><p>​        }</p><h4 id="返回值类型的两种情况"><a href="#返回值类型的两种情况" class="headerlink" title="返回值类型的两种情况"></a>返回值类型的两种情况</h4><p>​        1.有具体的返回值类型    方法体最后一句话要添加return语句,返回相应类型的值</p><p>​        2.没有具体返回值类型 void  方法体中,可以不加return语句</p><p>​    注意：1.所有的数据类型,都可以作为方法的返回值类型</p><p>​    </p><p>​    2.调用带有返回值的方法的时候,一定要读返回值有所处理，要定一个相应类型的变量来接收方法的返回值</p><p>​    \3. return 的作用//1.跳出方法(方法执行到return语句就结束了)  2.返回结果</p><p>​    4.方法不能返回多个值</p><p>​    5.多个方法不能嵌套定义</p><p>​    6.方法外面不能写逻辑代码</p><h4 id="方法调用的两种情况"><a href="#方法调用的两种情况" class="headerlink" title="方法调用的两种情况"></a>方法调用的两种情况</h4><p>​    1.同类之间的方法调用  直接通过  方法名()  来调用</p><p>​    2.不同类的方法   先创建对象  通过  对象名.方法名()  来调用</p><p>方法返回值:</p><p>​    有些方法在执行完成之后,要给调用方法的对象返回一个值</p><h3 id="六、变量的分类"><a href="#六、变量的分类" class="headerlink" title="六、变量的分类"></a>六、变量的分类</h3><h4 id="1-成员变量-："><a href="#1-成员变量-：" class="headerlink" title="1.成员变量 ："></a>1.成员变量 ：</h4><p>定义在类中的，属性的位置</p><p>​           本类，其他类都可以访问（现阶段来说）</p><h4 id="2-局部变量："><a href="#2-局部变量：" class="headerlink" title="2.局部变量："></a>2.局部变量：</h4><p>定义在方法中的</p><p>​           只能在  定义的变量的方法  中使用</p><p>​    变量只能在定义它的大括号的范围内使用</p><p>​    区别：</p><h4 id="1-作用范围"><a href="#1-作用范围" class="headerlink" title="1.作用范围"></a>1.作用范围</h4><h4 id="2-初始值："><a href="#2-初始值：" class="headerlink" title="2.初始值："></a>2.初始值：</h4><p>​              成员变量在没有初始值的情况下，java会给默认的初始值</p><p>​              局部变量不会</p><p>​    注意：同一个方法中不能有同名的局部变量，同一个类中也不能有重复的成员变量</p><p>​       不同的方法中可以存在同名的局部变量</p><p>​       成员变量和局部变量能否定义相同的名字，可以的</p><p>​       局部变量和成员变量可以重名，但是局部变量具有更高的优先级</p><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释  /*  /"></a>文档注释  /<em>*  </em>/</h4><p>​    注释：类，属性，方法</p><p>​    可以把注释的内容抽取出来，显示成文档，方便开发人员使用</p><p>​    @version  版本  </p><p>​    @author  作者</p><p>​    @return  返回值</p><p>​    @param  参数</p><p>​    @exception  异常情况</p><h3 id="七、带参方法"><a href="#七、带参方法" class="headerlink" title="七、带参方法"></a><strong>七、带参方法</strong></h3><p>定义</p><p>​        访问修饰符（public）  返回值类型   方法名（数据类型  变量名,数据类型 变量名….）{</p><p>​            </p><p>​        }</p><p>​        注意:方法定义时的参数列表为形参列表,说明了方法调用的时候需要几个,什么类型的参数，逗号分隔</p><p>调用：</p><h4 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h4><p>​            数据类型 变量=对象名.方法名（变量1,变量2,变量3,…..）；</p><p>​        无返回值</p><p>​            对象名.方法名(参数1,参数2,….);</p><p>​        注意:实参是调用方法时小括号里传递的,要和形参列表一一对应</p><p>一个方法可以有无数个参数,一个返回值</p><h4 id="数组当参数的方法"><a href="#数组当参数的方法" class="headerlink" title="数组当参数的方法"></a>数组当参数的方法</h4><p>​    定义:</p><p>​        public  返回值  方法名(数据类型[] 数组名){</p><p>​            return  值;</p><p>​        }</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用:"></a>调用:</h4><p>​        数据类型[] 实参数组名=new 数据类型[长度];</p><p>​        //数组元素的赋值</p><p>​        数据类型  变量= 对象名.方法名(实参数组名);</p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组:"></a>对象数组:</h4><p>​    定义:</p><p>​        类名[] 数组名=new  类名[数组长度];  如:Student[] stus=new Student[6];</p><p>​    赋值:  1.数组名[下标]=new 类名();      如:stus[0]=new Student();    </p><p>​        数组名[下标].属性</p><p>​        数组名[下标].方法();</p><h4 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h4><p>​    public  返回值类型  方法名(类名  对象名){</p><p>​    }</p><p>调用:</p><p>​    //创建方法所在类的对象</p><p>​    类名  方法所在类的对象名=new 类名();</p><p>​    </p><p>​    //创建传递参数的对象</p><p>​    类名 对象名=new  类名();</p><p> 方法所在类的对象名.方法名(对象名);</p><h4 id="package-包声明语句"><a href="#package-包声明语句" class="headerlink" title="package 包声明语句"></a>package 包声明语句</h4><p>​    本类所在包的路径,以点号分割</p><p>​    必须是除了注释之外的第一条语句</p><p>import  包导入语句</p><p>​    指明要导入的类的路径,也是以点号分割</p><p>​    包名完整路径.类名 导入某一个类</p><p>​    包名完整路径.*   导入某一个包下面所有的类</p><h4 id="java中包名命名规则"><a href="#java中包名命名规则" class="headerlink" title="java中包名命名规则:"></a>java中包名命名规则:</h4><p>全小写,不能以点号开始或者结束,</p><p>​         有时前面会加上域名和项目组织名称</p><h3 id="八、字符串-String-StringBuffer"><a href="#八、字符串-String-StringBuffer" class="headerlink" title="八、字符串:  String,StringBuffer"></a>八、字符串:  String,StringBuffer</h3><p>调用字符串方法的时候要注意以下几点:</p><p> <strong>1.方法的作用  2.方法的参数  3.方法的返回值</strong></p><p>注意:java jdk 开发工具包中字符串类的定义有final 关键字,final含义是最终的意思,所以字符串对象一经创建,就不能更改</p><p>​        比如:  String s1=”hello”;  s1+=”,world”;  //s1=hello ,world</p><p>​        由于字符串的内容是不能修改的,所以这个例子里面实际上是创建了两个String对象 既:只要对字符串的内容修改一次,就会重新创建一个字符串类的对象</p><h4 id="1-创建字符串对象"><a href="#1-创建字符串对象" class="headerlink" title="1.创建字符串对象"></a><strong>1.创建字符串对象</strong></h4><p>​        String s=””;</p><p>​        String s=new String();</p><p>​        String s=new String(“hello world”);</p><h4 id="2-String类的方法"><a href="#2-String类的方法" class="headerlink" title="2.String类的方法"></a><strong>2.String类的方法</strong></h4><p>​        <strong>调用字符串类的的方法的时候,要注意,方法是否有参数,以及返回值类型</strong></p><p><strong>Ø</strong> 获取字符串长度  返回int类型</p><p>​        </p><p><strong>Ø</strong> <strong><em>equals()</em></strong>:比较字符串内容相等</p><p><strong>注意:如果用”==” 比较字符串的值,实际比较的是两个字符串的地址是否相同</strong></p><p><strong>Ø</strong> <strong><em>equalsIgnoreCase()</em></strong>比较相等时忽略大小写,用法和equals相同</p><p>​        字符串大小写转换</p><p><strong>Ø</strong> <strong><em>toLowerCase()</em></strong> 将字符串全部转化为小写</p><p><strong>Ø</strong> <strong><em>toUpperCase()</em></strong> 将字符串转换成大写</p><p><strong>注意:原来的字符串不会改变,转换之后的会作为返回值返回</strong></p><p>​            <strong>如:</strong></p><p>​            <strong>String name=”tom”;</strong></p><p>​            <strong>String s=name.toUpperCase();</strong></p><p>​            <strong>System.out.println(“name=”+name);// tom</strong></p><p>​            <strong>System.out.println(“s=”+s);//TOM</strong></p><p><strong>Ø</strong> <strong><em>字符串连接的方法</em></strong></p><p><strong></strong> <strong><em>使用”+”拼接字符串</em></strong></p><p><strong>‚</strong> <strong><em>字符串.concat(“”);</em></strong>原来的字符串不会改变,转换之后的会作为返回值返回</p><p>比如:String s=”123”;  String s1= s.concat(“111”);</p><p>​                   输出s的值为  123——&gt;s还是为原来的值,并没有改变</p><p>​                 输出s1的值  123111——-&gt;拼接的结果是作为返回值,接收输出返回值就是拼接之后的值</p><p><strong>Ø</strong> <strong><em>字符串的提取</em></strong></p><p><strong></strong> <strong><em>字符串.indexOf()</em></strong> </p><p>参数:int或者String </p><p>​                返回值:int  代表要查找字符第一次出现的下标位置</p><p><strong>注意:字符串字符下标从0开始</strong></p><p>​                          <strong>如果没有找到,返回值-1</strong></p><p><strong>‚</strong> <strong><em>字符串.lastIndexOf();</em></strong> </p><p>参数:int或者String </p><p>​                最后一次出现的下标</p><p><strong>ƒ</strong> <strong><em>\</em>字符串.indexOf(int/String , int fromIndex);**</strong> </p><p>从fromindex位置开始的第一次出现的下标位置</p><p><strong>„</strong> <strong><em>\</em>字符串.charAt(int index)**</strong> </p><p> 返回值类型:char  </p><p>​               查找返回  对应下标的字符</p><p>截取字符串:</p><p>​            1.substring(开始的下标)  //截取从下标位置开始到字符串结束  部分的内容</p><p>​             例如:</p><p>​                String s=”郑州职业技术学院”;</p><p>​                String s1=s.substring(2);</p><p>​                System.out.println(“截取出来的字符串是:”+s1);//职业技术学院</p><p>​            2.substring(开始的下标,结束下标)  返回值:String  截取之后的</p><p>​                注意:开始下标从0 计算  结束下标从1开始计算</p><p>去前后空格  :trim()  返回值类型:String   注意:原来的字符串不改变,去掉空格的字符串以返回值的形式返回</p><p>​            String str=”  abc  “;</p><p>​            String str_new=str.trim();  或者  str=str.trim();</p><p>​            str还是带有空格的, str_new 去掉前后空格的</p><p>​        分割字符串:</p><p>​            1.split(String regx); 参数:分隔符  返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割</p><p>​            2.split(String regx,int limit); 参数:分隔符,分割之后返回的数组元素的个数   返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割成limit份</p><p>StringBuffer  :String类的增强版</p><p>​        优势:频繁对字符串的内容进行修改的时候要使用这个类</p><p>​        原因是:String对象一经创建,不能更改,如果修改了String对象的内容,系统会新创建一个对象来存放修改之后的内容</p><p>​            但是StringBuffer 存储的字符串的内容可以更改</p><p>​        方法:</p><p>​            1. toString();将StringBuffer的对象转换成String类型</p><p>​                //StringBuffer 和  String 类型相互转化</p><p>​                StringBuffer sb=new StringBuffer(“123”);</p><p>​                String s=sb.toString();</p><p>​        //String —-&gt;StringBuffer</p><p>​                String str=”123”;</p><p>​                StringBuffer sb1=new StringBuffer(str);</p><p>​            2. append(); 在字符串后面追加内容</p><p>​            3. StringBuffer对象.insert(int index,要插入的内容); 下标从0开始</p><p>​                将str的内容插入 对象中下标是index位置</p><p>​            4.length()  返回字符串对象的长度</p><h6 id="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"><a href="#java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件" class="headerlink" title="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"></a>java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件</h6>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
