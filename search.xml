<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Idea破解版的下载及安装</title>
      <link href="posts/4127.html"/>
      <url>posts/4127.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、在安装之前先下载一下吧！"><a href="#一、在安装之前先下载一下吧！" class="headerlink" title="一、在安装之前先下载一下吧！"></a>一、在安装之前先下载一下吧！</h2><p>点击以下传送门去腾讯微云下载！！！</p><p><a href="https://share.weiyun.com/Big4DCy8" target="_blank" rel="noopener">传送门</a></p><h2 id="二、安装方法，及破解方法，如图："><a href="#二、安装方法，及破解方法，如图：" class="headerlink" title="二、安装方法，及破解方法，如图："></a>二、安装方法，及破解方法，如图：</h2><p>请按以下方法一步一步来…………………..！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224752.png" alt="001"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224849.png" alt="002"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224906.png" alt="003"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224916.png" alt="004"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224923.png" alt="005"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224939.png" alt="006"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224954.png" alt="007"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225011.png" alt="008"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225019.png" alt="009"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225027.png" alt="010"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225036.png" alt="011"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225046.png" alt="012"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225057.png" alt="013"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225106.png" alt="014"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225117.png" alt="015"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225128.png" alt="016"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225138.png" alt="017"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225150.png" alt="018"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225204.png" alt="019"></p><p>长路漫漫，水分多多，又水完一篇文章！！！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="posts/48508.html"/>
      <url>posts/48508.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><blockquote><p>Throwable 类是Java语言中所有错误和异常的顶级父类，直接子类为 Error 和 Exception</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 无参构造：构造一个新的 throwable 对象，其详细信息为nullpublic Throwable()// 有参构造：使用指定的详细信息(message)构造一个新的 throwable 对象public Throwable(String message)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 返回此 throwable 对象的详细信息字符串public String getMessage()// 返回一个简要信息描述public String toString()// 打印此 throwable 对象及其详细信息字符串到标准错误流(控制台)public void printStackTrace()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Throwable throwable1 = new Throwable();        System.out.println(throwable1.getMessage());        System.out.println(throwable1.toString());        throwable1.printStackTrace();        Throwable throwable2 = new Throwable("错误信息！！！");        System.out.println(throwable2.getMessage());        System.out.println(throwable2.toString());        throwable2.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote><p>Error 类是 Throwable 的子类，它指出了一个合理的应用程序不应该试图捕捉的严重问题</p></blockquote><p>【注意】Error 结尾的是严重问题，无法解决</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote><p>Exception 类及其子类是一种 Throwable 的子类，指示了一个合理的应用程序可能想要捕获的条件。</p></blockquote><p>【注意】Exception 结尾的是我们可以处理的，一般我们需要关注的是 RuntimeException</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><blockquote><p>异常处理分为两种：捕获和抛出</p><p><strong>有能力处理就进行捕获，没有就抛出</strong></p></blockquote><h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    try {        // 有可能出现问题的代码，存在一定隐患的代码    } catch (异常类型 变量名) {        // 对应当前异常类型的处理方式    } finally {        // 无论是否捕获，都会执行，常用于释放资源    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        int num1 = 0;        int num2 = 20;        int ret = 0;        /*         * 除数不能为0         */        try {            ret = num2 / num1;        } catch (ArithmeticException e) {            e.printStackTrace();        }        System.out.println(ret);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">java.lang.ArithmeticException: / by zero    at code.exception.Test.main(Test.java:11)0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【注意】</p><blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、代码中出现异常，JVM会终止代码运行，如果使用try catch捕获处理异常，JVM会认为当前代码中不存在异常，可以继续运行。2、try - catch代码块中声明的都是局部变量，需要提前声明3、try - catch捕获处理异常，可以处理多种异常情况4、代码中存在多种隐患，存在多个异常情况，try - catch捕获有且只能处理第一个出现异常的代码，因为JVM从异常代码开始直接进入异常捕获阶段5、Exception作为Java中所有异常的超类，在捕获异常处理时如果直接使用Exception进行捕获处理，无法具体到对某一个异常来处理6、Exception可以作为try - catch 最后一个，用于处理其他异常捕获之后没有对症方式遗留问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">关键字:    throw        在方法内特定条件下抛出指定异常，后面跟异常类型的对象    throws        在【方法声明】位置，告知调用者，当前方法有哪些异常抛出，后面跟异常的类型    用于处理非当前方法操作问题，导致出现的异常，一般情况下是用于处理方法运行过程中因为参数传入，参数处理，运算结果导致的问题，抛出异常。    throw是一个稍微高级的参数合法性判断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestThrows {    public static void main(String[] args) {        try {            test(1, 0);        } catch (ArithmeticException e) {            e.printStackTrace();        }    }    /**     * 测试方法，打印两个数的差     *      * @param num1 第一个参数，被除数     * @param num2 第二个参数，除数     * @throws ArithmeticException 如果除数为0，抛出异常     */    public static void test(int num1, int num2) throws ArithmeticException {        if (0 == num2) {            throw new ArithmeticException("除数不能为0");        }        System.out.println(num1 / num2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">java.lang.ArithmeticException: 除数不能为0    at code.exception.TestThrows.test(TestThrows.java:23)    at code.exception.TestThrows.main(TestThrows.java:7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、throw 和 throws 必须同时出现，并且体现在注释上2、代码如果运行到throw抛出异常，之后的代码不再运行，之后的代码是成为无法抵达的代码3、代码中存在多种隐患，按照隐含的情况，分门别类处理，不能在同一个条件内抛出两个异常。并且在方法的声明位置，throws之后，不同的异常，使用逗号隔开4、当调用带有异常抛出的方法时，对于方法抛出的异常，有两种处理方式，可以捕获处理，也可以抛出处理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">RuntimeException：代码运行过程中出现的异常，没有强制处理的必要性，因为JVM会处理RuntimeException异常，即报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="其他异常"><a href="#其他异常" class="headerlink" title="其他异常"></a>其他异常</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">强制要求处理，不管是捕获处理还是抛出处理，都需要进行操作，如果未处理就会报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><blockquote><p>继承自 Exception 或者 RuntimeException，只需要提供无参构造和一个带参构造即可</p><p>【注意】如果继承自Exception，调用抛出了此异常的方法需要手动对其捕获或者抛出</p></blockquote><p>自定义异常类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyException extends Exception {    public MyException() {}    public MyException(String message) {        super(message);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        try {            buy(false);        } catch (MyException e) {            e.printStackTrace();        }    }    /**     * 买方法，当没有女朋友的时候，抛出异常     * @param hasGirlFriend boolean类型，是否有女朋友     * @throws MyException 自定义单身狗异常     */    public static void buy(boolean hasGirlFriend) throws MyException {        if (false == hasGirlFriend) {            throw new MyException("你还没有女朋友");        }        System.out.println("买一送一");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">code.myexception.MyException: 你还没有女朋友    at code.myexception.Test.buy(Test.java:19)    at code.myexception.Test.main(Test.java:6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、父类的方法有异常抛出，子类的重写方法在抛出异常的时候必须要小于等于父的异常2、父类的方法没有异常抛出，子类的重写方法不能有异常抛出3、父类的方法抛出多个异常，子类的重写方法必须比父少或者小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、异常的存在是非常有必要的，可以帮助我们定位和解决问题</p><p>2、异常的处理方式：捕获和抛出</p><p>3、自定义异常一定要有无参构造和有参构造</p><p>4、后期会遇到大量的异常，一般使用快捷键就能搞定</p><p>​        Eclipse：Ctrl + 1</p><p>​        Idea：Alt + Enter</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用String语句和集合</title>
      <link href="posts/24535.html"/>
      <url>posts/24535.html</url>
      
        <content type="html"><![CDATA[<p>此内容必须会！！！</p><h2 id="String语句"><a href="#String语句" class="headerlink" title="String语句"></a>String语句</h2><p>用老师的话说，如果在上班的时候你不会这些，去搜索被领导看到，就可以领盒饭了</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//获取字符串的长度int length();//获取指定下标位置的字符char charAt(int index);//获取指定字符在字符串中首此出现的下标位置int indexOf(int ch);//获取指定字符串在字符串中首此出现的下标位置int indexOf(String str);//获取指定字符在字符串中最后一次出现的下标位置int lastIndexOf(char ch);//获取指定字符串在字符串中最后一次出现的下标位置int lastIndexOf(String str);//从指定下标位置开始，到字符串结尾截取字符串String substring(int beginIndex);//从指定beginIndex开始，到endIndex结束，截取字符串【注意】要头不要尾String substring(int beginIndex,int endIndex);//去除字符串两端空格String trim();//使用指定字符串对当前字符串进行切割，获取一个字符串数组String[] split(String regex);//判断是否以指定字符串作为前缀结束boolean startsWith(String prefix);//判断是否以指定字符串作为后缀结束boolean endsWith(String suffix);//判断字符串是否为空boolean isEmpty();//与指定对象比较，判断是否相等boolean equals(Object anObject);//忽略大小写判断是否与指定字符串相等boolean equalslgnoreCase(String anotherString);//判断是否包含指定序列（搜索）boolean contains(String str);//字符数组转字符串String(char [] value);//从字符串数组的指定位置开始，截取指定个数的字符转为字符串String (char[] value,int offset,int count);//同理String（char[]value）static String valueOf(char[] data);//同理String(char[] value,int offset,int count);static String valueOf(char[] data,int offset,int count);//使用新字符替换字符串中的旧字符String replace(char oldChar,char newChar);//将字符串转换为字符数组char[] toCharArray();//将字符串中所有的英文字母转大写String toUpperCase();//将字符串中所有的英文字母转小写String toLowerCase();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201113093848.jpg" alt="String"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 添加当前集合约束的指定数据类型到当前集合中add(E e);// 添加另一个集合到当前集合中，要求添加集合中保存的元素必须是当前集合中//保存元素本身或者其子类对象addAll(Collection<? extends E> e);// 删除集合中的指定元素，删除成功返回true,未找到指定元素，无法删除返回false，//并且在多个元素的情况下，删除找到的第一个元素。boolean remove(Object obj);// 在当前集合中删除两个集合的交集    boolean removeAll(Collection<?> c);// 在当前集合中保留两个集合的交集boolean retainAll(Collection<?> c);// 清空整个集合中的所有元素void clear();// 获取集合中有效元素的个数int size();// 判断当前集合是否为空，是否存在有效元素boolean isEmpty();// 判断指定元素是否在当前集合中存在boolean contains(Object obj);// 判断传入的参数集合是不是当前集合的子集合boolean containsAll(Collection<?> c);// 返回集合中所有保存元素的Object类型数组Object[] toArray();// 获取集合的迭代器对象，泛型对应的具体数据类型和集合中约束的泛型具体数据类型一致。Iterator<K> iterator();    // 判断当前集合中是否可以继续得到元素，(是否可以继续遍历)    boolean hasNext();    // 1. 获取迭代器当前指向的元素    // 2. 将迭代器指向下一个元素    E next();    // 删除通过next方法获取到元素    /*      * 【注意】     *      *    1、remove方法只能删除next方法获取到元素     *    2、remove方法只能在next方法之后执行，且不能跨过一个next执行     *    3、没有next不能使用remove     */    boolean    remove();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// List接口继承Collection接口 add方法，使用操作和Collection一致，//并且这里采用的添加方式是【尾插法】add(E e);// List接口【特有方法】，在指定位置，添加指定元素add(int index, E e);// List接口继承Collection接口 addAll方法，使用操作和Collection一致，//并且这里采用的添加方式是【尾插法】addAll(Collection<? extends E> e);// List接口【特有方法】，在指定下标位置，添加另一个集合中所有内容addAll(int index, Collection<? extends E> e);// List接口【特有方法】，获取指定下标位置的元素并删除E remove(int index);// List接口继承Collection接口方法。删除集合中的指定元素boolean remove(Object obj);// List接口继承Collection接口方法。删除当前集合中和参数集合重复元素boolean removeAll(Collection<E> e);// List接口继承Collection接口方法。保留当前集合中和参数集合重复元素boolean retainAll(Collection<E> e);// List接口继承Collection接口方法。清空整个集合中的所有元素void clear();// List接口【特有方法】，使用指定元素替代指定下标的元素，返回值是被替换的元素E set(int index, E e);// List接口继承Collection接口方法。获取集合中有效元素个数int size();// List接口继承Collection接口方法。判断当前集合是否为空boolean isEmpty();// List接口继承Collection接口方法。判断指定元素是否包含在当前集合中boolean contains(Object obj);// List接口继承Collection接口方法。判断参数集合是不是当前集合在子集合boolean containsAll(Collection<?> c);// List接口继承Collection接口方法。获取当前集合中所有元素Object数组Object[] toArray();// List接口【特有方法】。获取指定下标对应的元素E get(int index);// List接口【特有方法】。获取当前集合指定子集合，从fromIndex开始，到toIndex结束。fromIndex <= 范围 < toIndexList<E> subList(int fromIndex, int toIndex);// List接口【特有方法】。获取指定元素在集合中第一次出现位置int indexOf(Object obj);// List接口【特有方法】。获取指定元素在集合中最后一次出现的位置int lastIndexOf(Object o);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在当前链表开始位置加元素boolean addFirst(E e);// 在当前链表末尾添加元素    boolean addLast(E e);// 获取第一个Node节点元素数据        E getFirst();// 获取末尾Node节点元素数据        E getLast();// 删除头节点    E removeFirst();// 删除末尾节点        E removeLast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 添加符合Map要求的键值对存入到双边队列中V put(K key, V value);// 添加另一个Map到当前Map中，要求K是当前Map本身对应的K，//或者其子类，V是当前Map本身对应的V，或者其子类        void putAll(Map<? extends K, ? extends V> map)// 删除对应Key键值对V remove(Object key); // 使用value修改已存在的key对应的值V put(K key, V value);// Map双边队列个数int size();// 判断当前Map双边队列中是否为空boolean isEmpty();// 判断指定Key是否存在boolean containsKey(Object key);// 判断指定Value是否存在boolean containsValue(Object value);// 返回Map双边队列中所有Key对应的Set集合Set<K> keySet();// 返回Map双边队列中所有value对应Collection集合Collection<V> values();// 返回值类型是Entry键值对形式数据的Set集合Set<Map.Entry<K, V>> entrySet();/* * Set<Map.Entry<K, V>> * * Map.Entry<K, V> Map接口的内部接口Entry，使用的泛型 K,V对应Map 创建过程中约束的K,V因为返回值是Set集合， 集合带有泛型 Set<Map接口中的内部接口Entry> */Entry 对应的方法    // 返回与此项对应的键    K getKey();    // 返回与此项对应的值。    V getValue();    // 用指定的值替换与此项对应的值，返回与此项对应的旧值     V setValue(V value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此地方有集合如何使用的具体用法    <a href="https://ialoe.top/posts/9443.html">https://ialoe.top/posts/9443.html</a></p>]]></content>
      
      
      <categories>
          
          <category> String语句 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel</title>
      <link href="posts/3086.html"/>
      <url>posts/3086.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、求和函数SUM"><a href="#1、求和函数SUM" class="headerlink" title="1、求和函数SUM()"></a>1、求和函数SUM()</h3><blockquote><p><strong>SUM</strong>函数将为值求和。 可以将单个值、单元格引用或是区域相加，或者将三者的组合相加。</p></blockquote><p>1、指定数值求和</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(10,20,30)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求和：输入=sum()，在括号中间按住ctrl连续点击即可选择需要求和的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C5,C9,C3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、也可以将指定单元格直接相加</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2 + C4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、区域求和，输入=sum()，在括号中间按住ctrl选中所需要求和的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、多个区域求和，输入=sum()，在括号中间分别按住ctrl选中所需要的多个区域的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C4,C6:C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、配合固定值进行求和，中间使用英文的逗号分隔</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C11,100)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、条件求和函数SUMIF"><a href="#2、条件求和函数SUMIF" class="headerlink" title="2、条件求和函数SUMIF()"></a>2、条件求和函数SUMIF()</h3><blockquote><p>按条件求和</p></blockquote><p>sumif函数的语法格式</p><blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=sumif(range，criteria，sum_range)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sumif（条件区域，求和条件，实际求和区域），第二个求和条件参数在第一个条件区域里。</p></blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUMIF(D2:D11,D4,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>求和所有性别中性别为女的年龄</p><h3 id="3、求平均值函数AVERAGE"><a href="#3、求平均值函数AVERAGE" class="headerlink" title="3、求平均值函数AVERAGE()"></a>3、求平均值函数AVERAGE()</h3><blockquote><p>获取平均值</p></blockquote><p>1、指定数值求平均值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(10,20)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求平均值:括号内按ctrl选择需要求平均值的单元格</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(C2,C8)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、范围单元格求平均值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、求最大值函数MAX"><a href="#4、求最大值函数MAX" class="headerlink" title="4、求最大值函数MAX()"></a>4、求最大值函数MAX()</h3><blockquote><p>获取最大值</p></blockquote><p>1、指定数值求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、求最小值函数MIN"><a href="#5、求最小值函数MIN" class="headerlink" title="5、求最小值函数MIN()"></a>5、求最小值函数MIN()</h3><blockquote><p>获取最小值</p></blockquote><p>1、指定数值求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、计数函数COUNT"><a href="#6、计数函数COUNT" class="headerlink" title="6、计数函数COUNT()"></a>6、计数函数COUNT()</h3><blockquote><p>获取指定单元格非空数据数值类型的个数，对于空单元格、逻辑值或者文本数据将被忽略。可以用来判断是否有空白单元格</p></blockquote><p>1、指定数值获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(1,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格中非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C10,F10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C10:C12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C8,C10,C12,F4:F12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7、非空计数函数COUNTA"><a href="#7、非空计数函数COUNTA" class="headerlink" title="7、非空计数函数COUNTA()"></a>7、非空计数函数COUNTA()</h3><blockquote><p>统计区域内包含文本和逻辑值的单元格个数。</p><p>注意counta函数与count函数的区别。</p><p>Count函数只统计区域内包含数字的单元格个数。</p></blockquote><p>1、指定多个范围单元格获取非空数据的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNTA(E4:E7,C2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8、四舍五入函数ROUND"><a href="#8、四舍五入函数ROUND" class="headerlink" title="8、四舍五入函数ROUND()"></a>8、四舍五入函数ROUND()</h3><blockquote><p>对数值进行四舍五入</p></blockquote><p>ROUND函数语法格式：</p><blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">ROUND(number, num_digits)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中</p><p>number表示需要进行四舍五入的数值或单元格内容。</p><p>num_digits表示需要取多少位的参数。</p><p>num_digits&gt;0时，表示取小数点后对应位数的四舍五入数值。</p><p>num_digits=0时，表示则将数字四舍五入到最接近的整数。</p><p>num_digits&lt; 0时，表示对小数点左侧前几位进行四舍五入。</p></blockquote><p>1、对指定单元格进行四舍五入</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=ROUND(E7,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK"><a href="#9、排名次函数RANK" class="headerlink" title="9、排名次函数RANK()"></a>9、排名次函数RANK()</h3><blockquote><p>返回一列数字的数字排位。 数字的排位是相对于列表中的其他值的大小。</p></blockquote><p>语法：RANK(number,ref,[order])</p><blockquote><p>RANK 函数语法具有下列参数：</p><ul><li><p><strong>Number</strong>   必需。 要找到其排位的数字。</p></li><li><p><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</p></li><li><p><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</p><p>如果 order 为 0（零）或省略，Microsoft Excel 对数字的排位是基于 ref 为按照降序排列的列表。</p><p>如果 order 不为零，Microsoft Excel 对数字的排位是基于 ref 为按照升序排列的列表。</p></li></ul></blockquote><p>1、获取指定单元格在范围内进行排名</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK(C3,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK-EQ"><a href="#9、排名次函数RANK-EQ" class="headerlink" title="9、排名次函数RANK.EQ()"></a>9、排名次函数RANK.EQ()</h3><p><code>与RANK函数用法一致</code></p><blockquote><p>返回一列数字的数字排位。 其大小与列表中其他值相关；如果多个值具有相同的排位，则返回该组值的最高排位。</p><p>如果要对列表进行排序，则数字排位可作为其位置。</p></blockquote><p>语法</p><blockquote><p>RANK.EQ(number,ref,[order])</p><p>RANK.EQ 函数语法具有下列参数：</p><ul><li><strong>Number</strong>   必需。 要找到其排位的数字。</li><li><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</li><li><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</li></ul><p>【注意】</p><ul><li>如果 Order 为 0（零）或省略，Excel 对数字的排位是基于 Ref 为按降序排列的列表。</li><li>如果 Order 不为零， Excel 对数字的排位是基于 Ref 为按照升序排列的列表。</li></ul></blockquote><p>1、升序排名</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK.EQ(C3,C2:C11,1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、降序排名(0可以省略)</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK.EQ(C3,C2:C11,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10、取整函数INT"><a href="#10、取整函数INT" class="headerlink" title="10、取整函数INT()"></a>10、取整函数INT()</h3><blockquote><p>将数字向下舍入到最接近的整数。</p></blockquote><p>1、对指定单元格进行取整，忽略小数位</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=INT(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11、求字符串长度函数LEN"><a href="#11、求字符串长度函数LEN" class="headerlink" title="11、求字符串长度函数LEN()"></a>11、求字符串长度函数LEN()</h3><blockquote><p>返回文本字符串中的字符个数</p><p>【注意】数字，字符，汉字都属于一个字符，包括小数点</p></blockquote><p>1、对指定单元格获取长度</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEN(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12、左取字符串函数LEFT"><a href="#12、左取字符串函数LEFT" class="headerlink" title="12、左取字符串函数LEFT()"></a>12、左取字符串函数LEFT()</h3><blockquote><p>从文本字符串的第一个字符开始返回指定个数的字符</p></blockquote><p>语法</p><blockquote><p>LEFT(text, [num_chars])</p><p>该函数语法具有下列参数：</p><ul><li><strong>Text</strong>  必需。 包含要提取的字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定要由 LEFT 提取的字符的数量。<ul><li>num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 LEFT 返回全部文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></li></ul></blockquote><p>1、获取指定单元格从左开始的第一个字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEFT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEFT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13、右取字符串函数RIGHT"><a href="#13、右取字符串函数RIGHT" class="headerlink" title="13、右取字符串函数RIGHT()"></a>13、右取字符串函数RIGHT()</h3><blockquote><p>根据所指定的字符数返回文本字符串中最后一个或多个字符</p></blockquote><p>语法</p><blockquote><p>RIGHT(text,[num_chars])</p><p>RIGHT  函数具有下列参数：</p><ul><li><strong>文本</strong>  必需。 包含要提取字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定希望 RIGHT 提取的字符数。</li><li>Num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 RIGHT 返回所有文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></blockquote><p>1、获取指定单元格从右开始的第一个字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RIGHT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RIGHT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="14、日函数DAY"><a href="#14、日函数DAY" class="headerlink" title="14、日函数DAY()"></a>14、日函数DAY()</h3><blockquote><p>返回以序列数表示的某日期的天数。 天数是介于 1 到 31 之间的整数。</p></blockquote><p>语法</p><blockquote><p>DAY(serial_number)</p><p>DAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f" target="_blank" rel="noopener">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=DAY(A2)</td><td>单元格 A2 (15) 中日期的天数</td><td>15</td></tr></tbody></table></div><h3 id="15、月函数MONTH"><a href="#15、月函数MONTH" class="headerlink" title="15、月函数MONTH()"></a>15、月函数MONTH()</h3><blockquote><p>返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。</p></blockquote><p>语法</p><blockquote><p>MONTH(serial_number)</p><p>MONTH 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的月份的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f" target="_blank" rel="noopener">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>说明</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=MONTH(A2)</td><td>单元格 A2 中日期的月份</td><td>4</td></tr></tbody></table></div><h3 id="16、年函数YEAR"><a href="#16、年函数YEAR" class="headerlink" title="16、年函数YEAR()"></a>16、年函数YEAR()</h3><blockquote><p>返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。</p></blockquote><p>语法</p><blockquote><p>YEAR(serial_number)</p><p>YEAR 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 要查找的年份的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td>2008-7-5</td><td></td><td></td></tr><tr><td>2010-7-5</td><td></td><td></td></tr><tr><td><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td>=YEAR(A3)</td><td>单元格 A3 中日期的年份 (2008)</td><td>2008</td></tr><tr><td>=YEAR(A4)</td><td>单元格 A4 中日期的年份 (2010)</td><td>2010</td></tr></tbody></table></div><h3 id="17、星期函数WEEKDAY"><a href="#17、星期函数WEEKDAY" class="headerlink" title="17、星期函数WEEKDAY()"></a>17、星期函数WEEKDAY()</h3><blockquote><p>返回对应于某个日期的一周中的第几天。 默认情况下，天数是 1（星期日）到 7（星期六）范围内的整数。</p></blockquote><p>语法</p><blockquote><p>WEEKDAY(serial_number,[return_type])</p><p>WEEKDAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 一个序列号，代表尝试查找的那一天的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li><li><strong>Return_type</strong>  可选。 用于确定返回值类型的数字。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Return_type</strong></th><th style="text-align:left"><strong>返回的数字</strong></th></tr></thead><tbody><tr><td style="text-align:left">1 或省略</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。 同 Microsoft Excel 早期版本。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">数字 0（星期一）到 6（星期日）。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">数字 1（星期二）到数字 7（星期一）。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">数字 1（星期三）到数字 7（星期二）。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">数字 1（星期四）到数字 7（星期三）。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">数字 1（星期五）到数字 7（星期四）。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">数字 1（星期六）到数字 7（星期五）。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。</td></tr></tbody></table></div></blockquote><p>备注</p><blockquote><ul><li>Microsoft Excel 可将日期存储为可用于计算的序列号。 默认情况下，1900 年 1 月 1 日的序列号是 1，而 2008 年 1 月 1 日的序列号是 39448，这是因为它距 1900 年 1 月 1 日有 39448 天。</li><li>如果当前日期基值的 serial_number 超出范围，则 #NUM！ 返回错误。</li><li>如果 return_type 超出了上表中指定的范围，则 #NUM！ 返回错误。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>数据</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2008-2-14</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=WEEKDAY(A2)</td><td>使用数字 1（星期日）到 7（星期六）表示的一周中的第几天 (5)</td><td>5</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 2)</td><td>使用数字 1（星期一）到 7（星期日）表示的一周中的第几天 (4)</td><td>4</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 3)</td><td>使用数字 0（星期一）到 6（星期日）表示的一周中的第几天 (3)</td><td>3</td></tr></tbody></table></div><h3 id="18、日期函数-DATE"><a href="#18、日期函数-DATE" class="headerlink" title="18、日期函数 DATE()"></a>18、日期函数 DATE()</h3><blockquote><p>返回表示特定日期的连续序列号。</p></blockquote><p>语法：</p><blockquote><p>DATE(year,month,day)</p><p>DATE 函数语法具有下列参数：</p><ul><li><strong>Year</strong>  ：必需。<strong><em>year\</em></strong> 参数的值可以包含一到四位数字。Excel 将根据计算机正在使用的日期系统来解释 <strong><em>year\</em></strong> 参数。默认情况下，Microsoft Excel for Windows 使用的是 1900 日期系统，这表示第一个日期为 1900 年 1 月 1 日。</li></ul><p><strong>提示:</strong> 为避免出现意外结果，请对 <strong><em>year\</em></strong> 参数使用四位数字。例如，“07”可能意味着“1907”或“2007”。因此，使用四位数的年份可避免混淆。</p><ul><li>如果 <strong><em>year\</em></strong> 介于 0（零）到 1899 之间（包含这两个值），则 Excel 会将该值与 1900 相加来计算年份。例如，DATE(108,1,2) 返回 2008 年 1 月 2 日 (1900+108)。</li><li>如果 <strong><em>year\</em></strong> 介于 1900 到 9999 之间（包含这两个值），则 Excel 将使用该数值作为年份。例如，DATE(2008,1,2) 将返回 2008 年 1 月 2 日。</li><li><p>如果 <strong><em>year\</em></strong> 小于 0 或大于等于 10000，则 Excel 返回 错误值 #NUM!。</p></li><li><p><strong>Month</strong>  必需。一个正整数或负整数，表示一年中从 1 月至 12 月（一月到十二月）的各个月。</p></li><li><p>如果 <strong><em>month\</em></strong> 大于 12，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始加上该月份数。例如，DATE(2008,14,2) 返回表示 2009 年 2 月 2 日的序列数。</p></li><li><p>如果 <strong><em>month\</em></strong> 小于 1，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始减去该月份数，然后再加上 1 个月。例如，DATE(2008,-3,2) 返回表示 2007 年 9 月 2 日的序列号。</p></li><li><p><strong>Day</strong>  必需。一个正整数或负整数，表示一月中从 1 日到 31 日的各天。</p></li><li><p>如果 <strong><em>day\</em></strong> 大于指定月中的天数，则 <strong><em>day\</em></strong> 会从该月的第一天开始加上该天数。例如，DATE(2008,1,35) 返回表示 2008 年 2 月 4 日的序列数。</p></li><li>如果 <strong><em>day\</em></strong> 小于 1，则 <strong><em>day\</em></strong> 从指定月份的第一天开始减去该天数，然后再加上 1 天。例如，DATE(2008,1,-15) 返回表示 2007 年 12 月 16 日的序列号。</li></ul><p><strong>注意:</strong> Excel 可将日期存储为连续序列号，以便能在计算中使用它们。1900 年 1 月 1 日的序列号为 1，2008 年 1 月 1 日的序列号为 39448，这是因为它与 1900 年 1 月 1 日之间相差 39,447 天。需要更改数字格式（设置单元格格式）以显示正确的日期。</p></blockquote><p>用法</p><p><strong>=DATE(C2,A2,B2)</strong> 将单元格 C2 中的年、单元格 A2 中的月以及单元格 B2 中的日合并在一起，并将它们放入一个单元格内作为日期。</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=DATE(C2,A2,B2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Excel函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的创建及使用</title>
      <link href="posts/51549.html"/>
      <url>posts/51549.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>第一步肯定是创建数据库了.看下图操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224153.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224722.png" alt=""></p><p>先创建一个名字为 <font color='red'>company的数据库</font> 输入以下内容然后全选右键运行，如图（最好先保存防止下次找不到上次所写内容）</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224844.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104225129.png" alt=""></p><p> 点击最下方的刷新</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091503.png" alt=""></p><p>然后自己所创建的数据库就出来了，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091636.png" alt=""></p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>以下为添加数据的内容，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105092334.png" alt=""></p><p>选中添加内容，运行，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101502.png" alt=""></p><h2 id="查询emp表"><a href="#查询emp表" class="headerlink" title="查询emp表"></a>查询emp表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101742.png" alt=""></p><h2 id="修改表内容"><a href="#修改表内容" class="headerlink" title="修改表内容"></a>修改表内容</h2><h3 id="注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样"><a href="#注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样" class="headerlink" title="注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样"></a>注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101854.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102729.png" alt=""></p><h2 id="删除表内容"><a href="#删除表内容" class="headerlink" title="删除表内容"></a>删除表内容</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101935.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103100.png" alt=""></p><h2 id="更改表名"><a href="#更改表名" class="headerlink" title="更改表名"></a>更改表名</h2><h3 id="运行后到最左方右键，点击刷新就可看到更改的表名"><a href="#运行后到最左方右键，点击刷新就可看到更改的表名" class="headerlink" title="运行后到最左方右键，点击刷新就可看到更改的表名"></a>运行后到最左方右键，点击刷新就可看到更改的表名</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102030.png" alt=""></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103458.png" alt=""></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105030.png" alt=""></p><h2 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102148.png" alt="image-20201105102145614"></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105239.png" alt="image-20201105105238598"></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105500.png" alt="image-20201105105459408"></p><h2 id="添加列及删除列"><a href="#添加列及删除列" class="headerlink" title="添加列及删除列"></a>添加列及删除列</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102228.png" alt="image-20201105102227470"></p><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105635.png" alt="image-20201105105632391"></p><p>删除列</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105726.png" alt="image-20201105105725397"></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110012.png" alt="image-20201105110011837"></p><h2 id="创建新表添加新内容"><a href="#创建新表添加新内容" class="headerlink" title="创建新表添加新内容"></a>创建新表添加新内容</h2><p>注意：逐条运行   出现如下图最下方受影响及时间为运行成功！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110906.png" alt="image-20201105110904752"></p><p>运行结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105111129.png" alt="image-20201105111128007"></p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">#创建数据库create database company charset=utf8;use company;create table emp(    eid int primary key,    ename varchar(20),    eage int,    esex varchar(5),  joindate date) charset=utf8;#添加数据insert into emp(eid,ename,eage,esex,joindate)     value(1,'张三',18,'男','2019-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(2,'李四',19,'男','2018-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(3,'王五',17,'女','2017-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(4,'赵六',20,'男','2020-09-05');#查询emp表select eid,ename,eage,esex,joindate from emp;select eid,ename,eage from emp;select * from emp;#把eid等于4的记录的ename的值改为赵若男update emp set ename='赵若男',esex='女' where eid=4;#删除eid等于3的数据delete from emp where eid=3;#更改表结构#把表名改为employalter table emp rename employ;select * from employ;#把字段名esex改为egenderalter table employ change esex egender varchar(5);#添加etel列alter table employ add etel varchar(17); #删除etel列alter table employ drop etel;#删除employ表drop table employ;drop table emp;use company;create table emp(    eid int primary key,    ename varchar(20) not null,    esex  enum('男','女') default '男',    etel varchar(17)  not null unique)insert into emp(eid,ename,esex,etel) value(1,'张三','男','18530900286');insert into emp(eid,ename,esex,etel) value(2,'张三','女','18530900287');insert into emp(eid,ename,etel) value(3,'赵四','18530900288');insert into emp(eid,ename,etel) value(4,'赵三','18530900289');insert into emp(eid,ename,etel) value(5,'赵五','18530900290');insert into emp(eid,ename,etel) value(6,'赵六','18530900277');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql"># 删除某表delete from 表名;# truncate table 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的安装</title>
      <link href="posts/24482.html"/>
      <url>posts/24482.html</url>
      
        <content type="html"><![CDATA[<p>想学MySQL首先要学会安装，安装包如下：</p><p><a href="https://share.weiyun.com/NvbChzFu" target="_blank" rel="noopener">传送门</a></p><h2 id="一、-什么是数据库"><a href="#一、-什么是数据库" class="headerlink" title="一、 什么是数据库"></a>一、 什么是数据库</h2><p>数据库是用来存储数据的仓库，互联的数据中心(idc ),绝大部分数据是通过数据库存储的。</p><h2 id="二、-数据库的种类"><a href="#二、-数据库的种类" class="headerlink" title="二、 数据库的种类"></a>二、 数据库的种类</h2><p>数据库有两大类：第一类是关系型数据库，第二类非关系型数据库</p><p>关系型数据库：mysql、oracle、sql server、mariadb</p><p>非关系型数据库：redis </p><h2 id="三、-数据库的安装"><a href="#三、-数据库的安装" class="headerlink" title="三、 数据库的安装"></a>三、 数据库的安装</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124903.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124926.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124936.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124958.png" alt=""></p><p>点击finish安装完成，开始对mysql进行配置</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125028.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125037.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125053.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125109.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125124.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125139.png" alt=""></p><p>这一步是调整允许数据库最大并发连接数</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125203.png" alt=""></p><p>这一步是设置mysql的端口号，默认是3306</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125219.png" alt=""></p><p>这一步是设置数据库的编码格式，改为了utf-8</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125236.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125246.png" alt=""></p><p>这一步设置数据库的密码，要输入两次一样的密码，不要设置过于复杂的密码</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125304.png" alt=""></p><p>四个对号安装成功，并且启动成功</p><h2 id="四、mysql服务器与客户端"><a href="#四、mysql服务器与客户端" class="headerlink" title="四、mysql服务器与客户端"></a>四、mysql服务器与客户端</h2><p>​    以上的过程安装的是mysql服务器。如果想对mysql服务器进行操作，还需要安装客户端连接上mysql服务器。比较常用的客户端有navicat、sql yog.</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125348.png" alt=""></p><h2 id="五、mysql数据库的名词解释"><a href="#五、mysql数据库的名词解释" class="headerlink" title="五、mysql数据库的名词解释"></a><strong>五、mysql数据库的名词解释</strong></h2><h3 id="数据库与数据表"><a href="#数据库与数据表" class="headerlink" title="数据库与数据表"></a>数据库与数据表</h3><p>​    数据库不直接存放数据，而先把数据存放到一张张数据表里，然后再把表放到数据库里。一个数据库里表都是相互有关系的。</p><h3 id="数据表的字段属性、记录"><a href="#数据表的字段属性、记录" class="headerlink" title="数据表的字段属性、记录"></a><strong>数据表的字段属性、记录</strong></h3><p> 数据表的列称为字段或属性，数据表的行称为记录。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a><strong>实体</strong></h3><p> 实体就是客观存在并可以相互区别的事物。表就是用来记录实体的信息的。</p><h2 id="六、创建数据库"><a href="#六、创建数据库" class="headerlink" title="六、创建数据库"></a>六、创建数据库</h2><p>​    Mysql服务器上默认有三个数据库，其中mysql数据库里边存储着用户信息等重要内容。当然也可以自己创建数据库。</p><h2 id="七、mysql数据库的数据类型"><a href="#七、mysql数据库的数据类型" class="headerlink" title="七、mysql数据库的数据类型"></a><strong>七、mysql数据库的数据类型</strong></h2><p>  <strong>整型：</strong> int</p><p>  <strong>浮点型</strong>： float(默认有七位小数)  double(默认有15位小数)  decimal(P,S) S是保留的小数位数，P数值的长度</p><p>  <strong>字符型：</strong>char(固定长度的类型) varchar(可变长度的类型)  text</p><p>​        固定长度和可变长度的区别：以char(20) varchar(20)为例。Char(20)不管存储内容长度是几个字节，都占内存的20个字节。Varchar(20) 存储的内容长度是几个字节，就占内存的几个字节。</p><p>  <strong>日期时间：</strong></p><p>​    日期： date（YYYY-MM-DD）</p><p>​    时间： time (HH:MM:SS)</p><p>​    日期时间：datetime (YYYY-MM-DD HH:MM:SS)</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github图床搭建</title>
      <link href="posts/53653.html"/>
      <url>posts/53653.html</url>
      
        <content type="html"><![CDATA[<p>由于平时在写markdown文档时会引用很多的图片，但是图片是不可以直接粘贴上去的，所以我一般都要把图片放在一个文件夹里面，再导入图片。这样做比较繁琐，而且还存在如果我修改了路径，图片就不显示的问题。<br> 于是就发现了这个神器——<strong>PicGo</strong></p><h3 id="1、先下载个PicGo，如下"><a href="#1、先下载个PicGo，如下" class="headerlink" title="1、先下载个PicGo，如下"></a>1、先下载个PicGo，如下</h3><p><a href="https://share.weiyun.com/mSUFa7MN" target="_blank" rel="noopener">传送门</a></p><h3 id="2-安装软件，打开软件，图床设置"><a href="#2-安装软件，打开软件，图床设置" class="headerlink" title="2 安装软件，打开软件，图床设置"></a>2 安装软件，打开软件，图床设置</h3><pre class="line-numbers language-lang-json"><code class="language-lang-json">{  "repo": "", // 仓库名，格式是username/reponame  "token": "", // github token  "path": "", // 自定义存储路径，比如img/  "customUrl": "", // 自定义域名，注意要加http://或者https://  "branch": "" // 分支名，默认是master}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-首先你得有一个GitHub账号。注册GitHub就不用我多言。"><a href="#1-首先你得有一个GitHub账号。注册GitHub就不用我多言。" class="headerlink" title="1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。"></a><strong>1.</strong> 首先你得有一个GitHub账号。注册GitHub就不用我多言。</h4><h4 id="2-新建一个仓库"><a href="#2-新建一个仓库" class="headerlink" title="2. 新建一个仓库"></a><strong>2.</strong> 新建一个仓库</h4><p>记下你取的仓库名。</p><p>如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031123905.png" alt="1"></p><h4 id="3-生成一个token用于PicGo操作你的仓库："><a href="#3-生成一个token用于PicGo操作你的仓库：" class="headerlink" title="3. 生成一个token用于PicGo操作你的仓库："></a><strong>3.</strong> 生成一个token用于PicGo操作你的仓库：</h4><p>访问：<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><h4 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4. 配置PicGo"></a><strong>4.</strong> 配置PicGo</h4><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>  中间不能出现空格，比如我创建了一个叫做Picture的仓库，在PicGo里我要设定的仓库名就是<code>wind-qin/Picture</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031124250.png" alt="图床1"></p><h4 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="5. 配置Typora"></a><strong>5.</strong> 配置Typora</h4><p>然后点击Typora左上角文件     偏好设置 点击图像</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120628.png" alt="image-20201106120619756"></p><p>点击验证图片上传选项为true则配置正确</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120714.png" alt="image-20201106120711559"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p>如想了解其他图床的安装请前往：</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" target="_blank" rel="noopener">https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A</a></p>]]></content>
      
      
      <categories>
          
          <category> github图床搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora写法</title>
      <link href="posts/28493.html"/>
      <url>posts/28493.html</url>
      
        <content type="html"><![CDATA[<h1 id="Typora的下载"><a href="#Typora的下载" class="headerlink" title="Typora的下载"></a>Typora的下载</h1><p><a href="https://share.weiyun.com/QOIBRwsr" target="_blank" rel="noopener">下载</a></p><h1 id="Typora的写法"><a href="#Typora的写法" class="headerlink" title="Typora的写法"></a>Typora的写法</h1><h3 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h3><h4 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h4><p># 一阶标题 或者快捷键Ctrl+1</p><p>##二阶标题 或者快捷键Ctrl+2</p><p>###三阶标题 或者快捷键Ctrl+3</p><p>####四阶标题 或者快捷键Ctrl+4</p><p>#####五阶标题 或者快捷键Ctrl+5</p><p>######六阶标题 或者快捷键Ctrl+6</p><h4 id="标题Typora显示形式是"><a href="#标题Typora显示形式是" class="headerlink" title="标题Typora显示形式是"></a>标题Typora显示形式是</h4><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图01.png" alt=""></p><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><h4 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h4><pre><code>&lt;center&gt;这是要居中的文本内容&lt;/center&gt;</code></pre><h4 id="文本居中显示形式是"><a href="#文本居中显示形式是" class="headerlink" title="文本居中显示形式是"></a>文本居中显示形式是</h4><p><center>这是要居中的文本内容</center><br>注：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。 </p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><h4 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h4><pre><code> &lt;u&gt;下划线的内容&lt;u&gt;</code></pre><p>或者快捷键Ctrl+U</p><h4 id="下划线在Typora显示形式是"><a href="#下划线在Typora显示形式是" class="headerlink" title="下划线在Typora显示形式是"></a>下划线在Typora显示形式是</h4><p> <u>这就是我亲测的下划线</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>删除线使用格式</p><pre><code>~~删除线的内容~~</code></pre><h4 id="删除线在Typora显示形式是"><a href="#删除线在Typora显示形式是" class="headerlink" title="删除线在Typora显示形式是"></a>删除线在Typora显示形式是</h4><p><del>这是删除线的内容</del></p><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><h4 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h4><pre><code> **加粗字体**</code></pre><p> 或者快捷键Ctrl+B </p><h4 id="字体加粗在Typora显示形式是"><a href="#字体加粗在Typora显示形式是" class="headerlink" title="字体加粗在Typora显示形式是"></a>字体加粗在Typora显示形式是</h4><p><strong>加粗字体 This is a bold font</strong></p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><h4 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h4><pre><code>*字体倾斜了*</code></pre><p> 或者快捷键Ctrl+I </p><h4 id="字体倾斜在Typora的显示形式"><a href="#字体倾斜在Typora的显示形式" class="headerlink" title="字体倾斜在Typora的显示形式"></a>字体倾斜在Typora的显示形式</h4><p> <em>字体倾斜了 This is a alanted font</em> </p><h3 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h3><p> 最简单粗暴的图片插入方式如图 :</p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图05.gif" alt=""></p><h3 id="视频的插入"><a href="#视频的插入" class="headerlink" title="视频的插入"></a>视频的插入</h3><p>方法一：</p><pre><code>&lt;video src=&quot;地址&quot;&gt;&lt;/video&gt;</code></pre><p>方法二：</p><pre><code>&lt;/iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot;&gt;</code></pre><p>注意：方法一可如插入图片般直接拉入，方法二由于插入视频后在博客中会将视频以下内容顶掉，在此将不再添加，如有兴趣可在Typora中添加尝试</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h4><p>第一种：<a href="http://www.simba.com" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：快捷键Ctrl+K</p><pre><code> [自定义内容](超链接地址) 例如：[百度一下](www.baidu.com)</code></pre><h4 id="超链接在Typora显示形式是：（必须以http开头）"><a href="#超链接在Typora显示形式是：（必须以http开头）" class="headerlink" title="超链接在Typora显示形式是：（必须以http开头）"></a>超链接在Typora显示形式是：（必须以http开头）</h4><p>第一种：<a href="http://www.simba.com" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：<a href="https://blog.csdn.net/SIMBA1949/article/details/www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><p>按住Ctrl键+点击上面链接就可以直接访问该链接</p><h3 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h3><p> Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。 </p><h4 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h4><pre><code>` ` `+编程语言：例如java代码：` ` `java</code></pre><p>在代码块的右下角写所用的编程语言</p><h4 id="代码区域在typora中显示形式"><a href="#代码区域在typora中显示形式" class="headerlink" title="代码区域在typora中显示形式"></a>代码区域在typora中显示形式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class simba{  public static void main(String[] args){    System.out.println("梦回大唐");  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h3><h4 id="表格的二种使用格式"><a href="#表格的二种使用格式" class="headerlink" title="表格的二种使用格式"></a>表格的二种使用格式</h4><p> 第一种：快捷键<strong>Ctrl+T</strong>，会自动跳出设置行和列的设置框，如下图 </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图06.jpg" alt=""></p><p>第二种：</p><p>|国籍|省份|市区|</p><h3 id="表格在typora中显示形式"><a href="#表格在typora中显示形式" class="headerlink" title="表格在typora中显示形式"></a>表格在typora中显示形式</h3><p>第一种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>李太白</td><td>123456</td></tr></tbody></table></div><p>第二种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><p>右键  如图：</p><p> <img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图07.png" alt=""></p><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li><p>[x] JAVA</p></li><li><p>[x]  C</p></li><li><p>[ ]  C++</p></li><li><p>[ ]  Python</p><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图08.png" alt=""></p></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h4><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</p><h4 id="列表在typora中的显示形式"><a href="#列表在typora中的显示形式" class="headerlink" title="列表在typora中的显示形式"></a>列表在typora中的显示形式</h4><ul><li>java</li><li>C</li><li>C++</li><li>Python</li></ul><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><h4 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h4><p><em>*</em>或者- - -</p><h4 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h4><hr><hr><p> 注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图03.png" alt=""></p><h3 id="改变字体的颜色"><a href="#改变字体的颜色" class="headerlink" title="改变字体的颜色"></a>改变字体的颜色</h3><h4 id="改变颜色的格式"><a href="#改变颜色的格式" class="headerlink" title="改变颜色的格式"></a>改变颜色的格式</h4><pre><code>&lt;font color=&#39;red&#39;&gt;改变字体的颜色&lt;/font&gt;</code></pre><h4 id="字体在typora中显示形式"><a href="#字体在typora中显示形式" class="headerlink" title="字体在typora中显示形式"></a>字体在typora中显示形式</h4><font color='red'>改变字体的颜色</font><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="注释的格式"><a href="#注释的格式" class="headerlink" title="注释的格式"></a>注释的格式</h4><pre><code>&lt;!--才能够显示--&gt;</code></pre><p>注意：注释后Typora中显示注释的内容，但展示页面中不显示</p><h3 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table></div><p>注：一些实体符号需要在实体符号之前加””</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>甫子寸诗集</title>
      <link href="posts/36937.html"/>
      <url>posts/36937.html</url>
      
        <content type="html"><![CDATA[<p>在此处甫子寸的诗纯个人喜欢的节选。</p><p>世间有些许荒唐，不如与我兴风作浪。</p><h3 id="《天经地义》"><a href="#《天经地义》" class="headerlink" title="《天经地义》"></a>《天经地义》</h3><p>知道吗，</p><p>这世间有很多事</p><p>是不用讲道理的，</p><p>就像我喜欢你，</p><p>不用落笔，</p><p>天经地义.</p><p>​                     —————甫子寸诗歌《天经地义》</p><h3 id="《东坡先生》"><a href="#《东坡先生》" class="headerlink" title="《东坡先生》"></a>《东坡先生》</h3><p> 大宋的明月照耀了千里，<br>却唯独照不到你。<br>你说沙洲寂寥，<br>倒也好过寒枝凄栖。<br>只寻常的入京赴考，<br>一纸策论便横空临世，<br>许是锋芒太盛？<br>竟令那山水醉翁也自叹弗如？</p><p>天才与伟人只差一个悲剧，<br>那权倾朝野的政敌沉迷变法，<br>乌台狂风起于你自由的豪尖，<br>向来墙倒众人推，<br>书生杀人不见血。<br>虎落平阳本就有趣，<br>落井下石是否更大快人心？！</p><p>自京师一贬直下到黄州，<br>耕垦隔绝新党的冷笑，<br>吹散天朝的遗风，<br>给大宋的文坛拆了细看，<br>竟再出不得如此人物，<br>上下五千年的洒脱，<br>败给谁的竹杖芒鞋。<br>把酒问天上宫阙，<br>抬眸见阴晴圆缺，<br>仙心欲归琼楼，<br>落笔却是那烟火人间。</p><p>大江东去，<br>你也随之东去，<br>雄姿英发，谈笑赤壁，<br>究竟是周郎还是你东坡居士？<br>擦去这些年的斜风细雨，<br>仍旧说着诗酒年华忘却鬓角的银发。<br>生平一点浩然气，<br>十年生死别亡妻，<br>门前的流水当真能西行？<br>如今恍惚相遇的互望无言，<br>不过又是一个明月照进松林的夜。 </p><p>​                     —————甫子寸《东坡先生》</p><h3 id="《乡愁其四》"><a href="#《乡愁其四》" class="headerlink" title="《乡愁其四》"></a>《乡愁其四》</h3><p>我问我外公什么是乡愁，</p><p>外公没有说话，</p><p>他在眼中，</p><p>藏入一坛浊酒.</p><p>​                        —————甫子寸《乡愁其四》</p><h3 id="《沉沦》"><a href="#《沉沦》" class="headerlink" title="《沉沦》"></a>《沉沦》</h3><p>你是我今后岁月难舍难分，</p><p>也是我荒凉宇宙明月星辰。</p><p>我爱你冰冷美艳凶险万分，</p><p>也爱你一笑嫣然撩我心魂。</p><p>题得出最美的诗文，</p><p>写不来你清透眼神。</p><p>你微微蹙眉，</p><p>使万物皆醺，英雄饮恨。</p><p>我轻轻一笑，</p><p>道茶还未凉，尚留余温。</p><p>一抹红唇，乱了方寸。</p><p>眉间一吻，我愿沉沦。</p><p>​                        —————甫子寸《沉沦》</p><h3 id="《钓鱼人》"><a href="#《钓鱼人》" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>这一生只想纵横，</p><p>谁又管身后的风？</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《钓鱼人》-1"><a href="#《钓鱼人》-1" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>你不懂我的梦，</p><p>便不知我热冷</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《诗歌之路在何方》"><a href="#《诗歌之路在何方》" class="headerlink" title="《诗歌之路在何方》"></a>《诗歌之路在何方》</h3><p> 舀下一瓢星光，</p><p>浇灌我的豪肠.</p><p>​                        —————甫子寸《诗歌之路在何方》节选</p><h3 id="《说与浮云听》"><a href="#《说与浮云听》" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>在最失意时纵马，</p><p>在最得意处品茶.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《说与浮云听》-1"><a href="#《说与浮云听》-1" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>一生很长，几度春夏?<br>纸张太短，无边风雅.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《随笔》"><a href="#《随笔》" class="headerlink" title="《随笔》"></a>《随笔》</h3><p>少年向来不识天高地厚，</p><p>放眼处皆自负才高八斗.</p><p>虽是自命风流，</p><p>倒也坦诚无忧.</p><p>我爱这样的少年，</p><p>谦和而狂妄，</p><p>骄傲又坦然.</p><p>​                        —————甫子寸《随笔》</p><h3 id="《月下随笔》"><a href="#《月下随笔》" class="headerlink" title="《月下随笔》"></a>《月下随笔》</h3><p>我是此间少年郎，</p><p>你是天上明月光</p><p>​                        —————甫子寸《月下随笔》节选</p><h3 id="《诗人》"><a href="#《诗人》" class="headerlink" title="《诗人》"></a>《诗人》</h3><p>我说诗人啊，</p><p>做自己的将军，</p><p>在自己的世界里统率三军.</p><p>​                        —————甫子寸《诗人》节选</p><h3 id="《诗心》"><a href="#《诗心》" class="headerlink" title="《诗心》"></a>《诗心》</h3><p>忙过了最近的忙，</p><p>醒来已是华灯初上，</p><p>太阳无缘见我，能作陪的只剩月光.</p><p>​                        —————甫子寸《诗心》节选</p><h3 id="《最绝伦的笔墨》"><a href="#《最绝伦的笔墨》" class="headerlink" title="《最绝伦的笔墨》"></a>《最绝伦的笔墨》</h3><p>你是我最绝伦的笔墨，</p><p>也是我诗里最美的传说.</p><p>​                        —————甫子寸《最绝伦的笔墨》节选</p><h3 id="《无题》"><a href="#《无题》" class="headerlink" title="《无题》"></a>《无题》</h3><p>龙有逆鳞不可触，</p><p>人无傲气不可交。</p><p>​                        —————甫子寸《无题》节选</p><h3 id="《劫》"><a href="#《劫》" class="headerlink" title="《劫》"></a>《劫》</h3><p>我于昨晚霸占了所有的月光，<br>等天亮却只想给一人写文章.</p><p>​                        —————甫子寸《劫》节选</p><h3 id="《只是想你》"><a href="#《只是想你》" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>这世间众生皆孤寂，<br>应怪众生未见过你。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《只是想你》-1"><a href="#《只是想你》-1" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>我扛得住所有白天的泪，</p><p>却熬不住漫漫长夜的黑。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《不想》"><a href="#《不想》" class="headerlink" title="《不想》"></a>《不想》</h3><p>我其实一点也不想念，<br>和月色也能相谈甚欢</p><p>​                        —————甫子寸《不想》节选</p><h3 id="《陷半生》"><a href="#《陷半生》" class="headerlink" title="《陷半生》"></a>《陷半生》</h3><p>误把眉目作山河，</p><p>沦陷半生未肯脱。</p><p>​                        —————甫子寸《陷半生》节选</p><h3 id="《野望》"><a href="#《野望》" class="headerlink" title="《野望》"></a>《野望》</h3><p>野心总是在深夜开始酝酿，</p><p>等天亮又黯然收场.</p><p>​                        —————甫子寸《野望》节选</p><h3 id="《格局》"><a href="#《格局》" class="headerlink" title="《格局》"></a>《格局》</h3><p>书生口中三寸兵，</p><p>不斩小人斩不平.</p><p>​                        —————甫子寸《格局》节选</p><h3 id="《随笔·热爱》"><a href="#《随笔·热爱》" class="headerlink" title="《随笔·热爱》"></a>《随笔·热爱》</h3><p> 人生九分只顾开怀，<br>对世界宣泄年轻的爱。<br>留一分写诗感慨，<br>等老去为自己喝彩。<br>到那时你会不会期待，<br>我敛去一身桀骜，<br>淋着星光向你走来，<br>为你捧起世上最温柔的海。 </p><p>​                        —————甫子寸《随笔·热爱》节选</p><h3 id="《我想把余生都送你》"><a href="#《我想把余生都送你》" class="headerlink" title="《我想把余生都送你》"></a>《我想把余生都送你》</h3><p>总有那么一天啊，</p><p>我会向那个不屈的少年告别，</p><p>柴米油盐酱醋茶，</p><p>目睹青丝成白发，</p><p>我不再心怀天下，</p><p>却只想接你回家.</p><p>​                        —————甫子寸《我想把余生都送你》</p><h3 id="《此刻此间》"><a href="#《此刻此间》" class="headerlink" title="《此刻此间》"></a>《此刻此间》</h3><p>你如今回眸看我一眼，</p><p>满天风光尽收你眉间.</p><p>​                        —————甫子寸《此刻此间》节选</p><h3 id="《三寸情书》"><a href="#《三寸情书》" class="headerlink" title="《三寸情书》"></a>《三寸情书》</h3><p>我说，瀚海可尽，明月可鞠，</p><p>落不得太多字句，</p><p>只为你一生眉目清举。</p><p>​                        —————甫子寸《三寸情书》节选</p><h3 id="《青云》"><a href="#《青云》" class="headerlink" title="《青云》"></a>《青云》</h3><p>闻听书中游侠，并无轻剑快马，</p><p>只凭背井离乡，丈量山河天下。</p><p>​                        —————甫子寸《青云》节选</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 甫子寸诗集节选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="posts/9443.html"/>
      <url>posts/9443.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="为什么要使用方法"><a href="#为什么要使用方法" class="headerlink" title="为什么要使用方法"></a>为什么要使用方法</h3><h4 id="生活中的方法（工具）"><a href="#生活中的方法（工具）" class="headerlink" title="生活中的方法（工具）"></a>生活中的方法（工具）</h4><p>螺丝刀，锤子，扳手</p><blockquote><p>1、提高复用度，可重复使用</p><p>2、提高效率</p></blockquote><p>开发中使用方法来实现同样的效果，<a href="">为了解决复用和效率的问题</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><a href="">实现特定功能的一段代码，可以被反复使用</a></p><h3 id="方法的构成"><a href="#方法的构成" class="headerlink" title="方法的构成"></a>方法的构成</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">固定格式：    public static返回值类型：    表示方法执行完成后返回的数据类型    如果没有返回值类型就用 void ，如果有就使用对应的返回值类型方法名：    小驼峰命名，见名知意，动宾结构形参列表：    用来接收用户传入的数据，可以是基本数据类型或者引用数据类型，需要声明局部变量。    如果不需要形参就写 ()，如果有多个就写多个方法体：    {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><blockquote><p>1、固定的格式（public static）不要问，因为不影响我们写代码，后期会讲！！！</p><p>2、方法要写上文档注释，为了更方便地阅读代码</p></blockquote><h3 id="方法声明格式"><a href="#方法声明格式" class="headerlink" title="方法声明格式"></a>方法声明格式</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static returnType methodName(dataType FormerParameter) {    method body;}public static 返回值类型 方法名(数据类型 形参名) {    方法体;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明位置"><a href="#声明位置" class="headerlink" title="声明位置"></a>声明位置</h3><p><a href="">定义在类中，与其他方法（main方法）并列</a></p><h3 id="无返回值方法调用"><a href="#无返回值方法调用" class="headerlink" title="无返回值方法调用"></a>无返回值方法调用</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">mothodName(actualParameter);方法名(实参);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：</p><blockquote><p>方法和变量最大的区别就是方法后面有小括号，即便没有参数也有小括号</p><p>小驼峰</p></blockquote><h4 id="3-6-1-无参无返回值调用"><a href="#3-6-1-无参无返回值调用" class="headerlink" title="3.6.1 无参无返回值调用"></a>3.6.1 无参无返回值调用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod1 {    public static void main(String[] args) {        printHelloWorld();    }    /**    * 打印Hello World    */    public static void printHelloWorld() {        System.out.println("Hello World");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、main方法是程序的入口，所有的代码和方法都需要在main方法中被完成和调用2、方法名的后面一定要跟 ()3、方法和其他方法的关系是并列关系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-6-2-有参无返回值调用"><a href="#3-6-2-有参无返回值调用" class="headerlink" title="3.6.2 有参无返回值调用"></a>3.6.2 有参无返回值调用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.util.Scanner;class TestMethod3 {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        System.out.println("请输入一个数：");        int num = scanner.nextInt();        printIntNum(num);    }    /**    * 展示用户传入的int类型数据    *    * @param num 这里需要传入一个int类型的数据    */    public static void printIntNum(int num) {        System.out.println("您输入的数为：" + num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、如果方法声明时带有形式参数，那么方法调用时就必须携带实际参数2、如果方法声明时没有形式参数，方法调用时就不能有实参3、声明时有几个形式参数，调用时就传入几个实际参数，形参实参个数不一样编译会报错4、实参与形参的数据类型不一样，编译器会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><blockquote><p>形参：用来接收调用该方法时传递的参数。只有在被调用的时候才分配内存空间，一旦调用结束，就释放内存空间。因此仅仅在方法内有效。<br>实参：方法调用时用于传入的数据，用来给形参赋值，数据类型要求一致</p></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>方法中的返回值有两种情况，即有返回值和无返回值，如果定义方法时有返回值类型，就需要返回相对应的数据类型</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">基本数据类型    值传递，不改变自身引用数据类型    引用传递，改变自身void    无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、一个方法只能有一个返回值2、分支结构的每一个分支都需要正确的返回值3、返回值可以接收也可以不接收<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h4><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>结束当前方法，返回至调用方法处，如果定义了返回值类型就返回对应类型的数据</p><p>【注意】<a href="">数据类型一致化</a></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">return 需要返回的数据;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、单一职能原则，一个方法只做一件事2、注意形参和实参数据类型一致化3、返回值类型和参数没有关系4、方法名要符合小驼峰命名规则5、return的下一行代码不会执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有返回值方法调用"><a href="#有返回值方法调用" class="headerlink" title="有返回值方法调用"></a>有返回值方法调用</h3><h4 id="无参有返回值的方法：give-me-five"><a href="#无参有返回值的方法：give-me-five" class="headerlink" title="无参有返回值的方法：give me five"></a>无参有返回值的方法：give me five</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod1 {    public static void main(String[] args) {        System.out.println(giveMeFive());    }    /**    * 返回一个整数 5    *    * @return 5 int类型    */    public static int giveMeFive() {        return 5;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="有参有返回值的方法：两个数求和"><a href="#有参有返回值的方法：两个数求和" class="headerlink" title="有参有返回值的方法：两个数求和"></a>有参有返回值的方法：两个数求和</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemo6 {    public static void main(String[] args) {        /*         * 调用自定义getSumOfTwoNumber方法，需要两个int类型的参数，并得到一个int类型的返回值         *          * 参数列表一定要和方法声明上的参数类型完全一致         */         int total = getSumOfTwoNumber(1, 2);        System.out.println(total);    }    /**     * 两个整数进行求和     *      * @param num1 求和的第一个数     * @param num2 求和的第二个数     * @return 返回两个参数的和，int类型     */    public static int getSumOfTwoNumber(int num1, int num2){        return num1 + num2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】调用带有多参数的方法，要求传入的参数数据类型，个数和顺序还有数据类型必须和方法声明一致</p><h4 id="规范化return"><a href="#规范化return" class="headerlink" title="规范化return"></a>规范化return</h4><p>在一个方法中，return出现的次数要尽可能得少，为了提高阅读性和逻辑性</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod4 {    public static void main(String[] args) {        System.out.println(getCompare(3,2));    }    /**    * 比较大小，返回较大的那个数    *    * @param num1 int类型    * @param num2 int类型    * @return int类型的结果    */    public static int getCompare(int num1, int num2) {        return num1 > num2 ? num1 : num2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、break 是退出当前循环结构，return 是退出当前方法2、如果返回值类型是 void ，可以返回 null 或者不返回或者 return;3、一个方法可以有多个 return，但只能有一个返回值4、返回值可以接收也可以不接收，由调用者决定如何调用5、分支结构里的每一个分支都需要有正确的返回值6、对返回值的处理方式因情况而定，可以打印、参与运算或者当做其他方法的实参7、调用带有多参数的方法，要求传入的参数数据类型，个数和顺序和类型必须和方法声明一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】方法具有单一职能原则，一个函数只做一件事</p><h3 id="方法重载【Overload】"><a href="#方法重载【Overload】" class="headerlink" title="方法重载【Overload】"></a>方法重载【Overload】</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>一个类或者接口中定义多个相同名称的方法</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、必须在同一个类中2、方法名必须一致3、参数必须不一致(个数，顺序，类型)    4、与访问修饰符、返回值类型无关<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemo9 {    public static void main(String[] args) {        // 调用同名方法，传入不同的参数列表，即可实现方法的重载        play();        play("英雄联盟");        play("红色警戒", 2);        play(1, "DNF");    }    public static void play() {        System.out.println("玩王者荣耀");    }    public static void play(String gameName) {        System.out.println("玩" + gameName);    }    public static void play(String gameName, int time) {        System.out.println("玩" + gameName + time + "小时");    }    public static void play(int time, String gameName) {        System.out.println("玩" + gameName + time + "小时");    }    /*      * Duplicate method play(String, int) in type MethodDemo9     *      * 跟返回值类型无关，只关注方法名和参数类型     *///    public static String play(String gameName, int time) {//        return "玩" + gameName + time + "小时";//    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>满足需求多样化，屏蔽使用差异，灵活、方便</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p>方法的重载我们只关注方法名和参数类型，要求方法名必须一致，参数列表必须不一致（个数，顺序，类型）</p></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>在方法内部或者形参列表上定义的变量（包括mian方法）</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>从定义局部变量的那一行到所在的代码块结束</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int i = 1; i <= 10; i++) {}for (int i = 1; i <= 10; i++) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】两个for循环中，i 循环变量分别属于不同的大括号以内，不同的作用域空间，并不冲突</p><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>从方法被调用的时刻算起到函数返回调用处的时刻结束</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int i = 1; i <= 10; i++) {}System.out.println(i); // 报错，找不到符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】for 循环结束时局部变量 i 的生存期结束，在 for 循环外无法使用 i</p><h4 id="单一性，不能重名"><a href="#单一性，不能重名" class="headerlink" title="单一性，不能重名"></a>单一性，不能重名</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 报错！for (int i = 1; i <= 10; i++) {    for (int i = 1; i <= 10; i++) {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】在一个方法内局部变量不能多次定义</p><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Test {    public static void main(String[] args) {        int num = 5;        test(num);        System.out.println(num);    // 5    }    public static void test(int num) {        num = 10;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】基本数据类型作为参数传递给局部变量时，传递的是值，局部变量的更改不影响实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">值传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\值传递.jpg" alt="值传递"></td></tr></tbody></table></div><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemoC {    public static void main(String[] args) {        int[] arr = new int[5];        System.out.println("调用方法前：" + arr[0]);        test(arr);        System.out.println("调用方法后：" + arr[0]);    }    public static void test(int[] arr) {        arr[0] = 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】引用数据类型传递时传递的是地址，局部变量直接作用于实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">引用传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\引用传递.jpg" alt="引用传递"></td></tr></tbody></table></div><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">局部变量声明在函数中，从定义的那一行开始到函数结束时被销毁局部变量必须先赋值再使用局部变量不能重复定义值传递：基本数据类型的传递不改变实参引用传递：引用数据类型的传递会改变实参Java中只有值传递，引用传递传递的是地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="学习要求"><a href="#学习要求" class="headerlink" title="学习要求"></a>学习要求</h4><blockquote><p>1、听不懂没关系，不影响写代码，读着代码就会写了。</p><p>2、先会用，在用的过程中逐渐加深对面向对象的理解。</p><p>3、利用不断地练习，形成<code>肌肉记忆</code>(代码格式)和<code>意识记忆</code>(要啥给啥)。（<font color='red'>开发中重要的思想而不是语法</font>）</p></blockquote><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><blockquote><p>面向过程编程（POP —&gt; <strong>Process-Oriented Programming</strong>）代表：C语言</p><p>面向对象编程（OOP —&gt; <strong>Object-Oriented Programming</strong>）代表：C++、Java</p><p>面向切面编程（AOP —&gt; <strong>Aspect-Oriented Programming</strong>）代表：Java</p></blockquote><h4 id="面向对象的定义"><a href="#面向对象的定义" class="headerlink" title="面向对象的定义"></a>面向对象的定义</h4><p>面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p><a href="">找合适的人做合适的事</a></p><h4 id="生活中的面向对象和面向过程"><a href="#生活中的面向对象和面向过程" class="headerlink" title="生活中的面向对象和面向过程"></a>生活中的面向对象和面向过程</h4><p>举例：<strong>想吃烤羊排</strong></p><blockquote><p>面向对象：找个店铺吃</p><p>​    1、去羊排店</p><p>​    2、点一斤羊排</p><p>​    3、等25分钟</p><p>​    4、吃</p><p>​    5、付款走人</p><p>面向过程：自己做着吃</p><p>​    1、自己做羊排</p><p>​        1.准备材料（羊、辅料、调料）</p><p>​        2.备料</p><p>​        3.烤箱预热，开烤</p><p>​        4.15分钟翻面一次</p><p>​        5.取出</p><p>​    2、吃</p><p>​    3、洗锅刷碗，打扫卫生</p></blockquote><h4 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、面向对象是基于面向过程的编程思想2、万物皆对象3、对象具有唯一性4、任何对象都具有一定的特征和行为；特征是事物的基本描述，行为是事物的功能5、类是一组相关的属性和方法的集合，是一个抽象的概念6、对象是类的具体存在7、在一组相同或相似的对象中，抽取出共性的特征和行为，保留所关注的部分就是类的抽取8、类是模板、图纸，通过类创造的对象就是实体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面向对象的优点"><a href="#面向对象的优点" class="headerlink" title="面向对象的优点"></a>面向对象的优点</h4><ul><li>直观，高效，与人类的思维习惯一致</li><li>信息隐藏，提高了程序的可维护性和安全性</li><li>提高了程序的可重用性</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><blockquote><p>面向过程：亲力亲为，自力更生，所有过程都要经历（诸葛亮是怎么死的，累死的）</p><p>面向对象：找合适的人做合适的事，直观高效（烤羊排）</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="生活中的类和对象"><a href="#生活中的类和对象" class="headerlink" title="生活中的类和对象"></a>生活中的类和对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">对象</th></tr></thead><tbody><tr><td style="text-align:center">人类</td><td style="text-align:center">马云爸爸，麻花藤（<font color='red'>隔壁老王、女朋友</font>）</td></tr><tr><td style="text-align:center">狗类</td><td style="text-align:center">史努比，忠犬八公，高飞，斯派克，小白，王可可（<font color='red'>单身狗、旺财、金毛、哈士奇</font>）</td></tr><tr><td style="text-align:center">英雄类</td><td style="text-align:center">Faker的劫，The Shy的卢锡安，霸哥的石头人，马老师的螳螂（<font color='red'>盖伦、锤石、EZ</font>）</td></tr><tr><td style="text-align:center">化妆品类</td><td style="text-align:center">我的洗面奶（<font color='red'>阿玛尼405唇釉，chill小辣椒口红，黛珂水乳，雅诗兰黛粉底液，nars腮红</font>）</td></tr></tbody></table></div><p>这些对象有什么特点？</p><blockquote><p>人类：</p><ul><li>马云爸爸，麻花藤</li></ul><p>​    都是特立独行的个体，我们一提起这个个体脑海中就能浮现出他的形象，</p><ul><li>隔壁老王、女朋友</li></ul><p>​    这些都不是对象，因为每个人都会有自己的隔壁老王，都有自己的女朋友，你脑海中的隔壁老王和你同桌脑海中的隔壁老王是同一个人吗？除非你们是同一个邻居还姓王那就不说了。但你们的女朋友总不会也是同一个吧？所以说，女朋友，隔壁老王都不是对象，你的隔壁老王，你的女朋友才是个对象！！！</p><p>狗类：</p><ul><li>史努比，忠犬八公，高飞，斯派克，小白，王可可</li></ul><p>​    这些都是独一无二的</p><ul><li>单身狗、旺财、金毛、哈士奇</li></ul><p>​    这些全都是类</p></blockquote><h4 id="Java中的类和对象"><a href="#Java中的类和对象" class="headerlink" title="Java中的类和对象"></a><font color='red'>Java中的类和对象</font></h4><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类是对某一类事物的描述，是抽象的、概念上的定义。<strong>类是模板，包含了一类事物所共有的特征(属性)和行为(方法)</strong></p><p>以人类为例：</p><blockquote><p>属性描述：学号、姓名、性别、年龄、身高、体重、地址、电话、微信、QQ…</p><p>行为描述：吃饭、睡觉、上班、学习、娱乐…</p></blockquote><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>对象是类的具体体现（<a href="">属性和方法</a>），是具体的、独一无二的个体。</strong></p><p>以班长为例：</p><blockquote><p>属性描述：班长的学号、班长的姓名、班长的身高…</p><p>行为描述：班长吃饭、班长睡觉、班长学习…</p></blockquote><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是对象的抽象，对象是类的具体实现</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><font color='red'>类的定义</font></h4><p>类是一种自定义的数据类型</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">格式：    class 类名 {        成员变量;// Field        成员方法;// Method    }class：    定义类的关键字类名：    大驼峰命名，首字母大写，见名知意    类名就是一种数据类型（自定义引用的数据类型），就是模板的名字成员变量（属性/特征描述）：    定义在类中，方法外的变量，用来描述类的特征成员方法（行为描述）：    定义在类中，用来描述类的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Student {    // 成员变量【Field】    String name;    int age;    char sex;    // 成员方法【Method】    public void eat() {        System.out.println("吃");    }    public void sleep() {        System.out.println("睡");    }    public void play() {        System.out.println("玩");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类和对象-1"><a href="#类和对象-1" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><font color='red'>对象的创建</font></h4><p>参考Scanner的创建，依葫芦画瓢</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Scanner sc = new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 格式：    类名 对象名 = new 类名([参数...]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">Person person = new Person();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a><font color='red'>对象的使用</font></h4><p>参考数组和 Scanner 的使用，依葫芦画瓢</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int[] array = new int[10];array.length    // 注意：这里没有 ()，说明这不是方法，那它是什么？我们用它来表示数组的长度，数组的长度是数组的一个属性Scanner sc = new Scanner(System.in);sc.nextInt();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    使用成员变量：        对象名.成员变量    使用成员方法：        对象名.成员方法()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 通过Person类对象person操作name、sex、age属性// 进行赋值操作person.name = "张三";person.age = 25;person.sex = '男';// 通过person进行取值操作System.out.println(person.name);System.out.println(person.age);System.out.println(person.sex);person.eat();person.sleep();person.play();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>. 的含义是 “的”</p><p>person.name：person的name</p><p>person.age：person的年龄</p><p>person.sex：person的性别</p><p>扩展：</p><p>如果直接打印对象名，会得到一个对象的【地址】，这个地址包含两部分：1、完整的包名；2、当前对象存储在堆区内存中的空间首地址</p></blockquote><h4 id="对象内存分析图"><a href="#对象内存分析图" class="headerlink" title="对象内存分析图"></a>对象内存分析图</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\java面向对象01.png" alt=""></td></tr></tbody></table></div><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><blockquote><p>没听懂没关系，多敲代码，读着代码就懂了</p><p>生活中的类和对象</p><ul><li>类是事物的统称，是一个抽象的概念</li><li>对象是事物的表现，是具体的，独一无二的</li></ul><p>Java中的类和对象</p><ul><li>类是对象的抽象，具有公共的特征和行为，对象是类的具体实现，具有唯一的特征和行为</li></ul><p>基础数据类型与类和对象</p><ul><li>类就是一种自定义的数据类型，由类名，属性和方法构成</li><li>对象就是一种数据类型的数据，由对象名，属性和方法构成</li></ul><p>类和对象的定义和使用</p><ul><li>格式和规范，一定要按照标准</li></ul><p><strong>注意</strong></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">大写开头的都是类小写开头的都是变量带()的都是方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><blockquote><p>构造方法很重要，但是比较鸡肋</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构造方法（<code>Constructor</code>）的名称和类名相同，没有返回值类型。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>类中的特殊方法，用于<font color='red'>创建对象</font>，在创建对象的时候会执行一些初始化操作，如给成员属性赋初值</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    类名([参数...]){}    Student(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><font color='red'>注意</font>：格式问题>1、构造方法的方法名与类名完全相同>>2、构造方法没有返回值类型>>3、创建对象时，触发构造方法的调用，不可手动调用>>4、如果没有声明构造方法，编译器默认生成无参构造方法>>5、如果定义了有参构造方法，编译器就不会创建无参构造方法>>【<font color='red'>强制要求</font>】>>```shell>无论什么时候，都要加上一个无参构造方法！！！>```#### 构造方法的使用```java// 自定义有参构造方法，并给name属性赋值Dog(String n) {    name = n;}// 自定义无参构造方法Dog(){}```### 构造方法的重载```javapublic Dog(String n){    name = n;}public Dog(String n, int i){    name = n;    age = i;}```#### 总结>1. 构造方法是用来创建对象，在创建对象的过程中会进行初始化操作（为对象赋值）>>2. 构造方法也是方法，除了没有返回值，其他的都跟方法一样>>按照方法参数列表的类型、个数、顺序去匹配，如果没有找到对应的就会报错>>3. 无论什么时候，都一定要给一个无参构造方法#### 扩展：反编译```shelljavap -c -l -private 类名.class```#### 扩展：对象的创建过程```shell1、类加载2、内存中开辟对象空间3、为各个属性赋予初始值4、执行构造方法中的代码5、将对象的地址赋值给变量```### this关键字#### 概述this代表所在类的对象引用，即当前对象>new 创建出来的对象>>调用方法的对象#### 作用1、<font color='red'>调用本类中的属性和方法（区别成员变量和局部变量）</font><p>2、调用本类中的其他构造方法：this()</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">格式：    this([参数...]);会根据参数列表调用对应的构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Rabbit(String color) {    // 调用本类中的属性    this.color = color;}public Rabbit(String color, int age, double weight) {    // 调用本类中的其他构造方法    this(color);    this.age = age;    this.weight = weight;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、this()只能在构造方法中使用2、this()只能在第一行3、构造方法中不能同时出现两个this()，因为24、不能自己调用自己，不能相互调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="规范化this"><a href="#规范化this" class="headerlink" title="规范化this()"></a>规范化this()</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Son {    String name;    int age;    float salary;    public Son() {    }    public Son(String name) {        // 调用Son(String name, int age, float salary)        this(name, 0, 0.0F);    }    public Son(String name, int age) {        // 调用Son(String name, int age, float salary)        this(name, age, 0.0F);    }    public Son(String name, int age, float salary) {        this.name = name;        this.age = age;        this.salary = salary;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>this表示的是当前对象</li><li>this可以调用本类中的属性和方法，最常用与区分成员变量和局部变量</li><li>this还可以调用本类中的构造方法，但是要注意有坑</li></ul></blockquote><h3 id="访问-权限-修饰符"><a href="#访问-权限-修饰符" class="headerlink" title="访问(权限)修饰符"></a>访问(权限)修饰符</h3><h4 id="private-私有-关键字"><a href="#private-私有-关键字" class="headerlink" title="private(私有)关键字"></a>private(私有)关键字</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、可以修饰成员变量和成员方法2、被private修饰的变量和方法仅本类中可用3、被private修饰的变量需要提供get、set方法供类外调用使用    4、boolean类型的 get 方法比较特殊：    public boolean isName(String name){        return name;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Dog {    private String name;    int age;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }    private void function() {        System.out.println("method be execute!");    }    public void executeFunction() {        this.function();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java中的访问修饰符"><a href="#Java中的访问修饰符" class="headerlink" title="Java中的访问修饰符"></a>Java中的访问修饰符</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">类内部</th><th style="text-align:center">同包下</th><th style="text-align:center">子类中</th><th style="text-align:center">非同包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">默认不写</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></div><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、一般我们最常用的就是private和public，建议任何情况下都使用访问修饰符对变量和方法进行限制</p><p>2、public权限最高，整个项目中都可以访问（同一个项目），private权限最小，只能在本类中使用</p><p>3、被private修饰的变量和方法可以通过提供公共的方法对其进行访问</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><blockquote><p>封装</p><p>继承</p><p>多态</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。核心是<font color='red'>归纳总结</font></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>提高代码的复用度、安全性，不必关心具体细节，便于开发</p><h4 id="JavaBean-规范化封装"><a href="#JavaBean-规范化封装" class="headerlink" title="JavaBean 规范化封装"></a>JavaBean 规范化封装</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1. 要求Java中的所有实体类成员变量全部私有化，最少提供一个无参数构造方法，对应成员变量实现setter和getter方法2. JavaBean规范，是为了后期开发汇总更好的代码适配度，提高代码运行的统一性，能够满足框架的使用3. JavaBean规范只是一个规范，而且是作为一个基础规范，操作都是可以使用快捷键来完成的！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    private char sex;    private boolean alive;    public Person() {}    public String getName() {        return this.name;    }    public int getAge() {        return this.age;    }    public char getSex() {        return this.sex;    }    public boolean isAlive() {        return alive;    }    public void setAlive(boolean alive) {        this.alive = alive;    }    public void setName(String name) {        this.name = name;    }    public void setAge(int age) {        this.age = age;    }    public void setSex(char sex) {        this.sex = sex;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>没有名字的对象，是对象的一种简化表示形式</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>一次性，每次使用都是一个新的对象</p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><blockquote><p>1、对象调用方法仅使用一次，然后等待销毁</p><p>2、作为实际参数传递</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestDog{    public static void main(String[] args) {        // 对象调用方法仅使用一次        new Dog().sleep();        // 作为实际参数传递        useDog(new Dog());    }    public static void useDog(Dog dog) {        dog.sleep();    }}class Dog {    String name;    int age;    public void sleep() {        System.out.println("小狗睡觉.....");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>提高开发效率，简化代码结构</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容。这个关系叫继承。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">关键字：extends格式:    class Son extends Father {    }一个孩子只能有一个父亲一个父亲可以有多个孩子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、Java为单继承，一个类只能有一个直接父类，但可以多级继承，属性和方法逐级叠加2、构造方法只可服务于本类，不可继承，子类执行构造方法前会默认调用父类的无参构造方法。可以通过super()去访问父类的构造方法3、private 修饰的属性和方法不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo {    public static void main(String[] args) {        // 创建一个父类对象        Father father = new Father();        // 父类调用父类的属性和方法        father.name = "父";        System.out.println(father.name);        father.game();        System.out.println("-------------");        // 创建一歌子类对象        Son son = new Son();        // 子类调用子类的属性和方法        son.age = 16;        System.out.println(son.age);        son.study();        // 子类调用父类的属性和方法(public修饰)        son.name = "子";        System.out.println(son.name);        son.game();        /*         * 子类调用父类private修饰的属性和方法         *          * 报错         * The field Father.suffer is not visible         * The method cook() from the type Father is not visible         *          * 由此可知子类不能调用父类私有化的属性和方法         *///        son.suffer = 10;//        son.cook();    }}public class Father {    public String name;    private int suffer;    public void game() {        System.out.println("下棋");    }    private void cook() {        System.out.println("做饭");    }}public class Son extends Father{    public int age;    public void study() {        System.out.println("子类 -- 学习");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="子类构造方法执行前默认先执行父类的无参构造方法"><a href="#子类构造方法执行前默认先执行父类的无参构造方法" class="headerlink" title="子类构造方法执行前默认先执行父类的无参构造方法"></a>子类构造方法执行前默认先执行父类的无参构造方法</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Father {    String name;    public Father() {        System.out.println("Father's Constrator be performed");    }}class Son extends Father {    int age;    public Son() {        System.out.println("Son's Constrator be performed");    }}public class TestSon {    public static void main(String[] args) {        Son son = new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Father's Constrator be performedSon's Constrator be performed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】Son 的构造方法中编译器默认生成 super(); 用来调用父类的构造方法，目的是为了初始化父类字段，因为子类可能会用到</p><div class="table-container"><table><thead><tr><th style="text-align:center">继承内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\继承内存分析图.jpg" alt="继承内存分析图"></td></tr></tbody></table></div><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、提高了代码的复用性2、提高了代码的维护性3、让类与类之间产生了一个关系，是多态的前提<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、让类的耦合性增强。这样某个类的改变，就会影响到其他和该类相关的类2、打破了封装性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Java中只有单继承</p><p>子类可以继承父类的非私有属性和方法（非private修饰的）</p><p>执行子类的构造方法前会默认执行父类的无参构造方法</p></blockquote><h3 id="方法重写【Override】"><a href="#方法重写【Override】" class="headerlink" title="方法重写【Override】"></a>方法重写【Override】</h3><h4 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h4><p>开发中父类的方法不一定适用于子类，因为父类方法不能更改，在子类中新增方法会造成代码的冗余，而且不符合逻辑</p><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、应用于继承和实现接口2、方法的返回值类型，方法名，形参列表与父类一致3、使用@Override注解来标识4、重写方法的访问修饰符权限不能低于父类    private < 默认(什么都不写) < protected < public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Son extends Father{    public int age;    @Override    public void game() {        System.out.println("玩红色警戒");    }    public void study() {        System.out.println("子类 -- 学习");    }}public class Father {    public String name;    private int suffer;    public void game() {        System.out.println("下棋");    }    private void cook() {        System.out.println("做饭");    }}public class Demo1 {    public static void main(String[] args) {        Son son = new Son();        son.game();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>既沿袭了父类的方法名，又实现了子类的扩展</p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、方法的重写能够在不新增方法的情况下实现子类的扩展</p><p>2、方法重写要求方法声明格式和父类完全一致（访问修饰符不能小于父类）</p><p>3、@Overrid关键字用来开启格式检测，如果不一致就会报错</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote><p>super指父类对象，用来区分父类和子类，用于调用父类的属性和方法</p><p>用法和this非常类似：this指当前对象，super指父类对象</p></blockquote><h4 id="调用父类的属性和方法"><a href="#调用父类的属性和方法" class="headerlink" title="调用父类的属性和方法"></a>调用父类的属性和方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Father {    public int age = 60;    public void play() {        System.out.println("下象棋");    }}public class Son extends Father {    public int age = 16;    @Override    public void play() {        System.out.println("玩游戏");    }    public void showAge() {        int age = 20;        System.out.println("局部变量：" + age);        System.out.println("当前对象成员变量：" + this.age);        System.out.println("父类对象成员变量：" + super.age);    }    public void callPlay() {        // 调用当前对象的方法        this.play();        // 调用父类对象的方法        super.play();    }}public class Demo {    public static void main(String[] args) {        Son son = new Son();        son.showAge();        son.callPlay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h4><p>默认调用父类的无参构造，且必须在代码的第一行</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Father {    private String name;    public Father() {        System.out.println("Father's Constrator be performed");    }    public Father(String name) {        System.out.println("Father's Constrator be performed with name");    }}class Son extends Father {    private int age;    public Son() {        super();        System.out.println("Son's Constrator be performed");    }    public Son(String name, int age) {        super(name);        this.age = age;        System.out.println("Son's Constrator be performed with name and age");    }}public class TestSon {    public static void main(String[] args) {        Son son = new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、super指父类对象，对比this关键字，使用方法都一样</p><p>2、super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><p>3、父类的属性要交给父类的构造方法去操作，没什么事就不要去使用 super() 来调用父类的构造方法了</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>final表示最终的，用来修饰变量，方法和类</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、final 修饰的局部变量只能被赋值一次2、final 修饰的成员变量只能被赋值一次，并且必须在声明时就赋值3、final 修饰的基本类型变量是一个常量(只能被赋值一次)，引用类型变量不可修改地址，如对象4、final 修饰的方法不能被重写5、final 修饰的类不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.fc.j._final;/* * final修饰的局部变量 */public class FinalDemo1 {    public static void main(String[] args) {        // 测试final修饰的修饰的变量        final int num;        num = 10;        System.out.println(num);        /*         * 被final修饰的变量只能赋值一次         *          * The final local variable num may already have been assigned         *          * 被final修饰的局部变量num可能已经被赋值         */        // num = 20;    }}// final修饰的类不能被继承，断子绝孙class Father {    /*     * final 修饰的成员变量必须在声明时就赋值     *      * The blank final field age may not have been initialized     * 空白的final成员变量可能未被初始化     */     // final int age;    final int age = 16;    public final void play() {        System.out.println("下棋");    }}class Son extends Father {    /*     *  Cannot override the final method from Father     *  无法重写被final修饰的方法     *///    @Override//    public final void play() {//        //    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>final修饰可以保证安全性，比如数组的长度属性，String类，这些都是final修饰的，保证不可变</p><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、final表示最终的，可以修饰变量，属性和方法</p><p>2、final修饰的基本数据类型的成员变量只能被赋值一次</p><p>3、final修饰的引用数据类型的成员变量地址不可变，但不影响地址所指向的对象的操作</p><p>4、final修饰的方法不能被重写</p><p>5、final修饰的类不能被继承</p></blockquote><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>static 关键字方便在<strong>没有创建对象的情况下来进行调用方法和变量</strong>(优先级高于对象)，可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能</p><h4 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class PersonDemo {    public static void main(String[] args) {        Person person1 = new Person("张三", 16);        Person person2 = new Person("李四", 17);        Person person3 = new Person("王五", 18);        Person person4 = new Person("赵六", 19);        /*         * The static field Person.address should be accessed in a static way         * 静态成员变量应该通过静态的方式访问（注意这里是应该，不是必须）         *          * Change access to static using 'Person' (declaring type)         * 使用Person声明类型来更改对静态的访问         * 通过类名来操作成员变量：Person.address         */        System.out.println("姓名：" + person1.name + " 年龄：" + person1.age + " 地址：" + Person.address);        System.out.println("姓名：" + person2.name + " 年龄：" + person2.age + " 地址：" + Person.address);        System.out.println("姓名：" + person3.name + " 年龄：" + person3.age + " 地址：" + Person.address);        System.out.println("姓名：" + person4.name + " 年龄：" + person4.age + " 地址：" + Person.address);        // 通过类名直接调用static修饰的成员变量，此时是没有对象的        System.out.println("没有对象：" + Person.address);        /*         *  Cannot make a static reference to the non-static field Person.name         *           *  将name添加static后没有报错         *///        System.out.println("没有对象：" + Person.name);        /*         * 通过对象调用statice修饰的成员方法         *          * The static method test() from the type Person should be accessed in a static way         */        // person1.testStatic();        // 通过类名直接调用静态方法        Person.testStatic();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、通过类名调用静态成员变量，因为静态变量与对象无关2、静态变量被所有对象共享，一处更改处处更改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h4><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Person {    public String name = "张三";    public int age;    public static String address = "郑州";    public Person() {        super();    }    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    // 自定义static修饰的成员方法    public static void testStatic() {        /*         * 静态方法不能调用非静态方法         * Cannot make a static reference to the non-static method test() from the type Person         */        // test();        System.out.println("static mothed");        /*         * 不能再静态方法中使用this关键字         *          * Cannot use this in a static context         */        // this.name;    }    public void test() {        System.out.println("method");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、static修饰的方法不能访问本类中的非静态变量和方法，不能使用this2、通过类名来调用静态成员方法，工具类的应用很广泛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、static修饰的成员变量和方法都是对象所共享的资源，对其进行的操作回作用于所有对象。</p><p>2、static修饰的成员变量和方法依赖于类不依赖于对象，即没有对象</p><p>3、static修饰的成员变量和成员方法都可以通过类名调用，没有对象</p><p>4、静态不能调用费静态，不能使用this关键字，没有对象</p><p>5、静态变量常和final关键字搭配作为常量使用，静态方法常用于工具类</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">static成员变量内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\static成员变量内存分析图.jpg" alt="static成员变量内存分析图"></td></tr></tbody></table></div><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在 Java 中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)</p><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、用于给对象初始化，多个构造方法中相同的代码存放到一起，每次调用构造方法都会执行，并且在构造方法前执行2、只有创建对象时调用，类不能调用3、构造代码块可以有多个，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    {        System.out.println("Person构造代码块执行");    }    public Person() {        System.out.println("Person构造方法执行");    }}public class TestPerson {    public static void main(String[] args) {        System.out.println("main方法");        new Person();        new Person();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    static {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、用于给类进行初始化，在加载的时候就执行，并且只执行一次2、优先级高于主函数3、静态代码块可以有多个，顺序执行，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    static {        System.out.println("Person静态代码块执行");    }    public Person() {        System.out.println("Person构造方法执行");    }}public class TestPerson {    static {        System.out.println("静态代码块1执行");    }    public static void main(String[] args) {        System.out.println("main方法");        new Person();        new Person();    }    static {        System.out.println("静态代码块2执行");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">静态代码块1执行静态代码块2执行main方法Person静态代码块执行Person构造方法执行Person构造方法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码块相关执行顺序"><a href="#代码块相关执行顺序" class="headerlink" title="代码块相关执行顺序"></a>代码块相关执行顺序</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Father {    public Father() {        System.out.println("父类构造方法执行~~~");    }    {        System.out.println("父类构造代码块执行~~~");    }    static {        System.out.println("父类静态代码块执行~~~");    }    public static void function() {        System.out.println("父类静态成员方法执行~~~");    }}public class Son extends Father{    public Son() {        System.out.println("子类构造方法执行~~~");    }    {        System.out.println("子类构造代码块执行~~~");    }    static {        System.out.println("子类静态代码块执行~~~");    }    public static void function() {        System.out.println("子类静态成员方法执行~~~");    }    public static void main(String[] args) {                System.out.println("main方法执行~~~");        new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">父类静态代码块执行~~~子类静态代码块执行~~~main方法执行~~~父类构造代码块执行~~~父类构造方法执行~~~子类构造代码块执行~~~子类构造方法执行~~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>执行顺序</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    static Test test1 = new Test();    static Test test2 = new Test();    static {        System.out.println("静态代码块");    }    {        System.out.println("构造代码块");    }    public Test() {        System.out.println("构造方法");    }    public static void main(String[] args) {        System.out.println("main方法");        new Test();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">构造代码块构造方法构造代码块构造方法静态代码块main方法构造代码块构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、构造代码块用于给对象初始化，每次创建对象都会调用构造代码块，并且执行顺序在构造方法之前</p><p>2、静态代码块用于给类初始化，当类被加载的时候就会调用静态代码块（只执行一次），执行顺序在main方法之前</p></blockquote><h3 id="abstract关键字【抽象类】"><a href="#abstract关键字【抽象类】" class="headerlink" title="abstract关键字【抽象类】"></a>abstract关键字【抽象类】</h3><p>不能实例化的类就是抽象类，用 abstract 修饰</p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">abstract class 类名 {    成员变量    构造方法    成员方法        非抽象方法        抽象方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、抽象类和抽象方法必须用关键字 abstract 修饰2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类3、abstract 修饰的方法没有方法体，且子类必须重写4、抽象类不能实例化，因为 abstract 类中有 abstract 方法5、抽象类的子类        也可以是一个抽象类，可以重写也可以不重写父类的抽象方法。        可以是一个具体类。这个类必须重写抽象类中的所有抽象方法。(可以实例化)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestSon {    public static void main(String[] args) {        Son son = new Son();        son.play();    }}// 抽象类abstract class Father {    String name;    int age;    public Father() {    }    public void eat() {        System.out.println("吃饭");    }    // 抽象方法    abstract public void play();}class Son extends Father {    // 抽象方法的重写    @Override    public void play() {        System.out.println("玩游戏");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><p>interface ：用来声明接口的关键字</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">声明格式：    interface 接口名 {        静态常量;        抽象方法;    }实现格式：    class 类名 implements 接口名 {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、接口中的成员变量只能是静态常量，定义时必须初始化。默认修饰符：public static final2、接口中没有构造方法，因为接口不能实例化对象3、接口中的成员方法只能是抽象方法，没有方法体。默认修饰符：public abstract4、接口的实现类必须重写接口中方法，或者是一个抽象类(可以重写也可以不重写接口中的方法)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口的声明和实现"><a href="#接口的声明和实现" class="headerlink" title="接口的声明和实现"></a>接口的声明和实现</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface play{    // 常量，缺省修饰符：public static final    int time = 10;    // 抽象方法，缺省修饰符：public abstract    void geme();}public class TestInterface3 implements play{    // 重写接口中的方法    @Override    public void geme() {        System.out.println("玩游戏");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写接口中的方法</p><h4 id="抽象类实现接口"><a href="#抽象类实现接口" class="headerlink" title="抽象类实现接口"></a>抽象类实现接口</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface servlet {    void init();    void service();}abstract class BaseServlet implements servlet {    // 重写init()方法    @Override    public void init() {        System.out.println("初始化");    }}class MyServlet extends BaseServlet {    @Override    public void service() {        System.out.println("服务方法");    }}public class Test {    public static void main(String[] args) {        new MyServlet().init();        new MyServlet().service();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】抽象类实现接口，可以选择性重写也可以不重写接口中的方法</p><h4 id="类的接口多实现"><a href="#类的接口多实现" class="headerlink" title="类的接口多实现"></a>类的接口多实现</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Play {    void geme();}interface Eat {    void noodles();}public class TestInterface3 implements Play, Eat {    // 重写Play类中的方法    @Override    public void geme() {        System.out.println("玩游戏");    }    // 重写Eat类中的方法    @Override    public void noodles() {        System.out.println("吃面条");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写所有接口中的方法</p><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Eat {    void noodles();}interface Play {    void happy();}// 单继承interface Person extends Play {}// 多继承interface Animal extends Play, Eat {}// 实体类实现Animal接口，重写所有方法class Biology implements Animal {    @Override    public void happy() {        System.out.println("玩得开心");    }    @Override    public void noodles() {        System.out.println("面条好吃");    }}public class Test {    public static void main(String[] args) {        Biology biology = new Biology();        biology.happy();    // 玩得开心        biology.noodles();    // 面条好吃    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口之间可以单继承，也可以多继承</p><h3 id="jdk1-8新特性：default接口"><a href="#jdk1-8新特性：default接口" class="headerlink" title="jdk1.8新特性：default接口"></a>jdk1.8新特性：default接口</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Function {    void test();    default void testDefault() {        System.out.println("default修饰的接口可以有方法体");    }}// default 修饰的接口可以不被重写class Base implements Function {    @Override    public void test() {        System.out.println("Base类重写Function接口中的方法");    }}// default 修饰的接口也可以重写class Boost implements Function {    @Override    public void test() {        System.out.println("Boost类重写Function接口中的方法");    }    @Override    public void testDefault() {        System.out.println("Boost类重写Function接口中的default方法");    }}public class TestInterface2 {    public static void main(String[] args) {        Base base = new Base();        Boost boost = new Boost();        base.test();        // Base类重写Function接口中的方法        base.testDefault();    // default修饰的接口可以有方法体        boost.test();        // Boost类重写Function接口中的方法        boost.testDefault();// Boost类重写Function接口中的default方法    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】default修饰的接口可以不被重写</p><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、接口是对类的扩展，通过接口可以让类拥有更多更强的功能2、接口中只有全局常量和抽象方法，所以不能实例化3、接口的实现类必须重写所有方法，或者是个抽象类4、接口可以多实现5、接口可以单继承，也可以多继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>二者具有直接或间接的继承关系时，父类引用指向子类对象，从而产生多种形态；接口的引用指向实现接口的类对象也是多态</strong></p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>多态场景下，父类引用调用方法，如果被子类重写过，优先执行子类重写过后的方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestCar {    public static void main(String[] args) {        // 父类引用指向子类对象        Vehicle vehicle = new Car();        // 优先执行子类重写过的方法        vehicle.run();    // Car run！！！    }}class Vehicle {    public void run() {        System.out.println("Vehicle run！！！");    }}class Car extends Vehicle {    @Override    public void run() {        System.out.println("Car run！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景一"><a href="#应用场景一" class="headerlink" title="应用场景一"></a>应用场景一</h4><p>使用父类作为方法形参实现多态，使方法参数的类型更为宽泛</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestCar {    public static void main(String[] args) {                Vehicle vehicle = new Car();        vehicle.type = "小汽车";        Bike bike = new Bike();        bike.type = "自行车";        Bus bus = new Bus();        bus.type = "公交车";        Employee employee = new Employee("你的迪丽热巴");        employee.goHome(vehicle);        employee.goHome(bus);    }}class Employee {    String name;    public Employee() {    }    public Employee(String name) {        this.name = name;    }    public void goHome(Vehicle vehicle) {        System.out.println(this.name + "乘坐" + vehicle.type + "交通工具回家");    }}class Vehicle {    String type;    public void run() {        System.out.println("Vehicle run！！！");    }}class Bus extends Vehicle {    @Override    public void run() {        System.out.println("Bus run！！！");    }}class Car extends Vehicle {    @Override    public void run() {        System.out.println("Car run！！！");    }}class Bike extends Vehicle {    @Override    public void run() {        System.out.println("Bike run！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">你的迪丽热巴乘坐小汽车回家Car run！！！你的迪丽热巴乘坐公交车回家Bus run！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景二"><a href="#应用场景二" class="headerlink" title="应用场景二"></a>应用场景二</h4><p>使用父类作为方法返回值实现多态，使方法可以返回不同子类对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Vehicle buyVehicle(int money) {        Vehicle vehicle = null;        if (money >= 100) {            Bus bus = new Bus();            bus.speed = 60;            bus.price = 1230000.0;            bus.seatNum = 16;            bus.type = "公交车";            vehicle = bus;        } else if (money >= 30) {            Car car = new Car();            car.price = 310000.0;            car.speed = 90;            car.type = "小汽车";            car.brand = "BMW";            vehicle = car;        } else if (money >= 1) {            Bike bike = new Bike();            bike.type = "捷安特自行车";            bike.speed = 40;            bike.price = 2000.0;            bike.color = "红色";            vehicle = bike;        }        return vehicle;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="向上装箱与向下拆箱"><a href="#向上装箱与向下拆箱" class="headerlink" title="向上装箱与向下拆箱"></a>向上装箱与向下拆箱</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Animal{}class Cat extends Animal{}class Dog extends Animal{}class Fish extends Animal {}public class Test {    public static void main(String[] args) {        showAnimal(new Animal());    // code.polymorphic.animal.Animal@7852e922        // 向上转型        showAnimal(new Cat());    // code.polymorphic.animal.Cat@4e25154f        // 向上转型        showAnimal(new Dog());    // code.polymorphic.animal.Dog@70dea4e        // 向上转型        showAnimal(new Fish());    // code.polymorphic.animal.Fish@5c647e05        System.out.println("----------------------");        Animal animal = getAnimal();        // 向下转型        Cat cat = (Cat) getCat();        // 向下转型        Dog dog = (Dog) getDog();        // 向下转型        Fish fish = (Fish) getFish();        System.out.println(animal);    // code.polymorphic.animal.Animal@33909752        System.out.println(cat);    // code.polymorphic.animal.Cat@55f96302        System.out.println(dog);    // code.polymorphic.animal.Dog@3d4eac69        System.out.println(fish);    // code.polymorphic.animal.Fish@42a57993    }    /**     * 展示动物     * @param animal     */    public static void showAnimal(Animal animal) {        System.out.println(animal);    }    /**     * 得到动物     * @return 返回一个Animal对象     */    public static Animal getAnimal() {        return new Animal();    }    /**     * 得到猫     * @return 返回一个Cat对象     */    public static Animal getCat() {        return new Cat();    }    /**     * 得到狗     * @return 返回一个Dog对象     */    public static Animal getDog() {        return new Dog();    }    /**     * 得到鱼     * @return 返回一个Fish对象     */    public static Animal getFish() {        return new Fish();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h4><p>用于判断当前对象是否是某个类，或者其子类、实现类的实例。如果是返回true，否则返回false。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 动物类 */class Animal {}/** * 老虎类 */class Tiger extends Animal {}/** * 熊猫类 */class Panda extends Animal {}/** * 猴子类 */class Monkey extends Animal {}public class AnimalDemo {    public static void main(String[] args) {        Animal ani = getAnimal();        if (ani instanceof Panda) {            // ani一定是panda对象或子类对象            Panda panda2 = (Panda) ani;            System.out.println("这是熊猫：" + panda2);            showPanda(panda2);        } else {            System.out.println("这是动物：" + ani);        }    }    // 获取动物，返回一个Panda对象    public static Animal getAnimal() {        return new Panda();    }    // 展示熊猫对象    public static void showPanda(Panda panda) {        System.out.println(panda);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】<strong>使用 instanceof 关键字做判断时， instanceof 操作符的左操作数必须和右操作数存在继承或实现关系</strong></p><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、父类引用指向子类对象，接口引用指向实现类对象</p><p>2、instanceof用以比较对象是否是类或父类的实例，接口的实现类</p></blockquote><h3 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h3><blockquote><p>API(Application Programming Interface) 应用程序编程接口</p></blockquote><p>编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑、向后跑、射门、抢球等各种命令，没有编过程序的人很难想象这样的程序如何编写。但是对于有经验的开发人员来说，知道机器人厂商一定会提供一些用于控制机器人的Java类，这些类中定义好了操作机器人各种动作的方法。其实，这些Java类就是机器人厂商提供给应用程序编程的接口，大家把这些类称为Xxx Robot API。本章涉及的Java API指的就是JDK中提供的各种功能的Java类。</p><h4 id="学习汉语和学习编程的异同点"><a href="#学习汉语和学习编程的异同点" class="headerlink" title="学习汉语和学习编程的异同点"></a>学习汉语和学习编程的异同点</h4><p>相同点</p><ul><li>基本语法</li><li>大量成语</li><li>写文章的手法和技巧</li></ul><p>不同点</p><ul><li>学习汉语 必须先学后用</li><li>学习编程 可以现用现学</li></ul><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p>Object类是类层次结构的根类，所有类都直接或者间接的继承自该类</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Object()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】Object 只有一个无参构造方法</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>用来返回对象的字符串表示形式</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public String toString()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值为：包名.类名@当前对象在内存空间中的首地址</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">getClass().getName() + '@' + Integer.toHexString(hashCode())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写toString"><a href="#重写toString" class="headerlink" title="重写toString()"></a>重写toString()</h4><p>由于默认情况下的数据对我们来说没有意义，一般会重写该方法用以展示对象的字段信息</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 toString 方法    @Override    public String toString() {        return "Student [name=" + name + ", age=" + age + "]";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student = new Student("Buffer",23);                System.out.println(student);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Student [name=Buffer, age=23]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><blockquote><p>toString方法用来展示一些对象的基本信息：完整的包名.类名@堆内存地址，通常我们用快捷键来重写这个方法来获取我们需要的数据信息</p></blockquote><h3 id="Object-类-1"><a href="#Object-类-1" class="headerlink" title="Object 类"></a>Object 类</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>用来比较两个对象的地址是否相同</p><pre><code>public boolean equals(Object obj) {        return (this == obj);}</code></pre><p>如果调用此方法的对象与 obj 的地址相同(即为同一个对象)，返回true，否则返回false</p><h4 id="重写equals-思路"><a href="#重写equals-思路" class="headerlink" title="重写equals()思路"></a>重写equals()思路</h4><p>一般需要重写 equals() 方法用以判断两个对象的字段是否相同</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、判断两个对象的地址是否相同2、判断两个对象的类型是否一致3、判断两个对象所存储的数据是否相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 equals 方法    @Override    public boolean equals(Object obj) {        // 判断是否是同一个对象(地址相同)，如果是返回 true        if (this == obj) {            return true;        }        // 判断数据类型是否一致，如果不一致返回 false        if (!(obj instanceof Student)) {            return false;        }        // 强制类型转换为当前类对象        Student student = (Student) obj;        // 所有字段全部满足时返回 true ，否则返回false        return this.name.equals(student.name) && this.age == student.age;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student1 = new Student("Buffer",23);        Student student2 = new Student("Banlance",22);        Student student3 = new Student("Buffer",23);        System.out.println(student1.equals(student2));        System.out.println(student1.equals(student3));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">falsetrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】基本数据类型不能使用 equals() 方法</p><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、equals方法用来判断两个对象是否相同，默认比较的是两个对象的内存首地址。我们可以通过重写equals方法实现对两个对象的比较</p><p>2、注意equals方法的调用者，不同的调用者调用方法是不一样的</p></blockquote><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>返回对象的哈希码值，<strong>具有唯一指向性</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public int hashCode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写hashCode"><a href="#重写hashCode" class="headerlink" title="重写hashCode()"></a>重写hashCode()</h4><p>hashCode方法要求必须和 equals() 方法的结果是对应的，如果两个对象的 equals 的结果为 true ，那这两个对象的 hashCode 的值一定相同，所以<strong>只要重写了 equals 方法，就必须重写 hashCode 方法</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 equals 方法    @Override    public boolean equals(Object obj) {        if (this == obj) {            return true;        }        if (!(obj instanceof Student)) {            return false;        }        Student student = (Student) obj;        return this.name.equals(student.name) && this.age == student.age;    }    // 重写 hashCode 方法    @Override    public int hashCode() {        // 调用 Objects 工具类的 hash 方法，根据传入的参数生成一个指定的 hashCode 值        return Objects.hash(name, age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student1 = new Student("Buffer",23);        Student student2 = new Student("Banlance",22);        Student student3 = new Student("Buffer",23);        System.out.println(student1.equals(student2));        System.out.println(student1.equals(student3));        System.out.println(student1.hashCode());        System.out.println(student2.hashCode());        System.out.println(student3.hashCode());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">falsetrue18926508722470635951892650872<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>student1 和 student3 的 equals 方法返回值是 true ，所以他们的 hashCode 值相同</p><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、hashCode()用来获取当前对象的哈希值，表示对象的唯一标识。如果重写equals()则必须重写hashCode()方法</p><p>2、equals相同hashCode一定相同，hashCode相同equals不一定相同</p></blockquote><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>获取当前对象的 Class 对象（字节码对象），直接打印会显示包含完整的包名,类名的信息</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public final native Class<?> getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Cat {}public class GetClassDemo {    public static void main(String[] args) {        Cat cat = new Cat();        System.out.println(cat.getClass());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">protected void finalize()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><h4 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Object类是所有类的基类，提供了一个无参的构造方法和一些公共方法</p><p>通过重写toString方法来获取对象中的数据</p><p>通过重写equals方法和hashCode方法来判断两个对象是否相同，这两个方法必须同时重写</p><p>getClass用来获取Class对象</p><p>finalize方法用于垃圾回收，不可控</p></blockquote><h3 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h3><p><code>System</code> 类包含一些有用的类字段和方法。它不能被实例化。 </p><p>在 <code>System</code>  类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 标准输入流，常用于键盘录入public final static InputStream in = null// 标准输出流，常用于打印信息public final static PrintStream out = null;// 标准错误输出流，常用于打印错误信息public final static PrintStream err = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class SystemFieldDemo {    public static void main(String[] args) {        // 通过Scanner测试标准输入        Scanner sc = new Scanner(System.in);        String next = sc.next();        // 通过System.out.print测试标准输出流        System.out.println(next);        sc.close();        // 通过System.err.print测试标准输出流        System.err.println("打印错误报告");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法私有化，无法创建对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** Don't let anyone instantiate this class */private System() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h3><p>这个方法表示复制数组，从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数解释</p><blockquote><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ArraycopyDemo {    public static void main(String[] args) {        // 创建一个长度为5的int类型数组arr        int[] arr = new int[5];        // 为数组arr赋值        for (int i = 0; i < arr.length; i++) {            arr[i] = i;        }        // 遍历数组arr        for (int i = 0; i < arr.length; i++) {            System.out.println(arr[i]);        }        System.out.println("------------------");        // 创建一个新的长度为5的int类型数组newArr        int[] newArr = new int[5];        // 调用System的arraycopy方法，分别传入对应的参数        System.arraycopy(arr, 0, newArr, 0, 5);        // 遍历newArr数组        for (int i = 0; i < newArr.length; i++) {            System.out.println(newArr[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><p>返回以毫秒为单位的当前时间。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static native long currentTimeMillis();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】</p><blockquote><p>1、这个方法的返回值是long类型</p><p>2、当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CurrentTimeMillsDemo {    public static void main(String[] args) {        long currentTimeMillis = System.currentTimeMillis();        System.out.println("毫秒：" + currentTimeMillis);        System.out.println("年：" + currentTimeMillis/1000/60/60/24/365);            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String date = sdf.format(currentTimeMillis);        System.out.println(date); // 2020-10-06 17:53:02    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h3><p>运行垃圾回收器。在此之前会调用Object的finalize()</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void gc()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>System.gc()可用于垃圾回收。当使用System.gc()回收某个对象所占用的内存之前，通过要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，Java提高了默认机制来清理该对象的资源，就是调用Object类的finalize()方法。finalize()方法的作用是释放一个对象占用的内存空间时，会被JVM调用。而子类重写该方法，就可以清理对象占用的资源，该方法有没有链式调用，所以必须手动实现。</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    // 构造方法，getter、setter方法、toString方法    /*     * 通过重写finalize方法验证调用gc会执行此方法     */    @Override    protected void finalize() throws Throwable {        System.out.println("执行finalize方法回收垃圾：" + this);        super.finalize();    }}public class GcDemo {    public static void main(String[] args) {        System.out.println(new Person("张三", 16));        System.gc();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从程序的运行结果可以发现，执行System.gc()前，系统会自动调用finalize()方法清除对象占有的资源，通过super.finalize()方式可以实现从下到上的finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。</p><p>但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的Java程序运行争抢资源，只有在执行大量的对象的释放，才调用垃圾回收最好</p></blockquote><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void exit(int status)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ExitDemo {    public static void main(String[] args) {        System.out.println("程序执行开始");        // 执行此方法后关闭虚拟机，程序不会再向下执行        System.exit(0);        System.out.println("程序执行结束");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h4><blockquote><p>System类提供了一些和系统相关的类字段和方法，便于我们和底层进行交互。</p><p>比较常用的就是arraycopy()和currentTimeMills()，其他不需要关注</p></blockquote><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><p>一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 </p><h4 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public final class Scanner implements Iterator<String>, Closeable {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里我们需要关注三个点：</p><p>1、final修饰，不能被继承</p><p>2、实现了 Iterator 接口(迭代器接口)，主要使用其中的 hasNext 方法和 next 方法</p><p>3、实现了 Closeable 接口，主要使用其中的 close 方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 用来判断是否还有下一个元素录入public boolean hasNext()// 用来接收录入的数据public String next()// 用来关闭资源(输入流)public void close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><p>从指定的扫描输入流构造一个 Scanner</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Scanner(InputStream source)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        // java.util.Scanner.Scanner(InputStream source)        // 使用构造方法，传入一个标准输入流，创建一个Scanner对象        Scanner sc = new Scanner(System.in);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 此方法用于接收从键盘录入的字符串public String next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        // 从键盘录入一个字符串        String str = sc.next();        System.out.println(str);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nextInt"><a href="#nextInt" class="headerlink" title="nextInt()"></a>nextInt()</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 此方法用于从键盘获取一个int类型的数据public int nextInt()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        // 从键盘录入一个字符串        int num = sc.nextInt();        System.out.println(num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法的重载：nextInt-int-radix"><a href="#方法的重载：nextInt-int-radix" class="headerlink" title="方法的重载：nextInt(int radix)"></a>方法的重载：nextInt(int radix)</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 指定进制数从键盘录入一个int类型的数据public int nextInt(int radix)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>int radix参数表示一个进制数，如果从键盘录入的数据超过了指定的进制数就会报错，默认是10</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        /*         * 8表示接收8进制内的数，及0~7         *          * 从键盘录入的数据中不能出现8及其以上的数字，如果有会报错：         * InputMismatchException 输入类型不匹配异常         */        int num = sc.nextInt(8);        System.out.println(num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相关方法：用法类似，要求触类旁通"><a href="#相关方法：用法类似，要求触类旁通" class="headerlink" title="相关方法：用法类似，要求触类旁通"></a>相关方法：用法类似，要求触类旁通</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public String nextLine()public byte nextByte()public byte nextByte(int radix)public short nextShort()public long nextLong()public float nextFloat()public double nextDouble()public BigInteger nextBigInteger()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hasNextInt"><a href="#hasNextInt" class="headerlink" title="hasNextInt()"></a>hasNextInt()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。public boolean hasNext()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>此方法可用于合法性判断</p></blockquote><p>案例</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        if (sc.hasNextInt()) {            System.out.println(sc.nextInt());        } else {            System.out.println("输入的数据类型有误");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他相关方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean hasNext()public boolean hasNextLine()public boolean hasNextBoolean()public boolean hasNextByte()public boolean hasNextShort()public boolean hasNextLong()public boolean hasNextFloat()public boolean hasNextDouble()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩展：回车换行问题"><a href="#扩展：回车换行问题" class="headerlink" title="扩展：回车换行问题"></a>扩展：回车换行问题</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int num = sc.nextInt();        String str = sc.nextLine();        System.out.println("str:" + str + "，num:" + num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当从键盘录入第一个数字后，敲下的回车键实际是两个字符：\r\n，所以键盘实际是录入了这两个字符并且结束，显示的效果和没有录入字符串相同</p><p>补充：</p><p>\r：回车，回到行首</p><p>\n：换行</p><p>电脑上的回车键(Enter键)实际上是回车式换行，会先执行回车，后执行换行</p></blockquote><p>扩展：多行录入</p><p>可以通过hasNext的重载方法来实现多行录入</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 如果从键盘录入指定的pattern标记，则返回true，否则返回falsepublic boolean hasNext(String pattern)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        StringBuffer sb = new StringBuffer();        // 将#作为结束的标记，当遇到#时结束循环        while (!sc.hasNext("#")) {            sb.append(sc.next());        }        System.out.println(sb);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Scanner 通过标准输入流来从键盘输入，后期不会用到，目前常用的方法为nextXxx()和hasNextXxx()</p></blockquote><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><blockquote><p>静态常量，全大写，通过类名调用</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 比任何其他值都更接近 e（即自然对数的底数）的 double 值public static final double E = 2.7182818284590452354;// 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值public static final double PI = 3.14159265358979323846;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>构造方法私有化，不能创建对象</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">private Math() {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><blockquote><p>所有方法全部都被 static 修饰，可以通过类名直接调用</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取绝对值public static int abs(int a)// 对数据进行向上取整public static double ceil(double a)// 对数据进行向下取整public static double floor(double a)// 获取最大值public static int max(int a,int b) // 获取最小值public static int min(int a, int b)// 获取a的b次幂public static double pow(double a,double b)// 随机数，范围：[0.0, 1.0)，注意左闭右开，包含左边不包含右边，public static double random()// 四舍五入public static int round(float a)// 获取正平方根public static double sqrt(double a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.fc.r.math;public class MathDemo1 {    public static void main(String[] args) {        // 自然对数的底        System.out.println("Math.E:" + Math.E);        // π        System.out.println("Math.PI:" + Math.PI);        System.out.println("-----------------");        // 绝对值        System.out.println("abs:" + Math.abs(-1));        System.out.println("abs:" + Math.abs(1));        System.out.println("-----------------");        // 向上取整        System.out.println("ceil:" + Math.ceil(12.34));        System.out.println("ceil:" + Math.ceil(12.56));        System.out.println("-----------------");        // 向下取整        System.out.println("floor:" + Math.floor(12.34));        System.out.println("floor:" + Math.floor(12.56));        System.out.println("-----------------");        // 最大最小值        System.out.println("max:" + Math.max(12.34, 56.78));        System.out.println("max:" + Math.max(12.34, Math.max(56.78, 100)));        System.out.println("min:" + Math.min(12.34, 56.78));        System.out.println("-----------------");        // a的b次方        System.out.println("pow:" + Math.pow(2, 10));        System.out.println("-----------------");        // 随机数1~10        System.out.println("random:" + (int) (Math.random() * 10 + 1));        System.out.println("-----------------");        // 四舍五入        System.out.println("round:" + Math.round(12.34));        System.out.println("round:" + Math.round(12.56));        System.out.println("-----------------");        // 获取正平方根        System.out.println("sqrt:" + Math.sqrt(16));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>Java泛型是JavaSE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型在定义的时候是宽泛的，而在使用的时候是确定的。可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><h4 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、提高了程序的安全性(类型安全)2、提高了程序的可扩展性、可重用性3、将运行期遇到的问题转移到了编译期4、省去了类型强转的麻烦(Object类对象)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型格式"><a href="#泛型格式" class="headerlink" title="泛型格式"></a>泛型格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">泛型标识符：<自定义无意义英文大写单字母占位符>    常用格式：                <T> Type         <E> Element        <K> Key        <V> Value泛型类：把泛型定义在类上    格式:class 类名<泛型类型1,…>        【注意】泛型类型必须是引用类型泛型方法：把泛型定义在方法上    格式:public <泛型类型> 返回类型 方法名(泛型类型 .)泛型接口：把泛型定义在接口上    格式:public  interface 接口名<泛型类型1…><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>案例代码1</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityMethodDemo {    public static void main(String[] args) {        System.out.println(getData(100));        System.out.println(getData("Java"));        System.out.println(getData('A'));        System.out.println(getData(false));    }    /**     * 泛型方法     * 格式：     *         泛型限定符 返回值类型 方法名(泛型类型 参数名) {}     *      * @param <T> 泛型限定符     * @param t 任意类型的参数     * @return 返回任意类型参数     */    public static <T> T getData(T t) {        return t;    } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityMethodDemo2 {    public static void main(String[] args) {        Integer[] intArr = {1, 2, 3};        String[] stringArr = {"4", "5", "6"};        // 自定义学生类，其中包含name和age两个成员变量        Student[] students = {new Student("张三", 1), new Student("李四", 2), new Student("王五", 3)};        printArray(intArr);        printArray(stringArr);        printArray(students);    }    /**     * 遍历任意类型的数组     *      * @param <T> 泛型限定符     * @param t 任意类型的数组     */    public static <T> void printArray(T[] t) {        for (int i = 0; i < t.length; i++) {            System.out.println(t[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、要求形式参数列表中必须有一个参数是当前自定义泛型，因为需要通过参数来约束当前方法运行过程中泛型对应的具体数据类型是哪一个2、返回值类型可以使用自定义泛型，而且是被形式参数列表中传入的泛型对应具体的数据类型控制3、方法体内也可以使用自定义泛型，同时也是被参数当中泛型对应具体数据类型约束监控<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityClassDemo {    public static void main(String[] args) {        Number<Integer> num1 = new Number<Integer>(100);        Number<String> num2 = new Number<String>("100");        System.out.println(num1.getT());        System.out.println(num2.getT());    }}/** * 泛型类，把泛型定义到类上，整个类内都可以使用。是对泛型方法的封装 * @param <T> 泛型标识符 */class Number<T> {    private T t;    // Constrator、setters、getters}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、类内可以直接使用对应的类名声明泛型2、类内使用的泛型具体数据类型是在创建当前类对象时约束3、在创建当前类对象时没有约束泛型对应的具体数据类型，那么所有使用到泛型的位置都是Object类型，有悖于泛型使用原则4、如果类声明过了泛型，那么类中所有使用此泛型的方法都同时被声明，即无法使用其他类型5、泛型类中定义的静态方法不能直接使用类声明的泛型，因为泛型需要在创建对象时声明，而静态方法在类加载时就加载完成，此时泛型还没有声明。如果静态方法想要使用泛型，只能自己声明自己使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>案例代码1</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface USB {}class Mouse implements USB {}class Keyboard implements USB {}interface PC<T> {    // 接口中的常量不能使用泛型    T use(T t);}/* *  实现类实现接口时不指定泛型类型, *  需要在创建对象时明确 */class MyPC<T> implements PC<T> {    @Override    public T use(T t) {        return t;    }}/* * 实现类实现接口时，接口中泛型的类型已经明确， * 实现的方法也是明确的 */class YourPC implements PC<Mouse> {    @Override    public Mouse use(Mouse t) {        return t;    }}public class GenericityInterfaceDemo {    public static void main(String[] args) {        // 创建对象时明确泛型的类型        MyPC<Keyboard> myPC = new MyPC<Keyboard>();        Keyboard keyboard = myPC.use(new Keyboard());        System.out.println(keyboard);        System.out.println("-----------------");        // 声明类时已经明确泛型的类型，所以这里的类型已经是明确的        YourPC yourPC = new YourPC();        Mouse mouse = yourPC.use(new Mouse());        System.out.println(mouse);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 自定义一个比较器接口 * @param <T> 泛型 */interface Comparable<T> {    /**     * 这是一个比较方法，实现类应该实现这个方法以达到比较的目的     *      * @param t 传入被比较的对象     * @return 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。     */    public abstract int compareTo(T t);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 自定义父类，实现比较器接口 */class Father implements Comparable<Father>{    private String name;    private int age;    // Constrator、setters、getters    @Override    public int compareTo(Father f) {        return this.age - f.age;    }}public class GenericityInterfaceDemo {    public static void main(String[] args) {        Father father1 = new Father("小明父亲", 30);        Father father2 = new Father("小红父亲", 29);        if (father1.compareTo(father2) < 0) {            System.out.println("小红父亲年长：" + father2.getAge());        } else {            System.out.println("小明父亲年长：" + father1.getAge());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、接口中的成员变量不能使用泛型，因为static、final2、泛型接口的实现类可以指定泛型的类型，也可以不指定，如果在实现类中明确了数据类型，创建对象时就不需要再进行明确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><blockquote><p>在泛型中，？ 表示未知类型，被称为通配符。通配符可以在各种情况下使用：可以作为形式参数、成员变量、局部变量的类型，也可以作为返回值类型。但是，通配符不能用于泛型方法调用、泛型类实例创建对象或者父类的类型实际参数</p></blockquote><p>表示全部类型，类似Object。区别于T，T只是占位符，而 ？是数据类型</p><pre class="line-numbers language-lang-java"><code class="language-lang-java"><?><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【使用场景】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、当一个方法可以用Object类提供的功能来实现时，泛型通配符是使用的2、若代码使用了泛型类中的方法，而这些方法又是不依赖于参数化类型的，可以使用泛型通配符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Grade<T> {    private T t;    // Constructor、setter and getter、toString    public void show() {        System.out.println("show" + this);    }}class School {    // 这里使用泛型通配符，表示可以传入任意类型    public void showGrade(Grade<?> grade) {        grade.show();    }}public class GenericityWildCardDemo {    public static void main(String[] args) {        School school = new School();        school.showGrade(new Grade<Student>(new Student()));        school.showGrade(new Grade<Teacher>(new Teacher()));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型上限"><a href="#泛型上限" class="headerlink" title="泛型上限"></a>泛型上限</h4><p>表示以T为父类的所有子类（包括父类）</p><p><code>&lt;? extends T&gt;</code></p><h4 id="泛型下限"><a href="#泛型下限" class="headerlink" title="泛型下限"></a>泛型下限</h4><p>表示以E为子类的所有父类（包括子类）</p><p><code>&lt;? super E&gt;</code></p><pre><code>class School {    public void showGrade(Grade&lt;?&gt; grade) {        grade.show();    }    // 泛型上限，Person类本身及其子类都可以使用    public void showExtends(Grade&lt;? extends Person&gt; grade) {        System.out.println(grade);    }    // 泛型下限，Person类本身及其父类都可以使用    public void showSuper(Grade&lt;? super Person&gt; grade) {        System.out.println(grade);    }}public class GenericityWildCardDemo {    public static void main(String[] args) {        School school = new School();        school.showGrade(new Grade&lt;Student&gt;(new Student()));        school.showGrade(new Grade&lt;Teacher&gt;(new Teacher()));        // 泛型上限，可以声明子类的类型        school.showExtends(new Grade&lt;Student&gt;());        // 泛型下限，可以声明父类的类型        school.showSuper(new Grade&lt;Object&gt;());    }}</code></pre><h3 id="泛型推断"><a href="#泛型推断" class="headerlink" title="泛型推断"></a>泛型推断</h3><blockquote><p>JDK1.7新特性，可以省略实例化对象时尖括号内的类型</p></blockquote><p>案例代码</p><pre><code>public class GenericityInferDemo {    public static void main(String[] args) {        // 泛型推断        Grade&lt;Student&gt; grade = new Grade&lt;&gt;();        // 得到对应的类型        Student student = grade.getT();    }}</code></pre><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、泛型就是泛化的类型，本质是参数化类型，是jdk1.5引入的新特性，用在类、接口和方法上，即泛型类，泛型接口和泛型方法</p><p>2、为了解决利用继承Object来实现通用性导致的强制类型转换和可能发生的类型转换异常的问题。</p><p>3、泛型的好处是确保了编译时期的类型安全，和避免了强制类型转换的麻烦</p><p>4、缺陷是因为泛型使用了类型擦除机制，jvm运行之前会将泛型信息擦除掉，这样做是为了兼容jdk1.5之前的代码，但是也会导致通过反射可以跳过泛型的问题，因为运行期间并没有泛型的限制</p><p>5、泛型通配符？代表任意类型，泛型上限&lt;? extends T&gt;，泛型下限&lt;? super T&gt;</p><p>6、jdk1.7新特性泛型推断，声明变量时定义过泛型得话，在实例化对象时可以省略类型，但是还要加&lt;&gt;，否则还是原类型</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="学习要求-1"><a href="#学习要求-1" class="headerlink" title="学习要求"></a>学习要求</h3><blockquote><p>抄！！！！！！！！！！！！！！！</p></blockquote><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Collection<E> Java中所有集合的总接口--| interface List<E> List接口，数据存储可重复，有序----| class ArrayList<E>     重点 可变长数组----| class LinkedList<E>     重点 双向链表模式----| class Vector<E>    线程安全的可变长数组--| interface Set<E> Set接口，数据存储不可以重复，无序----| class HashSet<E>     底层存储数据的结构是一个哈希表，存储效率，查询效率极高！！！----| class TreeSet<E>     底层存储数据的结构是一个平衡二叉树结构，要求数据必须有比较方式！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201116155514.jpg" alt="集合框架关系图"></p><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><blockquote><p>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些  collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何<em>直接</em>  实现：它提供更具体的子接口（如 <code>Set</code> 和 <code>List</code>）实现。此接口通常用来传递  collection，并在需要最大普遍性的地方操作这些 collection。 </p></blockquote><h3 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean add(E e);    添加当前集合约束的指定数据类型到当前集合中boolean addAll(Collection<? extends E> c);    添加另一个集合到当前集合中，要求添加集合中保存的元素必须是当前集合中保存    元素本身或者其子类对象 【泛型的上限】    class Dog extends Animal    class Cat extends Animal    class Tiger extends Animal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        System.out.println(collection1);    // [Java, Hello]        collection1.addAll(collection2);                System.out.println(collection1);    // [Java, Hello, Java, Hello, World]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean remove(Object obj);    删除集合中的指定元素，删除成功返回true,未找到指定元素，无法删除返回    false，并且在多个元素的情况下，删除找到的第一个元素。boolean removeAll(Collection<?> c);    在当前集合中删除两个集合的交集boolean retainAll(Collection<?> c);    在当前集合中保留两个集合的交集void clear();    清空整个集合中的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestRemove {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        collection1.remove("Hello");        System.out.println(collection1);    // [Java]        collection2.removeAll(collection1);        System.out.println(collection2);    // [Hello, World]        collection1.add("Hello");        collection1.containsAll(collection2);        System.out.println(collection1);    // [Java, Hello]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    有效元素个数boolean isEmpty();    判断当前集合是否为空，是否存在有效元素boolean contains(Object obj);    判断指定元素是否在当前集合中存在boolean containsAll(Collection<?> c);    判断传入的参数集合是不是当前集合的子集合Object[] toArray();    返回集合中所有保存元素的Object类型数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestGet {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        System.out.println(collection1.size());    // 2        System.out.println(collection1.isEmpty());    // fasle        System.out.println(collection1.contains("Java"));    //true        System.out.println(collection2.containsAll(collection1));    // true        Object[] array = collection1.toArray();        for (int i = 0; i < array.length; i++) {            System.out.println(array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>是用来获取集合中元素的另一种方式（遍历），依赖于集合存在</p><h4 id="获取迭代器的方法"><a href="#获取迭代器的方法" class="headerlink" title="获取迭代器的方法"></a>获取迭代器的方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">Iterator<E> iterator();    获取迭代器对象，泛型对应的具体数据类型和集合中约束的泛型具体数据类型一致。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean hasNext();    判断当前集合中是否可以继续得到元素，(是否可以继续遍历)E next();    1. 获取迭代器当前指向的元素    2. 将迭代器指向下一个元素void remove();    删除通过next方法获取到元素        【注意】        1、remove方法只能删除next方法获取到元素        2、remove方法只能在next方法之后执行，且不能跨过一个next执行        3、没有next不能使用remove<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Collection<String> c = new ArrayList<String>();        c.add("雪花纯生");        c.add("修道院啤酒");        c.add("1664");        c.add("泰山精酿");        c.add("时光精酿");        /*         * 根据当前集合，获取对应的迭代器对象         *          * 得到的迭代器对象会依据，当前集合中的所有元素进行一个规划操作。         * 迭代器对于整个集合中的元素都是存在预期。         */        Iterator<String> iterator = c.iterator();        /*         * 迭代器遍历，利用迭代器的特征进行遍历操作         */        while (iterator.hasNext()) {            // 获取每一个迭代器指向元素，并且展示            String string = iterator.next();            System.out.println(string);            /*             * 通过集合对象本身删除1664，对于迭代器而言，一脸懵逼，原本的规划             * 没有了！！！并且集合没有告知迭代器数据发生了改变，迭代器继续按照             * 原本的规划路径操作，保存！！！             *              * 对于集合在内存中占用的空间而言             *     1. 集合对应的引用数据类型变量可以操作对应空间             *     2. 迭代器可以操作对应的空间             *              * 对于集合和迭代器而言，【集合在内存中占用的空间】共享资源，在操作             * 共享资源过程中，我们要多多考虑共享资源的冲突问题。             * 后面课程中会讲到【多线程】             */            c.remove("1664");        }        /*         Exception in thread "main" java.util.ConcurrentModificationException                at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)                at java.util.ArrayList$Itr.next(ArrayList.java:859)                at com.qfedu.b_iterator.Demo3.main(Demo3.java:30)         */    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>有序的 Collection ，可以根据索引操作元素，数据可重复</p><blockquote><p>ArrayList</p><p>​    可变长数组</p><p>LinkedList</p><p>​    双向链表</p><p>Vector</p><p>​    线程安全的可变长数组</p></blockquote><h3 id="增加方法-1"><a href="#增加方法-1" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean add(E e);        List接口继承Collection接口 add方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】boolean add(int index, E e);    List接口【特有方法】，在指定位置，添加指定元素boolean addAll(Collection<? extends E> c);    List接口继承Collection接口 addAll方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】boolean addAll(int index, Collection<? extends E> c);    List接口【特有方法】，在指定下标位置，添加另一个集合中所有内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        List<String> arrayList = new ArrayList<String>();        arrayList.add("Hello");        arrayList.add("World");        arrayList.add("Android");        arrayList.add(0, "Java");        System.out.println(arrayList);        List<String> al = new ArrayList<String>();        al.add("ArrayList是线程不安全的可变长数组");        al.add("LinkedList是双向链表：增删快，查询慢");        al.addAll(arrayList);        System.out.println(al);        arrayList.addAll(0, al);        System.out.println(arrayList);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">E remove(int index);    List接口【特有方法】，获取指定下标位置的元素并删除boolean remove(Object obj);    List接口继承Collection接口方法。删除集合中的指定元素boolean removeAll(Collection<?> c);    List接口继承Collection接口方法。删除当前集合中和参数集合重复元素boolean retainAll(Collection<?> c);    List接口继承Collection接口方法。保留当前集合中和参数集合重复元素clear();    List接口继承Collection接口方法。清空整个集合中的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestRemove {    public static void main(String[] args) {        List<Integer> al = new ArrayList<Integer>();        al.add(1);        al.add(2);        al.add(3);        al.add(4);        System.out.println("删除指定下标位置为0的元素： " + al.remove(0));        System.out.println("al : " + al);        List<Integer> al1 = new ArrayList<Integer>();        al1.add(4);        al1.add(5);        al1.add(6);        System.out.println("al.removeAll(al1) : " + al.removeAll(al1));        System.out.println("al : " + al);        List<Integer> al2 = new ArrayList<Integer>();        al2.add(5);        al2.add(7);        al2.add(6);        System.out.println("al1.reatinAll(al2) : " + al1.retainAll(al2));        System.out.println("al1 ： " + al1);        al2.clear();        System.out.println("al2.clear() ： " + al2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">E set(int index, E e);    List接口【特有方法】，使用指定元素替代指定下标的元素，返回值是被替换的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestModify {    public static void main(String[] args) {        List<Character> al = new ArrayList<Character>();        al.add('A');        al.add('B');        al.add('C');        al.set(0, 'M');        System.out.println(al); // [M, B, C]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询方法-1"><a href="#查询方法-1" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    List接口继承Collection接口方法。获取集合中有效元素个数boolean isEmpty();    List接口继承Collection接口方法。判断当前集合是否为空boolean contains(Object obj);    List接口继承Collection接口方法。判断指定元素是否包含在当前集合中boolean containsAll(Collection<?> c);    List接口继承Collection接口方法。判断参数集合是不是当前集合在子集合Object[] toArray();    List接口继承Collection接口方法。获取当前集合中所有元素Object数组E get(int index);    List接口【特有方法】。获取指定下标对应的元素List<E> subList(int fromIndex, int toIndex);    List接口【特有方法】。获取当前集合指定子集合，从fromIndex开始，到toIndex结束。fromIndex <= 范围 < toIndex [)int indexOf(Object obj);    List接口【特有方法】。获取指定元素在集合中第一次出现位置int lastIndexOf(Object o);    List接口【特有方法】。获取指定元素在集合中最后一次出现的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestGet {    public static void main(String[] args) {        List<String> al = new ArrayList<String>();        al.add("Hello");        al.add("World");        al.add("Java");        al.add("Android");        al.add("Hello");        List<String> al2 = new ArrayList<>();        al2.add("Java");        al2.add("Hello");        System.out.println(al.size()); // 4        System.out.println(al.isEmpty()); // false        System.out.println(al.contains("Java")); // true        System.out.println(al.containsAll(al2)); // true        Object[] array = al.toArray();        for (Object str : array) {            System.out.println(str);        }        System.out.println(al.indexOf("World")); // 1        System.out.println(al.lastIndexOf("Hello")); // 4        System.out.println(al.get(0)); // Hello        System.out.println(al.subList(1, 3)); // [World, Java]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">void ensureCapacity(int minCapacity);    如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。trimToSize();    将此 ArrayList 实例的容量调整为列表的当前大小。节省空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><blockquote><p>增删慢，查询快</p></blockquote><pre><code>增删慢    增加慢        1、数组当前容量无法满足添加操作，需要进行grow扩容方法执行，在扩容方法中，存在数组创建，数组数据拷贝。非常浪费时间，而且浪费内存。        2、数组在添加数据的过程中，存在在指定位置添加元素，从指定位置开始，之后的元素整体向后移动。    删除慢        1、删除数据之后，从删除位置开始，之后的元素整体向前移动，移动过程非常浪费时间        2、删除操作会导致数据空间的浪费，内存的浪费    查询快        ArrayList 底层是一个数组结构，在查询操作的过程中，是按照数组+下标的方式来操作对应的元素，数组+下标方式可以直接获取对应的空间首地址，CPU访问效率极高。</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><blockquote><p>底层数据结构是一个双向链表，查询慢，增删快</p></blockquote><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>LinkedList使用的方法都是从List接口实现而来的方法，需要了解的是LinkedList特有方法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void addFirst(E e);    在当前链表开始位置加元素void addLast(E e);    在当前链表末尾添加元素E getFirst();    获取第一个Node节点元素数据E getLast();    获取末尾Node节点元素数据E removeFirst();    删除头节点E removeLast();    删除末尾节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        LinkedList<String> linkedList = new LinkedList<String>();        linkedList.add("Buffer");        linkedList.add("Balance");        linkedList.add("Wizard");        linkedList.add("Blanche");        linkedList.add("Eve");        linkedList.addFirst("Hello");        linkedList.addLast("World");        System.out.println(linkedList.getFirst());    // Buffer        System.out.println(linkedList.getLast());    // Eve        System.out.println(linkedList);    // [Hello, Buffer, Balance, Wizard, Blanche, Eve, World]        System.out.println("移除头元素" + linkedList.removeFirst());    // 移除头元素Hello        System.out.println("移除尾元素" + linkedList.removeLast());    // 移除尾元素World        System.out.println(linkedList);    // [Buffer, Balance, Wizard, Blanche, Eve]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><blockquote><p>一个不包含重复元素的 Collection。存储元素的顺序无序。（注意区分添加顺序和存储顺序）</p></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><blockquote><p>底层数据结构是哈希表，依赖 equals 方法和 hashCode 方法实现不可重复</p></blockquote><p>学生类：需要重写 equals() 和 hashCode()</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    // Construator setter/getter toString    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Set<Student> hashSet = new HashSet<Student>();        hashSet.add(new Student("Buffer", 23));        hashSet.add(new Student("Smoot", 22));        hashSet.add(new Student("Wizard", 23));        hashSet.add(new Student("Buffer", 23));        hashSet.add(new Student("Buffer", 20));        hashSet.add(new Student("Balance", 21));        for (Student student : hashSet) {            System.out.println(student);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Student [name=Smoot, age=22]Student [name=Wizard, age=23]Student [name=Balance, age=21]Student [name=Buffer, age=23]Student [name=Buffer, age=20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>hashSet底层哈希表结构存储元素时，会首先得到当前元素的哈希值，需要执行调用对应的hashCode方法，hash方法中存在一个【移位运算】，一种特殊运算方式，用于根据当前对象的hashCode结果，计算该元素在底层哈希表中的存储位置。</p><p>【重点】如果元素hashCode值结果一致，那么它们保存对应的位置应该是一致的，会存入同一个空间，但是会进行equals比较，对象相同，【无法添加，对象不同，可以添加，但是需要避免】</p></blockquote><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><blockquote><p>基于 TreeMap 的 NavigableSet  实现，底层数据结构是平衡二叉树。使用元素的自然顺序对元素进行排序（Comparable），或者根据创建 set 时提供的 Comparator  进行排序，具体取决于使用的构造方法。</p></blockquote><p>Person 类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package code.treeset;public class Person {    private String name;    private int age;    // Constructor setter/getter toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator 接口实现类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyCompare implements Comparator<Person> {    // 通过年龄判断是否为同一个 Person    @Override    public int compare(Person o1, Person o2) {        return o1.getAge() - o2.getAge();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestPerson {    public static void main(String[] args) {        // 创建 TreeSet 集合时传入一个 Comparator 接口的实现类        TreeSet<Person> treeSet = new TreeSet<Person>(new MyCompare());        treeSet.add(new Person("Smoot", 22));        treeSet.add(new Person("Buffer", 23));        treeSet.add(new Person("Wizard", 23));        treeSet.add(new Person("Balance", 21));        System.out.println(treeSet);    // [Person [name=Balance, age=21], Person [name=Smoot, age=22], Person [name=Buffer, age=23]]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map 接口允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection  视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap  类。</p><p>【重点】将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface Map<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Map<K, V> --| class HashMap<K, V>     重点！！！底层是哈希表--| class TreeMap<K, V>    底层是红黑树<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加方法-2"><a href="#增加方法-2" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V put(K key, V value);    添加符合Map要求的键值对存入到双边队列中void putAll(Map<? extends K, ? extends V> map)    添加另一个Map到当前Map中，要求K是当前Map本身对应的K，或者其子类，V是当前Map本身对应的V，或者其子类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-2"><a href="#删除方法-2" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V remove(Object key);     删除对应Key键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改方法-1"><a href="#修改方法-1" class="headerlink" title="修改方法"></a>修改方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V put(K key, V value);    使用value修改已存在的key对应的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查询方法-2"><a href="#查询方法-2" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    Map双边队列个数boolean isEmpty();    判断当前Map双边队列中是否为空boolean containsKey(Object key);    判断指定Key是否存在boolean containsValue(Object value);    判断指定Value是否存在Set<K> keySet();    返回Map双边队列中所有Key对应的Set集合Collection<V> values();    返回Map双边队列中所有value对应Collection集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Map-中的-Entry"><a href="#Map-中的-Entry" class="headerlink" title="Map 中的 Entry"></a>Map 中的 Entry</h3><blockquote><p>Map双边队列中把 Key 和 Value 进行一个封装操作，完全按照一个数据类型来处理。是 Map 中的一个成员接口，用于获取对应的键和值（参考Collection中的迭代器）</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Map.Entry<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Set<Map.Entry<K, V>> entrySet();    返回值类型是Entry键值对形式数据的Set集合Set<Map.Entry<K, V>>    Map.Entry<K, V> Map接口的内部接口Entry，使用的泛型 K,V对应Map创建过程中约束的K,V    因为返回值是Set集合，集合带有泛型 Set<Map接口中的内部接口Entry>Entry 对应的方法    K getKey();        返回与此项对应的键    V getValue();        返回与此项对应的值。    V setValue(V value);        用指定的值替换与此项对应的值，返回与此项对应的旧值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestEntry {    public static void main(String[] args) {        Map<String, Integer> map = new HashMap<String, Integer>();        map.put("Buffer", 23);        map.put("Balance", 23);        map.put("Amy", 32);        Set<Entry<String, Integer>> entrySet = map.entrySet();        for (Entry<String, Integer> entry : entrySet) {            System.out.println(entry.getKey() + " setVaule: " + entry.setValue(16));            System.out.println(entry.getKey() + " : " + entry.getValue());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null  键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class HashMap<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestHashMap {    public static void main(String[] args) {        Map<String, Integer> map = new HashMap<String, Integer>();        map.put("Buffer", 23);        map.put("Balance", 23);        map.put("Amy", 32);        System.out.println(map);        HashMap<String, Integer> hashMap = new HashMap<>();        hashMap.put("Candy", 33);        hashMap.put("David", 29);        hashMap.putAll(map);        System.out.println(hashMap);        hashMap.remove("Balance");        System.out.println(hashMap);        hashMap.put("Buffer", 16);        System.out.println(hashMap);        System.out.println("map.size() :" + map.size());        System.out.println("map.isEmpty() : " + map.isEmpty());        System.out.println("have Buffer : " + map.containsKey("Buffer"));        System.out.println("have Buffer's age : " + hashMap.containsValue(16));        Set<String> keySet = map.keySet();        System.out.println(keySet);        Collection<Integer> values = map.values();        System.out.println(values);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】HashMap 添加自定义数据类型元素时需要重写其 equals 和 hashCode 方法</p></blockquote><p>学生类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    private char sex;    // Constructor setter getter toString equals hashCode}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestMap2 {    public static void main(String[] args) {        Map<Student, Integer> hashMap = new HashMap<Student, Integer>();        hashMap.put(new Student("Buffer", 23, '男'), 1);        hashMap.put(new Student("Balance", 23, '男'), 2);        hashMap.put(new Student("Buffer", 22, '男'), 3);        hashMap.put(new Student("Buffer", 23, '女'), 4);        hashMap.put(new Student("Buffer", 23, '男'), 5);        Set<Entry<Student, Integer>> entrySet = hashMap.entrySet();        for (Entry<Student, Integer> entry : entrySet) {            System.out.println(entry);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Student [name=Balance, age=23, sex=男]=2Student [name=Buffer, age=23, sex=女]=4Student [name=Buffer, age=22, sex=男]=3Student [name=Buffer, age=23, sex=男]=5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote><p>基于红黑树（Red-Black tree）的 NavigableMap  实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator  进行排序，具体取决于使用的构造方法。 </p></blockquote><p>学生类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    private char sex;    // Constructor and setter、getter}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator 接口实现类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyCompare implements Comparator<Student> {    /**     * 返回两个学生的年龄差     */    @Override    public int compare(Student o1, Student o2) {        return o1.getAge() - o2.getAge();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><blockquote><p>文件和目录路径名的抽象表示形式，提供了对文件和文件夹的增删改查的方法</p></blockquote><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">File(String pathName);    根据指定的文件路径，或者文件夹路径，创建对应的File类对象。路径可以是相对路径，可以是绝对路径File(String parent, String childName);    根据指定的父目录文件夹路径，和子文件或者子文件夹的名字，创建对应的File类对象File(File parent, String childName);    根据指定的父目录File类对象，和子文件或者子文件夹的名字，创建对应的File类对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】如果是文件必须要有后缀名，否则就是文件夹</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file1 = new File("D:/aaa");        File file2 = new File("D:/aaa", "1.txt");        File file3 = new File(file1, "1.txt");        System.out.println(file1);    // D:\aaa        System.out.println(file2);    // D:\aaa\1.txt        System.out.println(file3);    // D:\aaa\1.txt    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean createNewFile();    通过File类对象调用，创建File类对象中对应地址的普通文件，创建成功返回true，创建失败返回false;    失败原因:        1. 路径不合法，路径不存在，路径错误。        2. 对应文件夹没有写入权限。        3. 对应文件已存在。        4. 磁盘坏道，电脑蓝屏。boolean mkdir();    通过File类对象创建，创建File类对象中对应的文件夹，创建成功返回true，失败返回false    失败原因:        1. 路径不合法，路径不存在，路径错误。        2. 对应文件夹没有写入权限。        3. 对应文件夹已存在。        4. 磁盘坏道，电脑蓝屏。boolean mkdirs();    创建文件夹过程中可以完成中间路径boolean renameTo(File dest);    通过File类对象调用，转为目标dest指定File类对象，可以操作普通文件，可以操作文件夹。移动或者重命名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        File file1 = new File("C:/Users/CJF/Desktop/啥啥啥.txt");        boolean createNewFile = file1.createNewFile();        System.out.println(createNewFile);        File file2 = new File("C:/Users/CJF/Desktop/啥啥啥");        boolean mkdir = file2.mkdir();        System.out.println(mkdir);        File file3 = new File("C:/Users/CJF/Desktop/啥啥啥/afaf/aggr/htedfgb/er");        boolean mkdirs = file3.mkdirs();        System.out.println(mkdirs);        File file4 = new File("C:/Users/CJF/Desktop/什么鬼.txt");        boolean renameTo = file1.renameTo(file4);        System.out.println(renameTo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-3"><a href="#删除方法-3" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean delete();    通过File类对象调用，删除File类对象对应的文件或者文件夹。    注意事项:        1. 从磁盘中直接抹掉数据，不经过回收站，慎用        2. 删除操作只针对于空文件夹操作，不能删除非空文件夹void deleteOnExit();    程序退出之后，删除调用该方法File类对象，对应的普通文件或者文件夹。    用于缓冲文件，缓存问题，日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        File file = new File("C:/Users/CJF/Desktop/Test.txt");        System.out.println(file.createNewFile());    // true        System.out.println(file.delete());    // true        file.deleteOnExit();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">前三个方法和文件或者文件夹是否存在无关。String getPath();    获取File类对象中保存的路径String getName();    获取File类对象操作对应的文件名或者文件夹名String getParent();    获取File类对象操作文件或者文件夹的上级目录String getAbsolutePath();    获取当前File类对象对应路径的绝对路径long length();    获取当前【文件】的占用磁盘空间字节数    根据不同的系统环境，文件夹调用length方法 0L 或者 4096Llong lastModified();    获取当前文件夹上一次修改时间的【时间戳】    是从计算机元年1970-01-01 00:00:00 到修改时间的秒数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("D:/aaa/bbb/ccc/1.txt");        System.out.println(file.getPath());    // D:\aaa\bbb\ccc\1.txt        System.out.println(file.getParent());    // D:\aaa\bbb\ccc        System.out.println(file.getName());    // 1.txt        System.out.println(file.length());    // 0        System.out.println(file.lastModified());// 0        System.out.println(new File(".").getAbsolutePath());    // D:\Qfeng\day27\.    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean isFile();    判断当前File类对象对应的是不是普通文件。boolean isDirectory();    判断当前File类对象对应的是不是文件夹。boolean exists();    判断当前File类对象对应的内容是否存在。boolean isAbsolute();    判断当前File类对象保存的路径是不是绝对路径。boolean isHidden();    判断当前File类对象对应的文件是不是一个隐藏文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestFileDecide {    public static void main(String[] args) {        File file = new File("D:/Adobe");        System.out.println(file.exists());    // true        System.out.println(file.isFile());    // false        System.out.println(file.isDirectory());    // true        System.out.println(file.isAbsolute());    // true        System.out.println(file.isHidden());    // false    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">static File[] listRoots();        获取Windows操作系统下的所有盘符    Linux中没有什么作用。String[] list();    获取File类对象对应文件夹中所有子文件或者子文件夹名字，String类型数组File[]    listFiles();    获取File类对象对应文件夹中所有子文件或者子文件夹的File类对象数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("C:/Users/CJF/Desktop");        String[] list = file.list();        for (String fileName : list) {            System.out.println(fileName);        }        File[] listFiles = file.listFiles();        for (File file2 : listFiles) {            System.out.println(file2);        }        File[] listRoots = File.listRoots();        for (File file2 : listRoots) {            System.out.print(file2 + "\t"); // C:\ D:\ E:\        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FilenameFilter-文件名过滤器接口"><a href="#FilenameFilter-文件名过滤器接口" class="headerlink" title="FilenameFilter 文件名过滤器接口"></a>FilenameFilter 文件名过滤器接口</h3><p>实现此接口的类实例可用于过滤文件名。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean accept(File dir, String name);    dir是当前操作获取文件列表的文件夹File类对象    name是当前文件夹下的文件名或者文件夹名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("D:/EclipseWorkSpace/rx1901/src/com/fc/za/file");        String[] fileNameArray = file.list(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return new File(dir, name).isFile() && name.endsWith(".java");            }        });        for (String fileName : fileNameArray) {            System.out.println(fileName);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><blockquote><p>1、IO流用来处理设备之间的数据传输<br>   上传文件和下载文件<br>2、Java对数据的操作是通过流的方式<br>3、Java用于操作流的对象都在IO包中</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">I   input    从硬盘读取数据到内存    read 读O   output    从内存写入数据到硬盘    write 写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">按照数据流向    输入流    读入数据    字节输入流、字符输入流    输出流    写出数据    字节输出流、字符输出流按照数据类型    字节流                字节输入流、字符输出流    字符流                字符输入流、字符输出流class InputStream 字节输入流基类--| class FileInputStream 文件操作字节输入流class OutputStream 字节输出流基类--| class FileOutputStream 文件操作字节输出流class Reader 字符输入流基类--| class FileReader 文件操作字符输入流class Writer 字符输出流基类--| class FileWriter 文件操作字符输出流缓冲流:    BufferedInputStream            字节输入缓冲流    BufferedOutputStream        字节输出缓冲流        BufferedReader            字符输入缓冲流    BufferedWriter            字符输出缓冲流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileInputStream-文件操作字节输入流"><a href="#FileInputStream-文件操作字节输入流" class="headerlink" title="FileInputStream 文件操作字节输入流"></a>FileInputStream 文件操作字节输入流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的文件路径创建对应的FileInputStream，文件操作输入字节流，如果文件不存在，抛出异常FileNotFoundExceptionFileInputStream(String filePath);// 根据用户指定对应文件的File类对象，创建对应的FileInputStream，如果文件不存在，抛出异常FileNotFoundException            FileInputStream(File file);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 从文件中读取一个字节数据返回。如果读取到底末尾，返回-1 EOF End Of Fileint read();// 从文件中读取数据到缓冲数组buf中，返回值类型是从文件中读取到的字节个数，如果读取到文件末尾，返回-1， EOF End Of File 。如果在运行过程中出现了问题，抛出异常IOException       int read(byte[] buf); 【重点，效率高】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确对应文件的路径，可以选择直接给予对应的String类型路径，或者创建对应的File类对象，作为参数2. 创建FileInputStream文件操作字节输入流，打开文件操作管道3. 从FileInputStream对象中使用方法，读取数据4. 关闭资源！！！FileInputStream类对象 ==> 水龙头！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test1 {    public static void main(String[] args) throws IOException {        FileInputStream fileInputStream = new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        int content = fileInputStream.read();        System.out.println((char) content);//        byte[] buf = new byte[1024 * 16];        while (-1 != (content = fileInputStream.read())) {            System.out.print((char)content);        }        fileInputStream.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码二</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test2 {    public static void main(String[] args) throws IOException {        FileInputStream fis = new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        byte[] buf = new byte[1024 * 16];        int count = -1;        while (-1 != (count = fis.read(buf))) {            System.out.println(new String(buf, 0, count));        }        fis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】一般都会使用缓冲数组，因为单个字节读取效率太低了</p></blockquote><h3 id="FileOutputStream-文件操作字节输出流"><a href="#FileOutputStream-文件操作字节输出流" class="headerlink" title="FileOutputStream 文件操作字节输出流"></a>FileOutputStream 文件操作字节输出流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的路径，创建对应的FileOutputStream文件操作输出流对象。如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，再写入数据FileOutputStream(String filePath);// 根据用户指定的File类对象，创建对应FileOutputStream文件操作输出流对象，如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，再写入数据FileOutputStream(File file);// 根据用户指定的路径，创建对应的FileOutputStream文件操作输出流对象。如果路径不合法，抛出异常FileNotFoundException。// append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据FileOutputStream(String filePath, boolean append);// 根据用户指定的File类对象，创建对应FileOutputStream文件操作输出流对象，如果路径不合法，抛出异常FileNotFoundException。// append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据FileOutputStream(File file, boolean append);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 写入一个字节数据写入到文件中void write(int b);// 写入一个字节数组到文件中        void write(byte[] buf);// 写入一个字节数组到文件中，要求从off偏移位置开始，计数count     void write(byte[] buf, int off, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确对应文件的路径，可以选择直接给予对应的String类型路径，或者创建对应的File类对象，作为参数2. 创建FileOutputStream文件操作输出字节流，打开文件操作管道3. 使用FileOutputStream对象写入数据到文件中4. 关闭资源！！！【注意】    1. FileOutputStream拥有创建文件的能力，在路径合法，且对应目录有写入权限下可以创建文件    2. 区分删除写和追加写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        fos.write(97);        System.out.println();        FileOutputStream fos2 = new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"), true);        fos2.write("\n今天是个好天气".getBytes());        fos2.close();        fos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileReader-文件操作字符输入流"><a href="#FileReader-文件操作字符输入流" class="headerlink" title="FileReader 文件操作字符输入流"></a>FileReader 文件操作字符输入流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据指定路径的文件创建对应的文件字符输入流对象，如果文件不存在，抛出异常FileNotFoundExceptionFileReader(String filePath);    // 根据指定路径的File类对象创建文件字符输入流对象，如果文件不存在，抛出异常FileNotFoundExceptionFileReader(File file);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 从文件中读取一个字符数据，返回值为int类型，int类型数据中有且只有低十六位是有效数据，如果读取到文件末尾返回-1 EOF End Of Fileint read();// 从文件中读取数据到char类型缓冲数组buf，返回值是读取到字符个数。如果读取到文件末尾返回-1 EOF End Of Fileint read(char[] buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确需要读取数据的文件2. 创建FileReader对象，打开文件操作管道3. 使用FileReader类对象方法，读取文件数据4. 关闭资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(new File("C:/Users/CJF/Desktop/Test.txt"));        char[] buf = new char[1024 * 16];        int content = -1;        while (-1 != (content = fr.read(buf))) {            System.out.println(new String(buf, 0, content));        }        fr.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileWriter-文件操作字符输出流"><a href="#FileWriter-文件操作字符输出流" class="headerlink" title="FileWriter 文件操作字符输出流"></a>FileWriter 文件操作字符输出流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的路径，创建对应的FileWriter文件操作字符输出流对象。如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，在写入数据FileWriter( String filePath);// 根据用户指定的File类对象，创建对应FileWriter文件操作字符输出流对象，如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，在写入数据FileWriter(File file);// 根据用户指定的路径，创建对应的FileWriter文件操作字符输出流对象。如果路径不合法，抛出异常FileNotFoundException。append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据    FileWriter(String filePath, boolean append);// 根据用户指定的File类对象，创建对应FileWriter文件操作字符输出流对象，如果路径不合法，抛出异常FileNotFoundException。append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据    FileWriter(File file, boolean append);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 写入一个字符数据写入到文件中void write(int ch);// 写入一个字符数组到文件中void write(char[] buf);// 写入一个字符数组到文件中，要求从off偏移位置开始，计数countvoid write(char[] buf, int off, int count);    // 写入一个字符串到文件中void write(String str);// 写入一个字符串到文件中，要求从offset偏移位置开始，计数countvoid write(String str, int offset, int count);【注意】    1. FileWriter拥有创建文件的能力，在路径合法，且对应目录有写入权限下可以创建文件    2. 区分删除写和追加写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(new File("C:/Users/CJF/Desktop/Test.txt"), true);        fw.write("\n今天是520情人节");        fw.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo8 {    public static void main(String[] args) throws IOException {        // 明确操作源文件        File src = new File("D:/EclipseWorkSpace/FC2020/src/com/fc/z/io/a.txt");        // 明确操作源文件        File dest = new File("D:/EclipseWorkSpace/FC2020/src/com/fc/z/io/b.txt");        // 创建读对象        FileInputStream fis = new FileInputStream(src);        // 创建写对象        FileOutputStream fos = new FileOutputStream(dest);        // 缓存        byte[] buf = new byte[1024 * 16];        int content = -1;        // 读取数据并写入        while (-1 != (content = fis.read(buf))) {            fos.write(buf, 0, content);        }        // 关闭资源        fos.close();        fis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><blockquote><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、流程是一样的   明确文件   打开管道   操作文件   关闭资源2、核心方法   read 读取，输入   write 写入，输出3、输出流有创建文件的能力。4、 输出流需要注意是删除写还是追加写。5、输入流有缓冲比没有缓冲效率高很多6、一定要注意关闭资源！！！resource7、一般还是用字节流，避免文件损坏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、缓冲流是Java中提供的系统缓冲，底层都是一个缓冲数组，根据处理的数据方式不同，提供的数据有字节缓冲数组和字符缓冲数组。2、字节缓冲流，默认的字节数组缓冲区是8KB    byte[] buffer = new byte[1024 * 8];3、字符缓冲流，默认的字符数组缓冲区是16KB   char[] buffer = new char[1024 * 8];4、【重点】   任何一个缓冲流都没有任何操作文件的能力！！！读取文件数据，写入文件数据，都是依赖于对应的字符流或者字节流提供的！！！5、缓冲流使用的方法，也是read write 而且是对应创建当前缓冲流使用的字符流或者字节流的！！！6、缓冲流减少了CPU通过内存访问磁盘或者说文件的次数。极大的提高了开发效率。IO流操作文件内容都是在缓冲流内部的缓冲数组中，也就是内存中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><blockquote><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">BufferedInputStream   字节缓冲输入流BufferedOutputStream   字节缓冲输出流BufferedReader   字符缓冲输入流BufferedWriter   字符缓冲输出流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="BufferedInputStream-字节缓冲输入流"><a href="#BufferedInputStream-字节缓冲输入流" class="headerlink" title="BufferedInputStream 字节缓冲输入流"></a>BufferedInputStream 字节缓冲输入流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedInputStream(InputStream in);    这里需要的参数是字节输入流对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>成员方法 Method </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int read();int read(byte[] buf);其实就是InputStream中使用的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedInputStream bis = new BufferedInputStream(                new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt")));        byte[] buf = new byte[1024 * 8];        int count = -1;        while (-1 != (count = bis.read(buf))) {            System.out.println(new String(buf, 0, count));        }        bis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedOutputStream-字节缓冲输出流"><a href="#BufferedOutputStream-字节缓冲输出流" class="headerlink" title="BufferedOutputStream 字节缓冲输出流"></a>BufferedOutputStream 字节缓冲输出流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedOutputStream(OutputStream out);    这里需要一个字节输出流作为方法的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用方法 Method    </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void write(int b);void write(byte[] buf);void write(byte[] buf, int off, int len);以上方法都是OutputStream提供的方法。所有的数据都是首先都是写入保存到BufferedOutputStream 底层操作的数组中，当数组填满以后，或者执行指定的方法，才会将数据之间写入到内存中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"), true));        bos.write("\n今天是个好天气".getBytes());        bos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效率总结"><a href="#效率总结" class="headerlink" title="效率总结"></a>效率总结</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、使用缓冲时间效率是远远高于未使用缓冲情况，这里是一个非常经典的空间换时间概念    缓冲占用内存 16KB 非缓冲 4byte 时间效率大于250倍 空间占用4000倍2、利用代码可以发现，非缓冲IO操作时使用数组作为缓冲区和使用缓冲流操作，时间效率相似。这里还是推荐使用系统提供的缓冲流，更加安全，并且提供了一些其他方法，可以作为一定参考和使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedReader-字符输入缓冲流"><a href="#BufferedReader-字符输入缓冲流" class="headerlink" title="BufferedReader 字符输入缓冲流"></a>BufferedReader 字符输入缓冲流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedReader(Reader in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用方法 Method</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int read();int read(byte[] buf);String readLine(); 【新方法】    从文件中读取一行数据，返回值类型是字符串，如果读取到文件默认，返回null    一行数据??? 结尾标记 \r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new FileReader(new File("C:/Users/CJF/Desktop/Test.txt")));        char[] buf = new char[1024 * 8];        int count = -1;        while (-1 != (count = br.read(buf))) {            System.out.println(new String(buf, 0, count));        }        String content = null;        while (null != (content = br.readLine())) {            System.out.println(content);    // 这里不会再输出，因为上面已经读到文件末尾，即 null == content        }        br.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedWriter-字符输出缓冲流"><a href="#BufferedWriter-字符输出缓冲流" class="headerlink" title="BufferedWriter 字符输出缓冲流"></a>BufferedWriter 字符输出缓冲流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedWriter(Writer in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void write(int ch);void write(char[] buf);    void write(char[] buf, int off, int len);    void write(String str);    void write(String str, int off, int len);    void newLine();     换行写操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedWriter bw = new BufferedWriter(new FileWriter(new File("C:/Users/CJF/Desktop/Test.txt"), true));        bw.write("\n今天又是个好天气");        bw.newLine();        bw.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><blockquote><p>概述：</p><p>​        正在运行的程序，是系统进行资源分配和调用的独立单位</p><p>​        每一个进程都有它自己的内存空间和系统资源</p><p>例如：</p><p>​        打开任务管理器，可以看到电脑中执行的每一个程序，每一个程序就是一个进程</p><p>特点：</p><p>​        1、独立性</p><p>​        2、动态性</p><p>​        3、并发性</p></blockquote><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>概述：        </p><p>​        是进程中的单个顺序控制流，是一条执行路径</p><p>​        一个进程如果只有一条执行路径，则称为单线程程序</p><p>​        一个进程如果有多条执行路径，则称为多线程程序</p><p>例如：</p><p>​        电脑管家就是一个程序 =&gt; 进程</p><p>​        电脑管家可以同时    病毒查杀，垃圾清理，一键加速等功能</p><p>​        这些每个功能都可以看做是线程，它们是同时进行的</p><p>特点：</p><p>​        1、线程是CPU的最小调度单位，CPU可以很快的在多个线程间实现切换。</p><p>​        2、运行时的线程，随时都可以被CPU给挂起。</p><p>​        3、线程的抢占发生在任意时期</p></blockquote><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><blockquote><p>1、一个进程可以有多个线程。但是必须要有一个主线程</p><p>2、进程间不能共享资源，但是线程间可以共享资源。</p><p>3、Java程序中，最少要有两个线程</p><p>​        1、main线程</p><p>​        2、JVM 的 GC 机制，守护线程</p></blockquote><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote><p>并发：两个或者两个以上的事务在同一个时间段发生</p><p>并行：两个或者两个以上的事务在同一个时刻发生</p></blockquote><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><blockquote><p>Java中的一个线程类，同时提供了很多线程的操作使用的方法，我们想要操作线程，必须通过Thread类对象去完成。Thread 类实现了 Runnable 接口，其中的 run 方法中就是我们要被运行的代码。可以通过重写 run 方法，并调用线程的 start 使其运行，以达到我们想要的效果</p></blockquote><h4 id="自定义线程三种方式"><a href="#自定义线程三种方式" class="headerlink" title="自定义线程三种方式"></a>自定义线程三种方式</h4><blockquote><p>1、自定义线程类，继承自 Thread，并重写 run 方法</p><p>2、自定义线程类，传入一个实现了 Runnable 接口的参数【重点】</p><p>3、自定义线程类，传入一个实现了 Callable 接口的参数</p></blockquote><h4 id="继承-Thread-类并重写-run-方法"><a href="#继承-Thread-类并重写-run-方法" class="headerlink" title="继承 Thread 类并重写 run 方法"></a>继承 Thread 类并重写 run 方法</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Thread1 thread1 = new Thread1();        thread1.start();        System.out.println("main线程");    }}class Thread1 extends Thread {    @Override    public void run() {        System.out.println("测试线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        Thread thread = new Thread(new Thread2());        thread.start();    }}class Thread2 implements Runnable {    @Override    public void run() {        System.out.println("测试线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        // 使用匿名内部类和匿名对象        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("测试线程");            }        }).start();        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><blockquote><p>可以有返回值</p><p>可以抛出异常</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test3 {    public static void main(String[] args) throws InterruptedException, ExecutionException {        Callable<Integer> cal = new Callable<Integer>() {            int count = 0;            @Override            public Integer call() throws Exception {                count++;                System.out.println(" Test :" + count);    //  Test :1                return count;            }        };        FutureTask<Integer> future = new FutureTask<Integer>(cal);        Thread thread = new Thread(future);        thread.start();        System.out.println("返回值为：" + future.get());    // 返回值为：1    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三种创建方式的区别"><a href="#三种创建方式的区别" class="headerlink" title="三种创建方式的区别"></a>三种创建方式的区别</h4><pre><code>继承 Thread 类：    编写简单、单继承，所以这种类无法再继承其他类、无法实现多个线程的资源共享、扩展性无实现 Runnable 接口：    编写复杂一点，接口可以多实现，可以实现多个线程的资源共享  推荐使用实现 Callable 接口：    编码复杂，可以实现线程执行完之后进行值的返回</code></pre><blockquote><p>【重点】开发中，需要线程返回值，就使用 Callable，不需要返回值的就可以 Runnable ，最常用的是实现 Runnable</p></blockquote><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="分时调度模型"><a href="#分时调度模型" class="headerlink" title="分时调度模型"></a>分时调度模型</h4><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p><h4 id="抢占式调度模型"><a href="#抢占式调度模型" class="headerlink" title="抢占式调度模型"></a>抢占式调度模型</h4><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些</p><blockquote><p>Java 采用的是抢占式调度模型</p></blockquote><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>线程的优先级就是线程获得CPU的概率，优先级越高，获取CPU的概率越大</p><blockquote><p>Java中共有10种优先级，从小到大，1-10之间。10是优先级最高，默认的优先级是5</p></blockquote><h4 id="优先级方法"><a href="#优先级方法" class="headerlink" title="优先级方法"></a>优先级方法</h4><blockquote><p>【注意】即便我们设置了优先级，也只是增加抢占的概率，线程并不一定会严格按照优先级执行</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取当前线程的优先级public final int getPriority()// 设置当前线程的优先级public final void setPriority(int newPriority)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    public static void main(String[] args) {        // 创建两个Runnable接口实现类        Runnable run1 = new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("烤羊排");                }            }        };        Runnable run2 = new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡");                }            }        };        // 创建两个线程        Thread thread1 = new Thread(run1);        Thread thread2 = new Thread(run2);        // 查看优先级        System.out.println(thread1.getPriority());        System.out.println(thread2.getPriority());        // 设置优先级        thread1.setPriority(10);        thread2.setPriority(1);        thread2.start();        thread1.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】设置优先级需要在 start 方法之前设置</p><h3 id="线程状态-生命周期"><a href="#线程状态-生命周期" class="headerlink" title="线程状态(生命周期)"></a>线程状态(生命周期)</h3><h4 id="简单理解生命周期"><a href="#简单理解生命周期" class="headerlink" title="简单理解生命周期"></a>简单理解生命周期</h4><blockquote><p>线程有五大状态，分别是新建、就绪、运行、阻塞、销毁</p></blockquote><p>新建：</p><blockquote><p>当我们实例化线程对象的时候，线程就是新建状态</p></blockquote><p>就绪：</p><blockquote><p>当我们调用线程的start方法之后，线程就会进入就绪状态</p><p>处于该状态的线程，随时都可以获取CPU调度</p></blockquote><p>运行：</p><blockquote><p>线程获取CPU的调度之后，线程抢到了时间片，可以用来运行自己任务</p></blockquote><p>阻塞：</p><blockquote><p>当线程因为资源竞争，或主动方法调用，让线程进入到阻塞。</p><p>常见：sleep、wait、join等等</p></blockquote><p>销毁：</p><blockquote><p>当线程的run方法执行结束之后，就会进入到销毁状态</p></blockquote><p>【注意】程序的结束就是指的内部的所有线程全部进入到了销毁状态</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155140.jpg" alt="线程的生命周期"></p><h4 id="扩展：六种线程状态"><a href="#扩展：六种线程状态" class="headerlink" title="扩展：六种线程状态"></a>扩展：六种线程状态</h4><blockquote><p>如果按照 java.lang.Thread.State 枚举方式，一共提供了6种线程状态</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:left">导致状态的发生条件</th></tr></thead><tbody><tr><td style="text-align:center">NEW(新建)</td><td style="text-align:left">线程刚刚被创建，没有启动，没有调用start方法</td></tr><tr><td style="text-align:center">RUNNABLE(可运行)</td><td style="text-align:left">线程已经可以在JVM中运行，但是是否运行不确定，看当前线程是否拥有CPU执行权</td></tr><tr><td style="text-align:center">BLOCKED(锁阻塞)</td><td style="text-align:left">当前线程进入一个同步代码需要获取对应的锁对象，但是发现当前锁对象被其他线程持有，当前线程会进入一个BLOCKED。如果占用锁对象的线程打开锁对象，当前线程持有对应锁对象，进入Runnable状态</td></tr><tr><td style="text-align:center">WAITING(无限等待)</td><td style="text-align:left">通过一个wait方法线程进入一个无限等待状态，这里需要另外一个线程进行唤醒操作。进入无限等待状态的线程是无法自己回到Runnable状态，需要其他线程通过notify或者notifyAll方法进行唤醒操作</td></tr><tr><td style="text-align:center">TIMED_WAITING(计时等待)</td><td style="text-align:left">当前线程的确是等待状态，但是会在一定时间之后自动回到Runnable状态，例如 Thread.sleep() 或者是Object类内的wait(int ms);</td></tr><tr><td style="text-align:center">TERMINATED(被终止)</td><td style="text-align:left">因为Run方法运行结束正常退出线程，或者说在运行的过程中因为出现异常导致当前线程被销毁</td></tr></tbody></table></div><h5 id="TIMED-WAITING-计时等待"><a href="#TIMED-WAITING-计时等待" class="headerlink" title="TIMED_WAITING(计时等待)"></a>TIMED_WAITING(计时等待)</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在对应线程代码块中，当前线程休眠指定的时间Thread.sleep(int ms);    sleep方法        1. 调用之后休眠指定时间        2. sleep方法必须执行在run方法内，才可以休眠线程        3. sleep不会打卡当前线程占用的锁对象。// 让当前线程进入一个计时等待状态        void wait(long timeout);    Object类内         1. 规定的时间及时完毕，线程回到可运行状态        2. 在等待时间内，通过其他线程被notify或者notifyAll唤醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155233.png" alt="TIMED_WAITING状态"></p><h5 id="BLOCKED-锁阻塞"><a href="#BLOCKED-锁阻塞" class="headerlink" title="BLOCKED(锁阻塞)"></a>BLOCKED(锁阻塞)</h5><pre><code>线程中有锁存在，线程需要进入带有锁操作的同步代码，如果锁对象被别人持有，只能在锁外等待锁阻塞状态的线程是否能够抢到锁对象有很多因素    1. 优先级问题，非决定因素    2. CPU执行概率问题。后期高并发一定会存在多线程操作锁对象问题，秒杀，抢购...    队列方式来处理</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155311.png" alt="BLOCKED锁阻塞状态"></p><h5 id="线程状态-WAITING-无限等待"><a href="#线程状态-WAITING-无限等待" class="headerlink" title="线程状态 WAITING(无限等待)"></a>线程状态 WAITING(无限等待)</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">当某一个线程被执行wait()方法，需要等待另外的一个线程进行唤醒操作。public void wait();    在哪一个线程中执行，就会让当前线程进入一个无限等待状态。            1. 所在线程进入无限等待状态            2. 开启【锁对象】public void notify();    唤醒和当前锁对象有关的无限等待线程中的一个，随机选择。            1. 唤醒一个无限等待状态线程            2. 开启【锁对象】public void notifyAll();    唤醒所有和当前锁对象有关的无限等待线程            1. 唤醒所有线程            2. 开启【锁对象】            3. 线程进入锁对象抢占过程，就有可能进入一个锁阻塞状态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155344.png" alt="无限等待图例"></p><h5 id="线程执行的所有状态分析图"><a href="#线程执行的所有状态分析图" class="headerlink" title="线程执行的所有状态分析图"></a>线程执行的所有状态分析图</h5><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155420.png" alt="六大线程状态"></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote><p>线程分为：用户线程和守护线程，Java中默认创建的线程就是用户线程</p></blockquote><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><blockquote><p>当守护的用户线程销毁的时候，守护线程也会跟着消亡。无论守护线程是否执行结束都会随着用户线程一起销毁</p></blockquote><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><blockquote><p>1、自动下载</p><p>2、操作日志</p><p>3、操作监控</p></blockquote><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 判断该线程是否为守护线程boolean isDaemon();// 当传入 true 时，将当前线程设置为守护线程：void setDaemon(boolean on)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    public static void main(String[] args) {        // 创建两个线程        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡");                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                }            }        });        // 查看是否是守护线程        System.out.println(thread2.isDaemon());        // 设置守护线程        thread2.setDaemon(true);        thread1.start();        thread2.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】主线程和 GC（<strong>garbage collection </strong>垃圾回收机制） 线程就是一对用户线程与守护线程，GC 守护主线程</p></blockquote><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 线程休眠(运行-->阻塞)：static void sleep(long millis);// 线程加入(运行-->阻塞)：void join();// 线程礼让(运行-->就绪)：    void yield();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><blockquote><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo6 {    public static void main(String[] args) {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡" + i);                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        thread.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】使用sleep方法需要对其进行异常捕获</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><blockquote><p>在当前线程中，执行另一个线程的join方法，然后当前线程就会阻塞，等待插入的线程执行完毕之后，才会从阻塞状态进入到就绪状态，重新参与CPU抢夺！</p><p>就绪状态的线程的抢占发生在任意时期</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo7 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("烤羊排" + i);                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡" + i);                }            }        });        thread2.start();        // 线程加入        thread2.join();        thread1.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><blockquote><p>可以让当前正在运行的线程暂停，并执行其他线程。但是不会让当前线程阻塞，而且让当前的线程进入到就绪状态。</p><p>实际上：线程执行yield之后，只有比当前线程的优先级更高或者相同的才有机会参与抢夺CPU，而且当前线程也会参与抢夺</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo8 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("大盘鸡" + i);                    if (i == 5) {                        System.out.println("线程礼让");                        Thread.yield();                    }                }            }        });        thread1.setPriority(9);        thread2.setPriority(1);        thread2.start();        thread1.start();        // 主线程        System.out.println("main线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">static Thread currentThread();    返回对当前正在执行的线程对象的引用long getId();    返回该线程的标识符。线程 ID 是一个正的 long 数，在创建该线程时生成。线程 ID 是唯一的，并终生不变。线程终止时，该线程 ID 可以被重新使用 String getName();    返回该线程的名称void setName(String name);    改变线程名称，使之与参数 name 相同Thread.State getState();    返回该线程的状态boolean isAlive();    测试线程是否处于活动状态boolean isInterrupted();    测试线程是否已经中断void interrupt();    中断线程static boolean interrupted();    判断当前线程是否已经中断。线程的中断状态由该方法清除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo9 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("大盘鸡" + i);                    if (i == 5) {                        System.out.println("线程礼让");                        Thread.yield();                    }                }            }        });//        thread2.start();        thread1.start();        System.out.println("获取当前线程：" + Thread.currentThread());        System.out.println("获取线程1的标识：" + thread1.getId());        System.out.println("获取线程2的标识：" + thread2.getId());        System.out.println("获取当前线程的标识：" + Thread.currentThread().getId());        System.out.println("获取当前线程的名称：" + thread1.getName());        // 设置线程的名称        thread1.setName("线程1");        System.out.println("获取当前线程的名称：" + thread1.getName());        System.out.println("获取当前线程的状态：" + thread1.getState());        System.out.println("获取当前线程是否存活：" + thread1.isAlive());        System.out.println("获取当前线程是否中断：" + thread1.isInterrupted());        // 中断线程        thread1.interrupt();        System.out.println("获取当前线程是否中断：" + thread1.isInterrupted());        System.out.println("获取当前线程是否中断：" + Thread.interrupted());        // 主线程        System.out.println("main线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商管理系统</title>
      <link href="posts/57339.html"/>
      <url>posts/57339.html</url>
      
        <content type="html"><![CDATA[<h3 id="电商管理系统"><a href="#电商管理系统" class="headerlink" title="电商管理系统"></a>电商管理系统</h3><p>第一步：先创建四大类，分别为 商品类（Article）、商品集合类（ArticleSet）、商品管理类（ArticleManage）、商品测试类（Demo）. </p><p>代码如下：</p><h4 id="商品类"><a href="#商品类" class="headerlink" title="商品类"></a>商品类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 商品类 * */public class Article {    public String name;    public int amount;    public double price;    public int number;    public void print(int index){        System.out.println(index+"\t"+name+"\t"+price+"\t"+amount+"\t"+number);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品集合类"><a href="#商品集合类" class="headerlink" title="商品集合类"></a>商品集合类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 商品集合类 * */public class ArticleSet {    Article[] articles=new Article[50];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品管理类"><a href="#商品管理类" class="headerlink" title="商品管理类"></a>商品管理类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.util.Scanner;/** * 商品管理类 * */public class ArticleManage {    ArticleSet articleSet=new ArticleSet();    Scanner input=new Scanner(System.in);    /**     * 初始化商品     */    public void initial(){        Article xiaoMi9=new Article();        xiaoMi9.name="小米9";        xiaoMi9.price=2799;        xiaoMi9.amount=60;        xiaoMi9.number=0;        Article xiaoMiMIX3=new Article();        xiaoMiMIX3.name="小米8";        xiaoMiMIX3.price=2049;        xiaoMiMIX3.amount=40;        xiaoMiMIX3.number=0;        Article redMiNote7Pro=new Article();        redMiNote7Pro.name="Redmi7";        redMiNote7Pro.price=699;        redMiNote7Pro.amount=80;        redMiNote7Pro.number=0;        Article xiaoMiPlay=new Article();        xiaoMiPlay.name="小米6x";        xiaoMiPlay.price=749;        xiaoMiPlay.amount=100;        xiaoMiPlay.number=0;        articleSet.articles[0]=xiaoMi9;        articleSet.articles[1]=xiaoMiMIX3;        articleSet.articles[2]=redMiNote7Pro;        articleSet.articles[3]=xiaoMiPlay;    }    public void startMenu(){        boolean flag=true;        do {System.out.println("欢迎使用前程商城后台管理系统");        System.out.println("*****************************************");        System.out.println("1.查看商品信息");        System.out.println("2.新增商品信息");        System.out.println("3.删除商品信息");        System.out.println("4.卖出商品信息");        System.out.println("5.商品销售排行榜");        System.out.println("6.退出");        System.out.println("*****************************************");        Scanner sc=new Scanner(System.in);        System.out.println("请选择要执行的操作：");        int choice=sc.nextInt();        switch (choice) {        case 1:            System.out.println("查看商品信息");            search();            break;        case 2:            System.out.println("新增商品信息");            add();            break;        case 3:            System.out.println("删除商品信息");            delete();            break;        case 4:            System.out.println("卖出商品信息");            sell();            break;        case 5:            System.out.println("商品销售排行榜");            leaderboard();            break;        case 6:            System.out.println("谢谢使用！");            flag=false;            break;        default:            System.out.println("输入不符合请重新输入：");            break;        }        } while (flag);    }    /**     * 查看商品     */    public void search(){        System.out.println("编号\t名称\t价格\t库存\t售出");        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null) {                articleSet.articles[i].print(i+1);            }        }    }    /**     * 新增商品     */    public void add(){        System.out.println("请输入商品名称：");        String name=input.next();        System.out.println("请输入价格：");        int price=input.nextInt();        System.out.println("请输入库存：");        int amount=input.nextInt();        Article article=new Article();        article.name=name;        article.price=price;        article.amount=amount;        article.number=0;        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]==null) {                articleSet.articles[i]=article;                break;            }        }    }    /**     * 删除商品     */    public void delete(){        System.out.println("请输入商品编号：");        boolean flag=true;        int card=input.nextInt();        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null&&(i+1)==card) {                int j=i;                while (articleSet.articles[j+1]!=null) {                    articleSet.articles[j]=articleSet.articles[j+1];                    j++;                }                articleSet.articles[j]=null;                flag=true;                break;            }         }        if (flag) {            System.out.println("删除成功！");        }else {            System.out.println("删除失败，请重新操作！");        }    }    /**     * 销售业务     */    public void sell(){        System.out.println("请输入你要卖出的商品名称：");        String name=input.next();        boolean flag=true;        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null&&articleSet.articles[i].name.equals(name)) {                System.out.println("请输入你要卖出的数量");                int number=input.nextInt();                if (number<=articleSet.articles[i].amount) {                    articleSet.articles[i].number=articleSet.articles[i].number+number;                    articleSet.articles[i].amount=articleSet.articles[i].amount-number;                    flag=true;                } else {                    System.out.println("商品数量不够，请抓紧进货！");                    flag=false;                }                break;            }else{                flag=false;            }        }        if (flag) {            System.out.println("卖出商品成功！");        } else {            System.out.println("卖出商品失败！");        }    }    /**     * 商品销售排行榜     */    public void leaderboard() {        Article[] articles = new Article[50];        for (int i = 0; i < articles.length; i++) {            if (articleSet.articles[i]!=null) {                articles[i]=articleSet.articles[i];            }        }        for (int i = 0; i < articles.length-1; i++) {            for (int j = 0; j < articles.length-i-1; j++) {                if (articles[j+1] != null) {                    if (articles[j].number < articles[j+1].number) {                        Article tempArticle = articles[j];                        articles[j]=articles[j+1];                        articles[j+1]=tempArticle;                    }                }            }        }        System.out.println("*************************************");        System.out.println("名次\t销售数量\t商品名称");        for (int i = 0; i < articles.length; i++) {            if (articles[i]!=null) {                System.out.println(i+1+"\t"+articles[i].number+"\t"+articles[i].name);            }        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品测试类"><a href="#商品测试类" class="headerlink" title="商品测试类"></a>商品测试类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** *商品测试类 */public class Demo {    public static void main(String[] args) {        ArticleManage articleManage=new ArticleManage();        articleManage.initial();        articleManage.startMenu();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的优化</title>
      <link href="posts/9296.html"/>
      <url>posts/9296.html</url>
      
        <content type="html"><![CDATA[<p>简单写一些关于优化hexo博客的内容，后续陆续补充.</p><hr><h3 id="一-添加动态标题"><a href="#一-添加动态标题" class="headerlink" title="一.添加动态标题"></a>一.添加动态标题</h3><p>在matery/layout/layout.ejs下添加如下内容.</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;            var OriginTitile=document.title,st;             document.addEventListener(&quot;visibilitychange&quot;,function(){                 document.hidden?(document.title=&quot;ヽ(●-`Д´-)ノ你要玩捉迷藏嘛&quot;,clearTimeout(st)):(document.title=&quot;(Ő∀Ő3)ノ好哦！&quot;,st=setTimeout(function(){document.title=OriginTitile},3e3))                 })&lt;/script&gt;</code></pre><h3 id="二-配置音乐播放器"><a href="#二-配置音乐播放器" class="headerlink" title="二.配置音乐播放器"></a>二.配置音乐播放器</h3><p> 要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可： </p><pre><code># 是否在首页显示音乐music:  enable: true  title:             # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: &#39;#42b983&#39;  loop: &#39;all&#39;       # 音频循环播放, 可选值: &#39;all&#39;, &#39;one&#39;, &#39;none&#39;  order: &#39;random&#39;   # 音频循环顺序, 可选值: &#39;list&#39;, &#39;random&#39;  preload: &#39;auto&#39;   # 预加载，可选值: &#39;none&#39;, &#39;metadata&#39;, &#39;auto&#39;  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p>id获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="其它内容优化："><a href="#其它内容优化：" class="headerlink" title="其它内容优化："></a>其它内容优化：</h3><p>想查看其它优化博客的内容请移步好友的博客：</p><p><a href="https://www.islu.cn/posts/9443.html" target="_blank" rel="noopener">https://www.islu.cn/posts/9443.html</a></p><p>此人博客较为详细</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="posts/38943.html"/>
      <url>posts/38943.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java语言的特点："><a href="#java语言的特点：" class="headerlink" title="java语言的特点："></a>java语言的特点：</h3><p>​                1.跨平台（一次开发，到处运行）</p><p>​                2.面向对象（万物皆可对象）</p><h3 id="java开发环境："><a href="#java开发环境：" class="headerlink" title="java开发环境："></a>java开发环境：</h3><p>​                jdk：java开发工具包（开发人员必须安装）</p><p>​                jre：java运行环境（运行java程序必须安装）</p><p>​                注意：java程序最终是运行在jvm虚拟机上的，不同的操作系统上可以安装其对应版本的jvm，这样就实现了跨平台</p><h3 id="java类的结构"><a href="#java类的结构" class="headerlink" title="java类的结构"></a>java类的结构</h3><p>​                1.编写源文件（后缀名    .java）</p><p>​                2.编译            （后缀名    .class）</p><p>​                3.运行</p><h3 id="java类的结构-1"><a href="#java类的结构-1" class="headerlink" title="java类的结构"></a>java类的结构</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class 类名{    public static void main(String[] args){    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <code>注意：main方法是java程序的入口</code></p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>​    输出语句</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">System.out.print("\n");//输出完之后不会换行System.out.println("\n");//输出完之后换行显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    转义符：</p><p>​    \n    换行，相当于输出完一句话按了回车键</p><p>​    \t    大空格，相当于Tab键</p><p>​    注释：</p><p>​    1.单行注释    //注释的内容</p><p>​    2.多行注释    /<em> 注释内容 </em>/</p><p>​    变量：</p><pre class="line-numbers language-lang-html"><code class="language-lang-html">color=red; 内存中一块储存空间的表示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="变量的数据类型："><a href="#变量的数据类型：" class="headerlink" title="变量的数据类型："></a>变量的数据类型：</h3><p>​    1.基本类型</p><p>​        八种基本数据类型</p><p>​        byte(1个字节) short(2个字节) int(4个字节) long(8个字节) </p><p>​        float(4个字节) double(8个字节) char(2个字节) boolean(1个字节)</p><p>​        自动转换 boolean—&gt;byte—&gt;short—&gt;int—&gt;long—&gt;float—&gt;double</p><p>​        short—&gt;float</p><p>​        自动    小—&gt;大</p><p>​        强制    大—&gt;小</p><p>​        float—&gt;int    强制    （int）12.3f</p><p>​    2.引用类型：</p><p>​        String，数组，对象，除了8种基本数据类型之外的都属于引用数据类型</p><p><strong>注意：比较相等</strong></p><ul><li><p>java基本数据类型（8种）</p><p>​    比较相等用==比较，比较不等！=</p></li><li><p>2.String</p><p>​    比较相等用equals（）方法比较内容是否相同    相同  true</p><p>不同 false，</p><p>方式：！字符串 1.equals（字符串2）</p></li></ul><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><p>​    1.字母，数字，下划线，$,但是不能以数字开头，</p><p>​    2.不能与关键字重名</p><p>​    3.见名知义</p><p>​    4.多个单词组成时，第一个单词小于其余单词开头大写    如：myScore键盘接收</p><p>​        1). 初始化Scanner 对象</p><p>​        <code>Scanner input=new Scanner(System.in);</code></p><p>​        2.)在程序中导入Scanner类  在类的外面写</p><p>​        <code>import java.util.Scanner;</code></p><p>​        3.)从键盘接收数据赋值给变量</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">    String name=input.next();//接收String类型的值    int javaScore=input.nextInt();//接收int类型的值    double height=input.nextDouble();//接收double类型的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="声明和使用步骤"><a href="#声明和使用步骤" class="headerlink" title="声明和使用步骤 :"></a>声明和使用步骤 :</h4><p>​            1.声明  2.分配空间  3.赋值  4.使用</p><p>​            注意: </p><p>​                声明同时分配空间: 数据类型[] 数组名=new 数据类型[数组长度];</p><p>​                数组下标从0开始  数组元素最大下标值是 length-1</p><p>​                声明的时候赋值:  数据类型[] 数组名=new 数据类型[]{值1,值2,值3,….} //注意,后面的括号中不能写长度</p><p>​                          数据类型[] 数组名={值1,值2,值3,….}//不可拆分</p><h4 id="遍历数组元素"><a href="#遍历数组元素" class="headerlink" title="遍历数组元素"></a>遍历数组元素</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java"> for(int i=0;i<数组名.length;i++){                System.out.println(数组名[下标]);            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数组的应用"><a href="#数组的应用" class="headerlink" title="数组的应用"></a>数组的应用</h4><p>​            ①    数组排序</p><p>​                            使用Arrays类sort方法排序，默认升序排列</p><p>​                            步骤：</p><p>​                            1）Arrays类导入import java.util.Arrays</p><p>​                            2）Arrays.sort（要排序的数组）；</p><p>​            ②求最大值（打擂台思想）</p><p>​                思路：</p><p>​                        1）.设置数组的一个元素为默认最大值</p><p>​                        2）.循环数组元素依次与最大值比较</p><p>​                关键代码：</p><p>​                                ```</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int max=数组[0];for(int i=0;i<数组名.lenght;i++){    if(数组名[i]>max){        max=数组名[i];      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            ③向数组中插入元素</p><p>​            实现思路</p><p>​            a)找到待插入元素的下标</p><p>​                            循环数组，当满足待插入元素大于当前数组元素的时候，终止循                环，并用变量保存当前下标</p><p>​            b)给待插入的元素腾位置</p><p>​                    从后往前移动元素    否则会元素覆盖，丢失i=lenght-1；i&gt;找到的小标值；i—    前一个的值赋值给后一个</p><p>​            c）插入元素</p><p>​                        数组名[下标]=元素值；</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符:"></a>运算符:</h3><ol><li><p>赋值运算符</p><p>​    符号:  =  </p></li></ol><p>​            把等号右边的值赋给左边</p><p>​            sum+=i;//sum=sum+i;</p><p>​    2.算数运算符</p><p>​        + - * /(求商)  %(求余数)  ++(自增)  —(自减)</p><p>​    3.关系运算符：</p><p>​        >,&lt; ,&gt;=,&lt;=,  == (比较两个数是否相等)  !=（比较两数是否不等）        </p><p>​            注意:比较的结果用boolean 类型 的数据表示</p><p>​    4.逻辑运算符：</p><p>​         &amp;&amp;　　 ||　　！</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>​    ！＞算术运算符＞关系运算符＞＆＆＞｜｜最高小括号,最低赋值运算符</p><h3 id="二-流程控制语句"><a href="#二-流程控制语句" class="headerlink" title="二.流程控制语句"></a>二.流程控制语句</h3><p>​                    流程图—-&gt;表示程序的运行流程    </p><p>​                           ◇  —-&gt;表示判断</p><p>​                        矩形—-&gt;表示代码块</p><p>​            平行四边形—-&gt;输出语句</p><p>​                圆角矩形 —-&gt;开始或者结束</p><h4 id="1-选择结构"><a href="#1-选择结构" class="headerlink" title="1. 选择结构"></a>1. 选择结构</h4><p>1）简单的if选择结构</p><p>​        语法结构：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">if(boolean类型的值){       //代码块}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）if—else选择结构———用于两种分支判断的情形</p><p>​        语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">if(){    //代码块1}else{    //代码块2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）多重if语句：用于区间连续情形</p><p>5)switch选择结构—-用于判断价值</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">switch(变量){    case    常量1：        //代码块        break;    case    常量2：        //代码块        break;        ...    default:            //代码块            break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>switch小括号里的变量  —-&gt;整型和字符型,jdk版本1.7以上 支持String</li><li><p>2.break可以省略,但是省略之后case之间会贯穿执行,直到遇到break才结束</p><p>3.各个case之间常量值不能重复的</p><p>4.default 总是在最后执行的,当前面所有的case都匹配不上时,位置不固定    </p></li></ol><h4 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h4><p>1)while循环——-先判断再执行</p><p>​            初始化循环变量</p><p>​            while(判断条件){</p><p>​                //循环操作  </p><p>​                更新循环变量</p><p>​            }</p><p>2)do-while—-先执行再判断  </p><p>​            //定义循环变量</p><p>​            do{</p><p>​                //循环体</p><p>​                循环变量的更新</p><p>​            }while(判断条件);</p><p>3)for循环—-用于固定循环次数</p><p>​            for(循环变量初始化;条件判断;循环变量更新){</p><p>​                循环体</p><p>​               }</p><p>执行顺序：同while    1.变量初始化    2.条件判断    3.循环体    4.变量更新</p><h6 id="注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较"><a href="#注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较" class="headerlink" title="注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较"></a>注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较</h6><p>顺序：</p><p>​                先判断后执行：while for</p><p>​                先执行后判断：do-while</p><h6 id="注意：（1）for循环主要用于循环次数固定"><a href="#注意：（1）for循环主要用于循环次数固定" class="headerlink" title="注意：（1）for循环主要用于循环次数固定"></a>注意：（1）for循环主要用于循环次数固定</h6><h6 id="（2）在循环条件不成立的时候，do-while至少执行一次"><a href="#（2）在循环条件不成立的时候，do-while至少执行一次" class="headerlink" title="（2）在循环条件不成立的时候，do-while至少执行一次"></a>（2）在循环条件不成立的时候，do-while至少执行一次</h6><p>4)二重循环</p><p>​            一个完整的循环结构  再嵌套另一个  </p><p>​            for(){</p><p>​              //循环体</p><p>​              for(){</p><p>​              }</p><p>​            }</p><p>​            外层循环变化一次,内层循环变化一遍</p><h4 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3.流程控制语句"></a>3.流程控制语句</h4><p>break:</p><p>​            1)单层循环中: 终止循环，执行循环外的语句</p><p>​            2)二重循环中:用在内层循环中,只能结束内层循环,执行外层剩下的代码</p><p>continue：  </p><p>​            1)单层循环:跳过本次循环，执行下一次循环</p><p>​            2)结束本层的本次循环 执行本层下一次    </p><h6 id="解决代码中的异常"><a href="#解决代码中的异常" class="headerlink" title="解决代码中的异常:"></a>解决代码中的异常:</h6><h6 id="常见的错误信息"><a href="#常见的错误信息" class="headerlink" title="常见的错误信息:"></a>常见的错误信息:</h6><h6 id="1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用"><a href="#1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用" class="headerlink" title="1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用"></a>1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用</h6><h6 id="2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明"><a href="#2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明" class="headerlink" title="2.num cannot be resolved to a variable===&gt;变量没有声明"></a>2.num cannot be resolved to a variable===&gt;变量没有声明</h6><h6 id="3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException"><a href="#3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException" class="headerlink" title="3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException"></a>3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException</h6><h6 id="当访问超出了数组下标范围"><a href="#当访问超出了数组下标范围" class="headerlink" title="当访问超出了数组下标范围"></a>当访问超出了数组下标范围</h6><h6 id="Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常"><a href="#Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常" class="headerlink" title="Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常"></a>Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常</h6><p>简单的异常处理</p><p>​        input.hasNextInt()  判断用户输入的内容是否是合法整数,合法为true,否则为false</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    要在变量赋值之前判断</p><p>​    程序调试  程序在我们的控制下一步一步执行</p><p>​     *    1.调试代码之前,要先分析可能出错的位置    </p><p>​     *    2.在可能出错的地方  打断点—-代码执行到断点处会暂停   行号前双击</p><p>​     *    3.以debug模式启动程序  debug as—-java application</p><pre><code> *    4.单步执行,查找错误(F6) {程序运行到断点处才会启动调试模式}</code></pre><p>​     *    5.找到错误,修改代码</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="一-什么叫面向对象"><a href="#一-什么叫面向对象" class="headerlink" title="一.什么叫面向对象"></a>一.什么叫面向对象</h4><p>相对于面向过程</p><p>​    在完成某件事情的时候,找到一个能完成该功能的对象,而不关心内部细节</p><p>​    如:数组排序的时候,我们只是调用了Arrays类的sort()方法就可以完成排序,但是具体是怎么实现的并没有过多的关心</p><h4 id="二-类和对象"><a href="#二-类和对象" class="headerlink" title="二.类和对象"></a>二.类和对象</h4><h5 id="1-现实中各类分类及描述"><a href="#1-现实中各类分类及描述" class="headerlink" title="1.现实中各类分类及描述"></a>1.现实中各类分类及描述</h5><p>手机:</p><p>​            属性(静态特征):    颜色,品牌,内存,处理器  </p><p>​            功能(动态行为): 打电话,发短信,上网</p><p>学生:</p><p>​            属性(静态特征) ;姓名,性别,身高,体重,学号,班级</p><p>​            功能(动态行为):学习,打代码</p><p>电脑:</p><p>​         属性(静态特征):品牌,外观,cpu,硬盘,内存</p><p>​            功能(动态行为); 开机,关机,运行各种软件</p><h5 id="2-怎么用java语言来描述现实生活中的分类"><a href="#2-怎么用java语言来描述现实生活中的分类" class="headerlink" title="2.怎么用java语言来描述现实生活中的分类"></a>2.怎么用java语言来描述现实生活中的分类</h5><p>public class 类名{</p><p>​            //属性——描述类的静态的特征</p><p>​            String 属性名;</p><p>​            int  属性名;</p><p>​            //方法——描述类的动态的行为</p><p>​            public void 方法名(){</p><p>​            }</p><p>​        }</p><h5 id="3-什么是对象"><a href="#3-什么是对象" class="headerlink" title="3.什么是对象"></a>3.什么是对象</h5><p>对象是用来描述客观事物的一个实,是具体的,能够看得见摸得着的</p><p>​            汽车—-类     我家楼下停着的那辆白色的宝马—-对象</p><p>​         *             手机—-类     我的这部手机——对象</p><p>​         *             椅子—-类     我现在正坐的椅子—-对象</p><p>​         *             演员—-类   女演员—-类     年龄是20到30岁之间的女演员 -类   迪丽热巴—对象 </p><p>​         *             作家—类   男作家—-类   郭敬明—对象</p><h5 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4.类和对象的关系"></a>4.类和对象的关系</h5><p>​        类定义了对象将会拥有的特征（属性）和行为（方法）———相当于图纸/模板</p><p>​        类是抽象的,对象是具体的</p><p>​        类是对象的类型,对象是类的实例</p><p>​        Car c=new Car();</p><p>​        int a=19;</p><h5 id="5-如何创建对象"><a href="#5-如何创建对象" class="headerlink" title="5.如何创建对象"></a>5.如何创建对象</h5><p>类名  对象名=new 类名();</p><h5 id="6-调用对象的属性"><a href="#6-调用对象的属性" class="headerlink" title="6.调用对象的属性"></a>6.调用对象的属性</h5><p>​    对象名.属性名;</p><h5 id="7-调用对象的方法"><a href="#7-调用对象的方法" class="headerlink" title="7.调用对象的方法"></a>7.调用对象的方法</h5><p>​    对象名.方法名();</p><h4 id="三-封装"><a href="#三-封装" class="headerlink" title="三.封装"></a>三.封装</h4><p>1.对象同时具有属性和方法两项特性</p><p>2.对象的属性和方法通常被封装在一起，共同体现事物的特性， 二者相辅相承，不能分割 </p><p>​    </p><p>​    如:一辆汽车，有完好的零件和特定的颜色还应具备开动、刹车等方法行为 </p><h4 id="四-面向对象的好处"><a href="#四-面向对象的好处" class="headerlink" title="四.面向对象的好处"></a>四.面向对象的好处</h4><p>​    1.与人类的思维习惯一致`</p><p>​    2.提高了程序的可重用性 </p><p>​    3.信息隐藏，提高了程序的可维护性和安全性  </p><h3 id="五、类的无参方法"><a href="#五、类的无参方法" class="headerlink" title="五、类的无参方法"></a>五、类的无参方法</h3><p>​    定义格式</p><p>​        public  返回值类型  方法名(){</p><p>​            //方法主体</p><p>​        }</p><h4 id="返回值类型的两种情况"><a href="#返回值类型的两种情况" class="headerlink" title="返回值类型的两种情况"></a>返回值类型的两种情况</h4><p>​        1.有具体的返回值类型    方法体最后一句话要添加return语句,返回相应类型的值</p><p>​        2.没有具体返回值类型 void  方法体中,可以不加return语句</p><p>​    注意：1.所有的数据类型,都可以作为方法的返回值类型</p><p>​    </p><p>​    2.调用带有返回值的方法的时候,一定要读返回值有所处理，要定一个相应类型的变量来接收方法的返回值</p><p>​    \3. return 的作用//1.跳出方法(方法执行到return语句就结束了)  2.返回结果</p><p>​    4.方法不能返回多个值</p><p>​    5.多个方法不能嵌套定义</p><p>​    6.方法外面不能写逻辑代码</p><h4 id="方法调用的两种情况"><a href="#方法调用的两种情况" class="headerlink" title="方法调用的两种情况"></a>方法调用的两种情况</h4><p>​    1.同类之间的方法调用  直接通过  方法名()  来调用</p><p>​    2.不同类的方法   先创建对象  通过  对象名.方法名()  来调用</p><p>方法返回值:</p><p>​    有些方法在执行完成之后,要给调用方法的对象返回一个值</p><h3 id="六、变量的分类"><a href="#六、变量的分类" class="headerlink" title="六、变量的分类"></a>六、变量的分类</h3><h4 id="1-成员变量-："><a href="#1-成员变量-：" class="headerlink" title="1.成员变量 ："></a>1.成员变量 ：</h4><p>定义在类中的，属性的位置</p><p>​           本类，其他类都可以访问（现阶段来说）</p><h4 id="2-局部变量："><a href="#2-局部变量：" class="headerlink" title="2.局部变量："></a>2.局部变量：</h4><p>定义在方法中的</p><p>​           只能在  定义的变量的方法  中使用</p><p>​    变量只能在定义它的大括号的范围内使用</p><p>​    区别：</p><h4 id="1-作用范围"><a href="#1-作用范围" class="headerlink" title="1.作用范围"></a>1.作用范围</h4><h4 id="2-初始值："><a href="#2-初始值：" class="headerlink" title="2.初始值："></a>2.初始值：</h4><p>​              成员变量在没有初始值的情况下，java会给默认的初始值</p><p>​              局部变量不会</p><p>​    注意：同一个方法中不能有同名的局部变量，同一个类中也不能有重复的成员变量</p><p>​       不同的方法中可以存在同名的局部变量</p><p>​       成员变量和局部变量能否定义相同的名字，可以的</p><p>​       局部变量和成员变量可以重名，但是局部变量具有更高的优先级</p><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释  /*  /"></a>文档注释  /<em>*  </em>/</h4><p>​    注释：类，属性，方法</p><p>​    可以把注释的内容抽取出来，显示成文档，方便开发人员使用</p><p>​    @version  版本  </p><p>​    @author  作者</p><p>​    @return  返回值</p><p>​    @param  参数</p><p>​    @exception  异常情况</p><h3 id="七、带参方法"><a href="#七、带参方法" class="headerlink" title="七、带参方法"></a><strong>七、带参方法</strong></h3><p>定义</p><p>​        访问修饰符（public）  返回值类型   方法名（数据类型  变量名,数据类型 变量名….）{</p><p>​            </p><p>​        }</p><p>​        注意:方法定义时的参数列表为形参列表,说明了方法调用的时候需要几个,什么类型的参数，逗号分隔</p><p>调用：</p><h4 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h4><p>​            数据类型 变量=对象名.方法名（变量1,变量2,变量3,…..）；</p><p>​        无返回值</p><p>​            对象名.方法名(参数1,参数2,….);</p><p>​        注意:实参是调用方法时小括号里传递的,要和形参列表一一对应</p><p>一个方法可以有无数个参数,一个返回值</p><h4 id="数组当参数的方法"><a href="#数组当参数的方法" class="headerlink" title="数组当参数的方法"></a>数组当参数的方法</h4><p>​    定义:</p><p>​        public  返回值  方法名(数据类型[] 数组名){</p><p>​            return  值;</p><p>​        }</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用:"></a>调用:</h4><p>​        数据类型[] 实参数组名=new 数据类型[长度];</p><p>​        //数组元素的赋值</p><p>​        数据类型  变量= 对象名.方法名(实参数组名);</p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组:"></a>对象数组:</h4><p>​    定义:</p><p>​        类名[] 数组名=new  类名[数组长度];  如:Student[] stus=new Student[6];</p><p>​    赋值:  1.数组名[下标]=new 类名();      如:stus[0]=new Student();    </p><p>​        数组名[下标].属性</p><p>​        数组名[下标].方法();</p><h4 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h4><p>​    public  返回值类型  方法名(类名  对象名){</p><p>​    }</p><p>调用:</p><p>​    //创建方法所在类的对象</p><p>​    类名  方法所在类的对象名=new 类名();</p><p>​    </p><p>​    //创建传递参数的对象</p><p>​    类名 对象名=new  类名();</p><p> 方法所在类的对象名.方法名(对象名);</p><h4 id="package-包声明语句"><a href="#package-包声明语句" class="headerlink" title="package 包声明语句"></a>package 包声明语句</h4><p>​    本类所在包的路径,以点号分割</p><p>​    必须是除了注释之外的第一条语句</p><p>import  包导入语句</p><p>​    指明要导入的类的路径,也是以点号分割</p><p>​    包名完整路径.类名 导入某一个类</p><p>​    包名完整路径.*   导入某一个包下面所有的类</p><h4 id="java中包名命名规则"><a href="#java中包名命名规则" class="headerlink" title="java中包名命名规则:"></a>java中包名命名规则:</h4><p>全小写,不能以点号开始或者结束,</p><p>​         有时前面会加上域名和项目组织名称</p><h3 id="八、字符串-String-StringBuffer"><a href="#八、字符串-String-StringBuffer" class="headerlink" title="八、字符串:  String,StringBuffer"></a>八、字符串:  String,StringBuffer</h3><p>调用字符串方法的时候要注意以下几点:</p><p> <strong>1.方法的作用  2.方法的参数  3.方法的返回值</strong></p><p>注意:java jdk 开发工具包中字符串类的定义有final 关键字,final含义是最终的意思,所以字符串对象一经创建,就不能更改</p><p>​        比如:  String s1=”hello”;  s1+=”,world”;  //s1=hello ,world</p><p>​        由于字符串的内容是不能修改的,所以这个例子里面实际上是创建了两个String对象 既:只要对字符串的内容修改一次,就会重新创建一个字符串类的对象</p><h4 id="1-创建字符串对象"><a href="#1-创建字符串对象" class="headerlink" title="1.创建字符串对象"></a><strong>1.创建字符串对象</strong></h4><p>​        String s=””;</p><p>​        String s=new String();</p><p>​        String s=new String(“hello world”);</p><h4 id="2-String类的方法"><a href="#2-String类的方法" class="headerlink" title="2.String类的方法"></a><strong>2.String类的方法</strong></h4><p>​        <strong>调用字符串类的的方法的时候,要注意,方法是否有参数,以及返回值类型</strong></p><p><strong>Ø</strong> 获取字符串长度  返回int类型</p><p>​        </p><p><strong>Ø</strong> <strong><em>equals()</em></strong>:比较字符串内容相等</p><p><strong>注意:如果用”==” 比较字符串的值,实际比较的是两个字符串的地址是否相同</strong></p><p><strong>Ø</strong> <strong><em>equalsIgnoreCase()</em></strong>比较相等时忽略大小写,用法和equals相同</p><p>​        字符串大小写转换</p><p><strong>Ø</strong> <strong><em>toLowerCase()</em></strong> 将字符串全部转化为小写</p><p><strong>Ø</strong> <strong><em>toUpperCase()</em></strong> 将字符串转换成大写</p><p><strong>注意:原来的字符串不会改变,转换之后的会作为返回值返回</strong></p><p>​            <strong>如:</strong></p><p>​            <strong>String name=”tom”;</strong></p><p>​            <strong>String s=name.toUpperCase();</strong></p><p>​            <strong>System.out.println(“name=”+name);// tom</strong></p><p>​            <strong>System.out.println(“s=”+s);//TOM</strong></p><p><strong>Ø</strong> <strong><em>字符串连接的方法</em></strong></p><p><strong></strong> <strong><em>使用”+”拼接字符串</em></strong></p><p><strong>‚</strong> <strong><em>字符串.concat(“”);</em></strong>原来的字符串不会改变,转换之后的会作为返回值返回</p><p>比如:String s=”123”;  String s1= s.concat(“111”);</p><p>​                   输出s的值为  123——&gt;s还是为原来的值,并没有改变</p><p>​                 输出s1的值  123111——-&gt;拼接的结果是作为返回值,接收输出返回值就是拼接之后的值</p><p><strong>Ø</strong> <strong><em>字符串的提取</em></strong></p><p><strong></strong> <strong><em>字符串.indexOf()</em></strong> </p><p>参数:int或者String </p><p>​                返回值:int  代表要查找字符第一次出现的下标位置</p><p><strong>注意:字符串字符下标从0开始</strong></p><p>​                          <strong>如果没有找到,返回值-1</strong></p><p><strong>‚</strong> <strong><em>字符串.lastIndexOf();</em></strong> </p><p>参数:int或者String </p><p>​                最后一次出现的下标</p><p><strong>ƒ</strong> <strong><em>\</em>字符串.indexOf(int/String , int fromIndex);**</strong> </p><p>从fromindex位置开始的第一次出现的下标位置</p><p><strong>„</strong> <strong><em>\</em>字符串.charAt(int index)**</strong> </p><p> 返回值类型:char  </p><p>​               查找返回  对应下标的字符</p><p>截取字符串:</p><p>​            1.substring(开始的下标)  //截取从下标位置开始到字符串结束  部分的内容</p><p>​             例如:</p><p>​                String s=”郑州职业技术学院”;</p><p>​                String s1=s.substring(2);</p><p>​                System.out.println(“截取出来的字符串是:”+s1);//职业技术学院</p><p>​            2.substring(开始的下标,结束下标)  返回值:String  截取之后的</p><p>​                注意:开始下标从0 计算  结束下标从1开始计算</p><p>去前后空格  :trim()  返回值类型:String   注意:原来的字符串不改变,去掉空格的字符串以返回值的形式返回</p><p>​            String str=”  abc  “;</p><p>​            String str_new=str.trim();  或者  str=str.trim();</p><p>​            str还是带有空格的, str_new 去掉前后空格的</p><p>​        分割字符串:</p><p>​            1.split(String regx); 参数:分隔符  返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割</p><p>​            2.split(String regx,int limit); 参数:分隔符,分割之后返回的数组元素的个数   返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割成limit份</p><p>StringBuffer  :String类的增强版</p><p>​        优势:频繁对字符串的内容进行修改的时候要使用这个类</p><p>​        原因是:String对象一经创建,不能更改,如果修改了String对象的内容,系统会新创建一个对象来存放修改之后的内容</p><p>​            但是StringBuffer 存储的字符串的内容可以更改</p><p>​        方法:</p><p>​            1. toString();将StringBuffer的对象转换成String类型</p><p>​                //StringBuffer 和  String 类型相互转化</p><p>​                StringBuffer sb=new StringBuffer(“123”);</p><p>​                String s=sb.toString();</p><p>​        //String —-&gt;StringBuffer</p><p>​                String str=”123”;</p><p>​                StringBuffer sb1=new StringBuffer(str);</p><p>​            2. append(); 在字符串后面追加内容</p><p>​            3. StringBuffer对象.insert(int index,要插入的内容); 下标从0开始</p><p>​                将str的内容插入 对象中下标是index位置</p><p>​            4.length()  返回字符串对象的长度</p><h6 id="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"><a href="#java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件" class="headerlink" title="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"></a>java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件</h6>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客</title>
      <link href="posts/56568.html"/>
      <url>posts/56568.html</url>
      
        <content type="html"><![CDATA[<p>此人比较懒惰。未填写内容</p><p>如想详细创建博客请移步另博客，链接如下：</p><p><a href="https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242</a></p><p>如想优化博客：</p><p><a href="https://www.islu.cn/posts/9443.html" target="_blank" rel="noopener">https://www.islu.cn/posts/9443.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
