<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSP</title>
      <link href="posts/6685.html"/>
      <url>posts/6685.html</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将Servlet 理解为后者</p><p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于HTTP协议的Web服务器。</p><blockquote><p>简单理解：</p><p>Servlet 是 Java Web 服务端的一个小程序，主要用户数据的交互，Web 数据展示和数据传递，这里的  Servlet 是一个动态资源。</p><p>Servlet 程序可以应对所有类型的请求和响应，Servlet 主要还是用于HTTP 协议的WEB服务器程序实现。</p></blockquote><h3 id="工作模式【重点】"><a href="#工作模式【重点】" class="headerlink" title="工作模式【重点】"></a>工作模式【重点】</h3><blockquote><ol><li>浏览器端发送请求至服务器</li><li>服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</li><li>服务器将响应返回客户端</li></ol></blockquote><h3 id="tomcat-和-servlet-的关系【了解】"><a href="#tomcat-和-servlet-的关系【了解】" class="headerlink" title="tomcat 和 servlet 的关系【了解】"></a>tomcat 和 servlet 的关系【了解】</h3><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而Servlet是一种运行在支持 Java 语言的服务器上的组件。Servlet 最常见的用途是扩展 Java Web 服务器功能,提供非常安全的,可移植的,易于使用的 CGI 替代品。</p><blockquote><p>1、Tomcat将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，所有的HTTP头数据读可以通过request对象调用对应的方法查询到。</p><p>2、Tomcat同时会要响应的信息封装为HttpServletResponse类型的response对象，通过设置response属性就可以控制要输出到浏览器的内容，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器</p></blockquote><p>Java Servlet API  是 Servlet容器 (tomcat) 和 servlet 之间的接口，它定义了 serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 ServletRequest 和 ServletResponse。所以说我们在编写servlet 时，需要实现 Servlet 接口，按照其规范进行操作。</p><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>步骤</p><pre><code>1、创建类并继承自HttpServlet2、重写doGet和doPost方法（两个方法实际是一个）3、声明@WebServlet并加上默认属性(访问路径)</code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * @description 第一个Servlet程序 * * @WebServlet 注解的意思是声明程序的入口，注解中的属性为请求的路径 * 【注意】属性前必须要加 / !!! */@WebServlet("/HelloServlet")public class HelloServlet extends HttpServlet {    /**     * 处理Post请求     *     * @param req HttpServletRequest对象：浏览器请求数据内容对象     * @param resp HttpServletResponse对象：浏览器响应数据内容对象     * @throws ServletException Servlet异常     * @throws IOException IO异常     */    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println("doPost被执行");        resp.getWriter().append("Hello Servlet");    }    /**     * 处理Get请求     *     * @param req HttpServletRequest对象：浏览器请求数据内容对象     * @param resp HttpServletResponse对象：浏览器响应数据内容对象     * @throws ServletException Servlet异常     * @throws IOException IO异常     */    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println("doGet被执行");        // 实际调用的仍然是doget方法        doPost(req, resp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>html页面</p><pre class="line-numbers language-lang-html"><code class="language-lang-html"><!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <title>测试Servlet</title></head><body>    <form action="HelloServlet" method="get">        <input type="submit" value="get请求">    </form>    <form action="HelloServlet" method="post">        <input type="submit" value="post请求">    </form></body></html><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】</p><ol><li>Servlet代码中的@WebServlet注解中的属性值前必须要加 /</li><li>HTML页面中跳转页面不要加 / </li></ol></blockquote><h3 id="servlet-核心接口和类"><a href="#servlet-核心接口和类" class="headerlink" title="servlet 核心接口和类"></a>servlet 核心接口和类</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 两个相关核心包javax.servletjavax.servlet.http// 顶级父类接口，定义了生命周期方法以及获取配置的方法public interface Servlet;// 初始化当前Servlet程序，这里需要的参数是ServletConfig，ServletConfig是当前Servlet的配置，该配置可以从注解方式或者从当前项目中的web.xml加载获取public void init(ServletConfig config) throws ServletException;// 获取ServletConfig对象，当前对象中保存有Servlet配置内容public ServletConfig getServletConfig();// 【核心方法】Servlet提供服务的方法，浏览器访问当前Servlet程序，service方法是起作用，真实调用的还是doget和doPost// ServletRequest对应的是请求对象// ServletResponse 对应的是响应对象public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;// 获取当时Servlet程序信息对应字符串，几乎不用，数据都保存在数据库中public String getServletInfo();// 销毁当前Servlet程序，可以由Tomcat服务器执行，也可也通过servlet程序自己调用        public void destroy();// 对 Servlet 的扩展，完成了一些不太关心的方法，对我们来说只需重写 service 方法即可    public abstract class GenericServlet;// 根据初始化参数名字获取对应的值，而且参数值为Stringpublic String getInitParameter(String name);// 获取ServletContext对象，一个Servlet Application有且只有一个ServletContext对应，这是Servlet上下文对象，对应整个Servlet项目，此方法同时实现了Servlet接口中的 init 初始化方法public ServletContext getServletContext();// 符合HTTP协议的Servlet，继承自GenericServlet，最常用，需要重写 doGet 和 doPost 方法    public abstract class HttpServlet;// 符合HTTP GET请求的处理方式protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException// 符合HTTP POST请求的处理方式     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException// 用于 Servlet 之间的通信public interface ServletContext;// 扩展ServletRequest接口，为HTTP servlet提供请求信息。servlet容器创建一个HttpServletRequest对象，并将其作为参数传递给servlet的服务方法(doGet、doPost)。public interface HttpServletRequest;// 扩展ServletResponse接口以在发送响应时提供特定于http的功能。servlet容器创建一个HttpServletResponse对象，并将其作为参数传递给servlet的服务方法(doGet、doPost等)。public interface HttpServletResponse;// 提供一种技术来识别跨多个页面请求或访问Web站点的用户，并存储有关该用户的信息，用于会话技术public interface HttpSession;// 创建一个cookie, servlet发送给Web浏览器的少量信息，由浏览器保存，然后发送回服务器。cookie的值可以唯一地标识客户端，因此cookie通常用于会话管理。public class Cookie;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【重点】HttpServlet 中的 doGet 和 doPost 方法</p></blockquote><h3 id="三种创建-Servlet-的方式"><a href="#三种创建-Servlet-的方式" class="headerlink" title="三种创建 Servlet 的方式"></a>三种创建 Servlet 的方式</h3><blockquote><p>【注意】不管是哪种方式都一定要加上@WebServlet注解！！！</p></blockquote><h4 id="实现-servlet-接口【鸡肋】"><a href="#实现-servlet-接口【鸡肋】" class="headerlink" title="实现 servlet 接口【鸡肋】"></a>实现 servlet 接口【鸡肋】</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 实现Servlet接口 * 代码中存在太多和业务逻辑无关的代码，增加了程序员的压力！！！ * 不要这么写！！！ */@WebServlet("/ServletImpl")public class ServletImpl implements Servlet {    /**     * 构造方法     */    public ServletImpl() {        System.out.println("constructor method be called");    }    /**     * 初始化方法     *     * @param servletConfig 需要使用ServletConfig类对象，也就是Servlet配置来完成初始化操作     * @throws ServletException Servlet异常     */    @Override    public void init(ServletConfig servletConfig) throws ServletException {        System.out.println("init method be called");    }    /**     * 获取Servlet配置对象     *     * @return 获取ServletConfig对象     */    @Override    public ServletConfig getServletConfig() {        return null;    }    /**     * 提供服务核心方法，其实就是doGet和doPost     *     * @param servletRequest ServletRequest对象     * @param servletResponse ServletResponse对象     * @throws ServletException Servlet异常     * @throws IOException      IO异常     */    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        System.out.println("service method be called");        // 设置字符集为UTF-8        servletResponse.setContentType("text/html; charset=utf-8");        // 写入内容        servletResponse.getWriter().append("<font color=red size=30px style=text-align: center>service方法被执行~</font>");    }    /**     * 获取Servlet信息     * @return Servlet信息     */    @Override    public String getServletInfo() {        return null;    }    /**     * 销毁的方法     */    @Override    public void destroy() {        System.out.println("destroy method be called");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>太过繁琐，需要关注的东西太多，pass</p></blockquote><h4 id="继承-GenericServlet-类【鸡肋】"><a href="#继承-GenericServlet-类【鸡肋】" class="headerlink" title="继承 GenericServlet 类【鸡肋】"></a>继承 GenericServlet 类【鸡肋】</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 继承自GenericServlet创建Servlet */@WebServlet("/ExtendsGeneric")public class ExtendsGeneric extends GenericServlet {    @Override    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {        servletResponse.setContentType("text/html; charset=utf-8");        servletResponse.getWriter().append("<div style='color: aquamarine'>北纬线的思念被季风吹远</div>");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>相比于实现 Servlet，友好太多，但是还不够友好，因为没有对应Http协议请求的处理方法</p></blockquote><h4 id="继承-HttpServlet-类【重点】"><a href="#继承-HttpServlet-类【重点】" class="headerlink" title="继承 HttpServlet 类【重点】"></a>继承 HttpServlet 类【重点】</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 继承自HttpServlet创建Servlet */@WebServlet("/ExtendsHttpServlet")public class ExtendsHttpServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        resp.setContentType("text/html; charset=utf-8");        resp.getWriter().append("<font color='green' size=7>晚餐可以吃午餐肉吗？</font>");    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        doGet(req, resp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】一定要重写 doGet 和 doPost 方法</p></blockquote><h4 id="使用继承-HttpServlet-类的优点"><a href="#使用继承-HttpServlet-类的优点" class="headerlink" title="使用继承 HttpServlet 类的优点"></a>使用继承 HttpServlet 类的优点</h4><blockquote><p>HttpServlet 在实现 Servlet 接口的时候，已经实现了 servlet 中所有方法，因此继承自 HttpSrvlet 的类，不需要再去重写相应的生命周期等方法，并且支持 HTTP 协议</p></blockquote><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><blockquote><ul><li>Servlet 构造方法被执行</li><li>然后使用 init 方法进行初始化。</li><li>浏览器端对 service 方法的任何调用都将被处理</li><li>Servlet 退出，使用 destroy 方法进行销毁，然后垃圾收集并完成。</li></ul></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * Servlet生命周期 */@WebServlet("/ServletLife")public class ServletLife implements Servlet {    /**     * 构造方法     */    public ServletLife() {        System.out.println("ServletLife Constructor called");    }    /**     * 初始化方法     *     * @param config 需要使用ServletConfig类对象，也就是Servlet配置来完成初始化操作     * @throws ServletException Servlet异常     */    @Override    public void init(ServletConfig config) throws ServletException {        System.out.println("init method called");    }    /**     * 获取ServletConfig对象     *     * @return 获取ServletConfig对象     */    @Override    public ServletConfig getServletConfig() {        return null;    }    /**     * 提供服务核心方法     *     * @param req ServletRequest对象     * @param res ServletResponse对象     * @throws ServletException Servlet异常     * @throws IOException      IO异常     */    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {        System.out.println("service method called");    }    /**     * 获取Servlet信息     * @return Servlet字符串信息     */    @Override    public String getServletInfo() {        return null;    }    /**     * 销毁Servlet     */    @Override    public void destroy() {        System.out.println("destroy method called");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两种配置方式【重点】"><a href="#两种配置方式【重点】" class="headerlink" title="两种配置方式【重点】"></a>两种配置方式【重点】</h3><h4 id="通过-WebServlet-注解"><a href="#通过-WebServlet-注解" class="headerlink" title="通过 @WebServlet 注解"></a>通过 @WebServlet 注解</h4><p>@WebServlet注解用于标注在一个继承了HttpServlet类之上，属于类级别的注解</p><blockquote><p>【注意】Servlet3.0之后允许使用注解方式配置！！！</p></blockquote><p><strong>常用格式</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@WebServlet("/TestServlet")public class useAnnotation extends HttpServlet {    doGet();    doPost();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用属性描述</p><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>是否必须</th><th>描述</th></tr></thead><tbody><tr><td>asyncSupported</td><td>boolean</td><td>否</td><td>指定Servlet是否支持异步操作</td></tr><tr><td>displayName</td><td>String</td><td>否</td><td>指定Servlet显示名称</td></tr><tr><td>initParams</td><td>WebInitParam[]</td><td>否</td><td>配置初始化参数</td></tr><tr><td>loadOnStartup</td><td>int</td><td>否</td><td>标记容器是否在应用启动时就加载这个Servlet，默认 -1，选择加载 1</td></tr><tr><td>name</td><td>String</td><td>否</td><td>指定Servlet名称</td></tr><tr><td>urlPatterns</td><td>String[]</td><td>是/否</td><td>允许当前Servlet有多个匹配方式，和value互斥</td></tr><tr><td>value【重点】</td><td>String[]</td><td>否/是</td><td>url资源匹配方式，和urlPatterns互斥</td></tr></tbody></table></div><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 通过注解配置Servlet */@WebServlet(urlPatterns = {"/urlPatterns", "/aa"}, // 多个匹配路径，与value属性互斥，只能存在一个        name = "AnnotationServlet", // 自定义Servlet名，没啥用        displayName = "AnnotationServlet", // 显示名，没啥用        loadOnStartup = 1,  // 加载时自动启动        initParams = {@WebInitParam(name = "username", value = "易烊千玺"), @WebInitParam(name = "password", value = "欧阳娜娜")}) // 初始化参数public class UseOnAnnotation extends HttpServlet {    public UseOnAnnotation() {        System.out.println("constructor be called");    }    @Override    public void init() throws ServletException {        System.out.println("init method be called");        super.init();    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        resp.setContentType("text/html; charset=utf-8");        resp.getWriter().append("test annotation");        // 获取初始化参数        String username = getServletConfig().getInitParameter("username");        String password = getServletConfig().getInitParameter("password");        resp.getWriter().append(username).append(":").append(password);    }    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        doPost(req, resp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="通过-web-xml-文件"><a href="#通过-web-xml-文件" class="headerlink" title="通过 web.xml 文件"></a>通过 web.xml 文件</h4><p>核心内容</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><!--Servlet核心配置，必须告知Servlet程序对应的名字和Servlet程序对应的class（Java类）--><servlet>    <!-- ServletName -->    <servlet-name>UseWebXML</servlet-name>    <!-- Servlet对应的class，必须是完整的包名.类名 -->    <servlet-class>com.fc.d_configServlet.UseWebXML</servlet-class></servlet><!-- Servlet映射关系 --><servlet-mapping>    <!--声明映射到哪一个Servlet，必须与Servlet-name中相同-->    <servlet-name>UseWebXML</servlet-name>    <!--URL-->    <url-pattern>/UseWebXML</url-pattern></servlet-mapping><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>XML 配置文件</strong></p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"         version="3.1">    <!--Servlet核心配置，必须告知Servlet程序对应的名字和Servlet程序对应的class（Java类）-->    <servlet>        <!-- ServletName -->        <servlet-name>UseWebXML</servlet-name>        <!-- Servlet对应的class，必须是完整的包名.类名 -->        <servlet-class>com.fc.d_configServlet.UseWebXML</servlet-class>        <!-- 当前Servlet程序初始化操作，需要放在servlet-class之后 -->        <init-param>            <param-name>彭于晏</param-name>            <param-value>真帅</param-value>        </init-param>        <init-param>            <param-name>欧阳娜娜</param-name>            <param-value>真美</param-value>        </init-param>        <!-- Tomcat启动时当前Servlet -->        <load-on-startup>1</load-on-startup>    </servlet>    <!-- Servlet映射关系 -->    <servlet-mapping>        <!--声明映射到哪一个Servlet，必须与Servlet-name中相同-->        <servlet-name>UseWebXML</servlet-name>        <!--URL-->        <url-pattern>/UseWebXML</url-pattern>    </servlet-mapping>    <!-- Servlet映射关系2 -->    <servlet-mapping>        <!--声明映射到哪一个Servlet，必须与Servlet-name中相同-->        <servlet-name>UseWebXML</servlet-name>        <!--第二个URL-->        <url-pattern>/UseWebXML2</url-pattern>    </servlet-mapping></web-app><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>案例代码</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 使用Web.xml方式 */public class UseWebXML extends HttpServlet {    public UseWebXML() {        System.out.println("constructor be called");    }    @Override    public void init() throws ServletException {        System.out.println("init method be called");        super.init();    }    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        resp.setContentType("text/html; charset=utf-8");        resp.getWriter().append("猫(>^ω^<)喵");        String parameter1 = getServletConfig().getInitParameter("彭于晏");        String parameter2 = getServletConfig().getInitParameter("欧阳娜娜");        System.out.println(parameter1 + ":" + parameter2);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        doGet(req, resp);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><pre><code>   两种方式比较       @WebServlet注解           配置简单，直观，高效           url-pattern 冲突问题，并且是在Tomcat启动时发现，需要注意细节       web.xml配置文件           繁琐，麻烦，步骤繁多           url-pattern 一旦写错或者冲突，web.xml文件会提示错误！！！</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 安装教程</title>
      <link href="posts/46164.html"/>
      <url>posts/46164.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本教程所有操作基于<code>Window 10</code>操作系统 + <code>Node.js v12.16.1-x64</code>，原则上适用于所有<code>Windows</code>操作系统，细节不同请根据自己需要自行判断。</p><p><code>git</code>+<code>Node.js</code>是上传博客文章必备内容</p><p><code>git</code>在自己电脑的软件商城就可下载</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201208181337553.png" alt="image-20201208181337553"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h2><p>要安装<code>Node.js</code>，首先需要去下载对应系统安装包，下载地址<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a> </p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/th1twh6f93.png" alt="th1twh6f93"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><h3 id="1-双击下载好的安装包；"><a href="#1-双击下载好的安装包；" class="headerlink" title="1.双击下载好的安装包；"></a>1.双击下载好的安装包；<img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/n9mkyvqg6u.png" alt="n9mkyvqg6u"></h3><h3 id="2-下一步"><a href="#2-下一步" class="headerlink" title="2.下一步"></a>2.下一步</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/5fsjj42yxb.png" alt="5fsjj42yxb"></p><h3 id="3-勾选同意并下一步"><a href="#3-勾选同意并下一步" class="headerlink" title="3.勾选同意并下一步"></a>3.勾选同意并下一步</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/oxj5nic6yo.png" alt="oxj5nic6yo"></p><h3 id="4-除了修改路径一路next"><a href="#4-除了修改路径一路next" class="headerlink" title="4.除了修改路径一路next"></a>4.除了修改路径一路next</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/hjrqiyvpoz.png" alt="hjrqiyvpoz"></p><h3 id="5-建议不作修改，直接下一步，当然你也可以对里边所需服务进行勾选；"><a href="#5-建议不作修改，直接下一步，当然你也可以对里边所需服务进行勾选；" class="headerlink" title="5.建议不作修改，直接下一步，当然你也可以对里边所需服务进行勾选；"></a>5.建议不作修改，直接下一步，当然你也可以对里边所需服务进行勾选；</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/3y2gn9v8ik.png" alt="3y2gn9v8ik"></p><h3 id="6-所需工具自己需要就勾选，不需要就直接下一步；"><a href="#6-所需工具自己需要就勾选，不需要就直接下一步；" class="headerlink" title="6.所需工具自己需要就勾选，不需要就直接下一步；"></a>6.所需工具自己需要就勾选，不需要就直接下一步；</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/ub2de51frm.png" alt="ub2de51frm"></p><p>接下来直接安装就好，看图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/skofo7g.png" alt="skofo7g"></p><h3 id="7-查看版本"><a href="#7-查看版本" class="headerlink" title="7.查看版本"></a>7.查看版本</h3><pre><code>node -v</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/f95fnalbtd.png" alt="f95fnalbtd"></p><p>到此结束！成功安装 <code>Node.js</code>！！！</p><p>由于博主过于懒惰本文来自==》<a href="https://cloud.tencent.com/developer/article/1631257" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1631257</a></p>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat安装及运行</title>
      <link href="posts/60824.html"/>
      <url>posts/60824.html</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat-操作"><a href="#Tomcat-操作" class="headerlink" title="Tomcat 操作"></a>Tomcat 操作</h2><h3 id="Tomcat-安装"><a href="#Tomcat-安装" class="headerlink" title="Tomcat 安装"></a>Tomcat 安装</h3><p>1、解压压缩文件</p><p><a href="https://share.weiyun.com/6drHB4ww" target="_blank" rel="noopener">传送门</a></p><blockquote><p>【注意】</p><p>1、不要有中文路径</p><p>2、建议在非C盘</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204095825295.png" alt="image-20201204095825295"></p><p>2、效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204100135535.png" alt="image-20201204100135535"></p><h3 id="Tomcat-运行"><a href="#Tomcat-运行" class="headerlink" title="Tomcat 运行"></a>Tomcat 运行</h3><p>1、移动到tomcat安装路径下，双击进入</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204100603144.png" alt="image-20201204100603144"></p><p>2、进入bin目录</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204100702009.png" alt="image-20201204100702009"></p><p>3、双击 <code>startup.bat</code> 启动 <code>Tomcat</code></p><blockquote><p>【注意】区别于 <code>startup.sh</code> ，此脚本用于 <code>Linux</code> 下 <code>Tomcat</code> 的启动，建议打开文件扩展名方便查看</p><pre><code>查看 -&gt; 勾选文件扩展名</code></pre></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204101054741.png" alt="image-20201204101054741"></p><blockquote><p>双击之后稍等片刻，会弹窗下面的窗口</p></blockquote><p>4、出现图中显示毫秒值的字样说明启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204101556218.png" alt="image-20201204101556218"></p><h3 id="Tomcat-运行失败原因"><a href="#Tomcat-运行失败原因" class="headerlink" title="Tomcat 运行失败原因"></a>Tomcat 运行失败原因</h3><blockquote><p>如果一闪而过，说明没有配置 <code>JAVA_HOME</code> 环境变量</p></blockquote><p>1、选择此电脑中的属性并打开</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204102023399.png" alt="image-20201204102023399"></p><p>2、点击高级系统设置</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204102515418.png" alt="image-20201204102515418"></p><p>3、选择高级下面的环境变量</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204102613087.png" alt="image-20201204102613087"></p><p>4、在系统变量下点击新建</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204102723837.png" alt="image-20201204102723837"></p><p>5、输入变量名并点击浏览目录</p><pre><code>JAVA_HOME</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204102848860.png" alt="image-20201204102848860"></p><p>6、找到 <code>JDK</code> 在系统中的位置并选中点击确定</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204103045459.png" alt="image-20201204103045459"></p><p>7、配置好变量名和变量值后点击确定</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204103132731.png" alt="image-20201204103132731"></p><p>8、此时我们发现系统变量中已经有了JAVA_HOME，点击确定</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204103228156.png" alt="image-20201204103228156"></p><p>9、点击确定</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204103330881.png" alt="image-20201204103330881"></p><p>10、此时环境变量已经配置好，重新点击 <code>startup.bat</code> 就能成功打开 <code>Tomcat</code> 服务器软件</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201204103611413.png" alt="image-20201204103611413"></p><h3 id="Tomcat-测试访问"><a href="#Tomcat-测试访问" class="headerlink" title="Tomcat 测试访问"></a>Tomcat 测试访问</h3><p>打开 Tomcat 服务器软件后在浏览器的网址栏中输入下面的网址，能跳转到 Tomcat 主页说明访问成功</p><pre class="line-numbers language-lang-http"><code class="language-lang-http">http://localhost:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410402344.png" alt="image-2020120410402344"></p><h3 id="Tomcat-停止"><a href="#Tomcat-停止" class="headerlink" title="Tomcat 停止"></a>Tomcat 停止</h3><p>在 <code>Tomcat</code> 的 <code>bin</code> 目录下点击 <code>shutdown.bat</code> 即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410432460.png" alt="image-2020120410432460"></p><h3 id="Tomcat-中导入前端静态项目"><a href="#Tomcat-中导入前端静态项目" class="headerlink" title="Tomcat 中导入前端静态项目"></a>Tomcat 中导入前端静态项目</h3><blockquote><p>我们可以将一些写好的 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>、图片等静态资源组成的项目通过 <code>Tomcat</code> 服务器使用浏览器对其进行访问，这里我使用了一个最简单的测试项目，同学们可自行选择自己写好的页面进行测试，只需要把项目所在文件夹整个复制到 <code>Tomcat</code> 的 <code>webapps</code> 目录下即可</p></blockquote><p>1、启动 <code>Tomcat</code> 服务器</p><p>2、进入到 <code>Tomcat</code> 安装路径下的 <code>webapps</code> 文件路径</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410464251.png" alt="image-2020120410464251"></p><p>3、将前端页面所在文件夹直接复制过来即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410505186.png" alt="image-2020120410505186"></p><blockquote><p>进入此项目发现只有一个 <code>test.html</code> 页面</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410540696.png" alt="image-2020120410540696"></p><p>内容如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410551079.png" alt="image-2020120410551079"></p></blockquote><p>4、在浏览器中输入下面格式的网址即可访问到对应的项目页面</p><pre><code>格式：http://localhost:8080/项目名/资源名例如：http://localhost:8080/project/test.html</code></pre><p>5、效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120410563110.png" alt="image-2020120410563110"></p>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="posts/3410.html"/>
      <url>posts/3410.html</url>
      
        <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p><code>JavaScript Object Notation</code><br>   （JavaScript Object Notation，JavaScript对象表示法，读作/ˈdʒeɪsən/）是一种由道格拉斯·克罗克福特构想和设计、轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式，并且采用了类似于C语言家族的一些习惯</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、存储和交换文本信息的语法，类似XML</p><p>2、轻量级（小、快）</p><p>3、可读性强（容易解析）</p><p>案例代码</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    "firstName": "John",    "lastName": "Smith",    "sex": "male",    "age": 25,    "married": false,    "address":     {        "streetAddress": "21 2nd Street",        "city": "New York",        "state": "NY",        "postalCode": "10021"    },    "phoneNumber":     [        {          "type": "home",          "number": "212 555-1234"        },        {          "type": "fax",          "number": "646 555-4567"        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p>JSON 的语法基本上可以视为 JavaScript 语法的一个子集，包括以下内容：</p><ul><li>数据使用键/值对表示。建议键使用引号引起来！</li><li>键/值对使用 ,（逗号）分割。</li><li>使用大括号保存对象，每个名称后面跟着一个 ‘:’（冒号）</li><li>使用方括号保存数组，数组值使用 ,（逗号）分割。</li></ul><p>案例代码</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    "book": [        {            "id":"01",            "language": "Java",            "edition": "third",            "author": "Herbert Schildt"        },        {            "id":"07",            "language": "C++",            "edition": "second"            "author": "E.Balagurusamy"    }]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JSON 支持以下两种数据结构：</p><ul><li><strong>键/值对集合：</strong> 这一数据结构由不同的编程语言支持。</li><li><strong>有序的值列表：</strong> 包括数组，列表，向量或序列等等。</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><h4 id="JSON-值"><a href="#JSON-值" class="headerlink" title="JSON 值"></a>JSON 值</h4><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>对象（花括号里）</li><li>数组（中括号里）</li><li>null</li></ul><h4 id="数字、字符串、逻辑值"><a href="#数字、字符串、逻辑值" class="headerlink" title="数字、字符串、逻辑值"></a>数字、字符串、逻辑值</h4><p>案例代码</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    "name": "buffer",    age: 16,    'gender': true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><blockquote><p>JSON 对象在花括号中书写：</p><p>对象可以包含多个键/值对</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    "id":001,     "name":"张三",     "age":18}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>案例代码</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    name : ["张三", '李四', '王五'],    age : ["1", '2', 3],    info : ['帅']}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><blockquote><ol><li>数据使用[]包含</li><li>在[]都是JSON格式对象</li><li>每一个对象之间使用逗号隔开，同时最后一个元素不需要逗号</li></ol></blockquote><p>案例代码1</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    person1: [        {            "name": "张三"        },         {            "age": 1        },         {            "gender": true        }    ],    person1: [        {            "name": "李四"        },         {            "age": 2        },         {            "gender": true        }    ],    person1: [        {            "name": "翠花"        },         {            "age": 3        },         {            "gender": false        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{    "person1": [        {            "name": "张三",            "age": 13,            "gender": true        }    ],    "person2": [        {            "name": "李四",            "age": 15,            "gender": true        }    ],    "person3": [        {            "name": "翠花",            "age": 19,            "gender": false        }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON数据获取"><a href="#JSON数据获取" class="headerlink" title="JSON数据获取"></a>JSON数据获取</h3><blockquote><p>1、json对象.键名</p><p>2、json对象[“键名”]</p><p>3、数组对象[下标]    -》  对应数组</p></blockquote><p>案例代码一</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var person = {"name":"张三"};var name = person.name;alert(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码二</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var person = {"name":"张三"};var name = person["name"];alert(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码三</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var persons = {"person" : ["张三", 16, false]};var name = persons.person[0];alert(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码四</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var persons = {    "person": [{        "name": "张三"    }, {        "age": 16    }, {        "gender": false    }]};var name = persons.person[0]["name"];var age = persons.person[1].age;alert(name + age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码五</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var person = {    "name": "玉田",    "age": 21};for (var key in person) {    alert(key + ":" + person[key]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码六</p><pre class="line-numbers language-lang-javascript"><code class="language-lang-javascript">var persons = [{    "name": "老七",    "age": 47,    "gender": true}, {    "name": "永强",    "age": 23,    "gender": true}, {    "name": "刘英",    "age": 20,    "gender": false}];for (var i = 0; i < persons.length; i++) {    var person = persons[i];    for (var key in person) {        alert(key + ":" + person[key]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JSON数据验证"><a href="#JSON数据验证" class="headerlink" title="JSON数据验证"></a>JSON数据验证</h3><p><a href="www.bejson.com">JSON格式验证</a></p><h3 id="JSON解析【重点】"><a href="#JSON解析【重点】" class="headerlink" title="JSON解析【重点】"></a>JSON解析【重点】</h3><h4 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h4><blockquote><p>JSON对象转Java对象</p><p>Java对象转JSON对象</p></blockquote><h4 id="常见解析器"><a href="#常见解析器" class="headerlink" title="常见解析器"></a>常见解析器</h4><blockquote><p>Gson</p><p>Jackson【常用】</p><p>Fastjson【常用】</p></blockquote><h3 id="Jackson解析"><a href="#Jackson解析" class="headerlink" title="Jackson解析"></a>Jackson解析</h3><blockquote><p>1、导包</p><pre><code>jackson-core-2.2.3.jarjackson-annotations-2.2.3.jarjackson-databind-2.2.3.jar</code></pre><p>2、创建Jackson核心类对象 ObjectMapper</p><p>3、调用相关转换方法实现解析</p></blockquote><p>实体类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Person {    private String name;    private int age;    private boolean gender;    // Constructor、Getters and Setters、toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java对象转JSON字符串"><a href="#Java对象转JSON字符串" class="headerlink" title="Java对象转JSON字符串"></a>Java对象转JSON字符串</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class JacksonTest {    @Test    public void test1() {        // 准备Java对象        Person person = new Person("玉田", 27, true);        // 获取核心类对象ObjectMapper        ObjectMapper mapper = new ObjectMapper();        try {            // 将Java对象转为Json字符串            String jsonString = mapper.writeValueAsString(person);            System.out.println(jsonString);        } catch (JsonProcessingException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="集合转JSON字符串"><a href="#集合转JSON字符串" class="headerlink" title="集合转JSON字符串"></a>集合转JSON字符串</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test2() {    // 准备Java对象    Person person1 = new Person("玉田", 51, true, new Date());    Person person2 = new Person("永强", 34, true, new Date());    Person person3 = new Person("大脚", 29, false, new Date());    // 声明一个集合并将数据添加到集合中    List<Person> list = new ArrayList<>();    list.add(person1);    list.add(person2);    list.add(person3);    // 获取核心类对象ObjectMapper    ObjectMapper mapper = new ObjectMapper();    try {        // 将集合转为Json字符串        String jsonString = mapper.writeValueAsString(list); // [{"name":"玉田","age":51,"gender":true,"birthday":"2020-12-01 15:46:46"},{"name":"永强","age":34,"gender":true,"birthday":"2020-12-01 15:46:46"},{"name":"大脚","age":29,"gender":false,"birthday":"2020-12-01 15:46:46"}]        System.out.println(jsonString);    } catch (JsonProcessingException e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Map转JSON字符串"><a href="#Map转JSON字符串" class="headerlink" title="Map转JSON字符串"></a>Map转JSON字符串</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test4() {    // 准备Java对象    Person person1 = new Person("玉田", 51, true, new Date());    Person person2 = new Person("永强", 34, true, new Date());    Person person3 = new Person("大脚", 29, false, new Date());    // 声明一个集合并将数据添加到集合中    Map<String, Person> map = new HashMap<>();    map.put("person1", person1);    map.put("person2", person2);    map.put("person3", person3);    // 获取核心类对象ObjectMapper    ObjectMapper mapper = new ObjectMapper();    try {        // 将Map转为Json字符串        String jsonString = mapper.writeValueAsString(map); // {"person3":{"name":"大脚","age":29,"gender":false,"birthday":"2020-12-01 15:51:02"},"person2":{"name":"永强","age":34,"gender":true,"birthday":"2020-12-01 15:51:02"},"person1":{"name":"玉田","age":51,"gender":true,"birthday":"2020-12-01 15:51:02"}}        System.out.println(jsonString);    } catch (JsonProcessingException e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="JSON字符串转Java对象【用的不多】"><a href="#JSON字符串转Java对象【用的不多】" class="headerlink" title="JSON字符串转Java对象【用的不多】"></a>JSON字符串转Java对象【用的不多】</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test6() {    String jsonString = "{\"name\":\"玉田\", \"age\":21, \"gender\":true}";    ObjectMapper mapper = new ObjectMapper();    try {        Person person = mapper.readValue(jsonString, Person.class);        System.out.println(person); // Person{name='玉田', age=21, gender=true, birthday=null}    } catch (IOException e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="补充：两个注解的使用"><a href="#补充：两个注解的使用" class="headerlink" title="补充：两个注解的使用"></a>补充：两个注解的使用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 被此注解修饰的变量不会进行Json格式的转换@JsonIgnore// 被此注解修饰的变量会被格式化@JsonFormat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码一：@JsonIgnore</p><p>实体类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Person {    private String name;    private int age;    private boolean gender;    @JsonIgnore    private Date birthday;    // Constructor、Getters and Setters、toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test3() {    // 准备Java对象    Person person = new Person("玉田", 27, true);    person.setBirthday(new Date());    // 获取核心类对象ObjectMapper    ObjectMapper mapper = new ObjectMapper();    try {        // 将Java对象转为Json字符串        String jsonString = mapper.writeValueAsString(person);        System.out.println(jsonString); // {"name":"玉田","age":27,"gender":true}    } catch (JsonProcessingException e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码二：@JsonFormat</p><p>实体类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Person {    private String name;    private int age;    private boolean gender;    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")    private Date birthday;    // Constructor、Getters and Setters、toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test3() {    // 准备Java对象    Person person = new Person("玉田", 27, true);    person.setBirthday(new Date());    // 获取核心类对象ObjectMapper    ObjectMapper mapper = new ObjectMapper();    try {        // 将Java对象转为Json字符串        String jsonString = mapper.writeValueAsString(person);        System.out.println(jsonString); // {"name":"玉田","age":27,"gender":true,"birthday":"2020-12-01 15:37:31"}    } catch (JsonProcessingException e) {        e.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FastJson-解析"><a href="#FastJson-解析" class="headerlink" title="FastJson 解析"></a>FastJson 解析</h3><blockquote><p>1、导包</p><pre><code>fastjson-1.2.47.jar</code></pre><p>2、通过JSON核心类调用解析和转换方法</p></blockquote><h4 id="Java对象转为Json字符串"><a href="#Java对象转为Json字符串" class="headerlink" title="Java对象转为Json字符串"></a>Java对象转为Json字符串</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test1() {    // 准备实体类对象    Person person = new Person("玉田", 21, true, new Date());    // Java对象转为Json字符串    String jsonString = JSON.toJSONString(person);    System.out.println(jsonString); // {"age":21,"birthday":1606839584000,"gender":true,"name":"玉田"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="集合转为Json字符串"><a href="#集合转为Json字符串" class="headerlink" title="集合转为Json字符串"></a>集合转为Json字符串</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test2() {    // 准备Java对象    Person person1 = new Person("玉田", 51, true, new Date());    Person person2 = new Person("永强", 34, true, new Date());    Person person3 = new Person("大脚", 29, false, new Date());    // 声明一个集合并将数据添加到集合中    List<Person> list = new ArrayList<>();    list.add(person1);    list.add(person2);    list.add(person3);    // Java对象转为Json字符串    String jsonString = JSON.toJSONString(list);    System.out.println(jsonString); // [{"age":51,"birthday":1606840178091,"gender":true,"name":"玉田"},{"age":34,"birthday":1606840178091,"gender":true,"name":"永强"},{"age":29,"birthday":1606840178091,"gender":false,"name":"大脚"}]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Json字符串转Java对象"><a href="#Json字符串转Java对象" class="headerlink" title="Json字符串转Java对象"></a>Json字符串转Java对象</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test3() {    // 准备Json字符串    String jsonString = "{\"age\":21,\"birthday\":1606839584000,\"gender\":true,\"name\":\"玉田\"}";    // 将Json字符串解析成实体类对象    Person person = JSON.parseObject(jsonString, Person.class);    System.out.println(person);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Json字符串转Json对象"><a href="#Json字符串转Json对象" class="headerlink" title="Json字符串转Json对象"></a>Json字符串转Json对象</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test4() {    // 准备Json字符串    String jsonString = "{\"age\":21,\"birthday\":1606839584000,\"gender\":true,\"name\":\"玉田\"}";    // 将Json字符串转为Json对象    JSONObject jsonObject = JSON.parseObject(jsonString);    System.out.println(jsonObject);    // 根据键获取对应的值    String name = jsonObject.getString("name");    System.out.println(name);    System.out.println(jsonObject.getInteger("age"));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Json字符串转Json数组"><a href="#Json字符串转Json数组" class="headerlink" title="Json字符串转Json数组"></a>Json字符串转Json数组</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test5() {    // 准备Json字符串    String jsonString = "[{\"age\":51,\"birthday\":1606840178091,\"gender\":true,\"name\":\"玉田\"},{\"age\":34," +            "\"birthday\":1606840178091,\"gender\":true,\"name\":\"永强\"},{\"age\":29,\"birthday\":1606840178091," +            "\"gender\":false,\"name\":\"大脚\"}]";    // Json字符串转Json数组    JSONArray objects = JSON.parseArray(jsonString);    System.out.println(objects);    // 增强for循环获取所有的Json对象    for (Object object : objects) {        // 强制类型转换        JSONObject jsonObject1 = (JSONObject) object;        // 根据键获取对应的值        System.out.println(jsonObject1.getString("name"));        System.out.println(jsonObject1.getInteger("age"));    }    // 获取Json数组中指定下标位置的java对象    Person person = objects.getObject(2, Person.class);    System.out.println(person);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Json数组转集合"><a href="#Json数组转集合" class="headerlink" title="Json数组转集合"></a>Json数组转集合</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">@Testpublic void test6() {    // 准备Json字符串    String jsonString = "[{\"age\":51,\"birthday\":1606840178091,\"gender\":true,\"name\":\"玉田\"},{\"age\":34," +            "\"birthday\":1606840178091,\"gender\":true,\"name\":\"永强\"},{\"age\":29,\"birthday\":1606840178091," +            "\"gender\":false,\"name\":\"大脚\"}]";    // Json字符串转Json数组    JSONArray objects = JSON.parseArray(jsonString);    // 讲Json数组转为集合    List<Person> list = objects.toJavaList(Person.class);    // 增强for循环拿到所有的对象    for (Person person : list) {        System.out.println(person);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Web相关概念"><a href="#Web相关概念" class="headerlink" title="Web相关概念"></a>Web相关概念</h2><h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><h4 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h4><blockquote><p>C/S架构的全称为Client Server，即客户机/服务器模式</p></blockquote><h5 id="C-S架构的优点"><a href="#C-S架构的优点" class="headerlink" title="C/S架构的优点"></a>C/S架构的优点</h5><ol><li>C/S架构的界面和操作可以很丰富。（客户端操作界面可以随意排列，满足客户的需要）</li><li>安全性能可以很容易保证。（因为只有两层的传输，而不是中间有很多层。</li><li>由于只有一层交互，因此响应速度较快。（直接相连，中间没有什么阻隔或岔路，比如QQ，每天那么多人在线，也不觉得慢）</li></ol><h5 id="C-S架构的缺点"><a href="#C-S架构的缺点" class="headerlink" title="C/S架构的缺点"></a>C/S架构的缺点</h5><ol><li>适用面窄，通常用于局域网中。</li><li>用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。</li><li>维护成本高，发生一次升级，则所有客户端的程序都需要改变。</li></ol><h4 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h4><blockquote><p>B/S架构的全称为Browser/Server，即浏览器/服务器结构。</p></blockquote><h5 id="B-S架构的优点"><a href="#B-S架构的优点" class="headerlink" title="B/S架构的优点"></a>B/S架构的优点</h5><ol><li>客户端无需安装，有Web浏览器即可。 </li><li>BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。 </li><li>BS架构无需升级多个客户端，升级服务器即可。可以随时更新版本，而无需用户重新下载。</li></ol><h5 id="B-S架构的缺点"><a href="#B-S架构的缺点" class="headerlink" title="B/S架构的缺点"></a>B/S架构的缺点</h5><ol><li>在跨浏览器上，BS架构不尽如人意。 </li><li>表现要达到CS程序的程度需要花费不少精力。 </li><li>在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。 </li><li>客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax流行后此问题得到了一定程度的缓解）</li></ol><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><blockquote><p>可以理解为前端的固定页面，所有人访问看到的效果是相同的，这里面包含HTML、CSS、JS、图片等等，不需要查数据库也不需要程序处理，直接就能够显示的页面，如果想修改内容则必须修改页面，但是访问效率相当高。</p></blockquote><h4 id="动态资源"><a href="#动态资源" class="headerlink" title="动态资源"></a>动态资源</h4><blockquote><p>需要程序处理或者从数据库中读数据，能够根据不同的条件在页面显示不同的数据，即每个用户访问相同资源后，得到的结果可能不一样。动态资源被访问后，需要先转换为静态资源，再返回给浏览器，所以内容更新不需要修改页面但是访问速度不及静态页面。</p></blockquote><p><img src="D:/java上课案例/12月4日/Pictures/资源分类.bmp" alt=""></p><h3 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>通信设备在网络上的唯一标示，可以通过IP地址找到通信所在的设备</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>应用程序在计算机中的唯一标识。</p><blockquote><p>范围是  0~65535</p></blockquote><h4 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h4><p>规定了数据传输的规则</p><h3 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h3><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>服务器：安装了服务器软件的计算机</p><p>服务器软件：接收用户的请求，处理请求，做出响应</p><p>Web服务器软件：通过浏览器接收用户的请求，处理请求，做出响应</p><p>​    【重点】在 Web 服务器软件中，可以部署 Web 项目，让用户通过浏览器来访问这些项目</p></blockquote><h3 id="常见-Java-相关的-Web-服务器软件"><a href="#常见-Java-相关的-Web-服务器软件" class="headerlink" title="常见 Java 相关的 Web 服务器软件"></a>常见 Java 相关的 Web 服务器软件</h3><div class="table-container"><table><thead><tr><th>Web服务器软件</th><th>描述</th></tr></thead><tbody><tr><td>webLogic</td><td>oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的</td></tr><tr><td>webSphere</td><td>IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的</td></tr><tr><td>JBOSS</td><td>JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的</td></tr><tr><td>Tomcat</td><td>Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范。开源，免费</td></tr></tbody></table></div><p>【注意】Apache不等于Tomcat，打个比方：apache是一辆卡车，上面可以装一些东西如html等。但是不能装水，要装水必须要有容器（桶），tomcat就是一个桶（装像JAVA这样的水），而这个桶也可以不放在卡车上。</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p><p>官网</p><pre class="line-numbers language-lang-http"><code class="language-lang-http">https://tomcat.apache.org/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>apache-tomcat-8.5.37-windows-x64.zip</code></pre><blockquote><p>解压即安装</p></blockquote><p>【注意】</p><ul><li>安装路径不要有中文！！！</li><li>配置 JAVA_HOME 环境变量（tomcat运行依赖于JVM，需要指定JDK）</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><div class="table-container"><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>bin</td><td>可执行文件，包含启动和停止的命令</td></tr><tr><td>conf</td><td>配置文件目录，存放Tomcat的配置文件</td></tr><tr><td>lib</td><td>依赖和类库jar包</td></tr><tr><td>logs</td><td>日志目录</td></tr><tr><td>temp</td><td>临时文件目录</td></tr><tr><td>webapps</td><td>非常重要的目录，存放项目的目录</td></tr><tr><td>work</td><td>工作目录，将来JSP文件编译成Servlet存放的目录</td></tr></tbody></table></div><h3 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h3><pre><code># 启动命令  bin/startup.bat  # 停止命令bin/shutdown.bat</code></pre><blockquote><p>【注意】</p><ol><li>不要重复启动，启动之前先关闭已经启动的【可以通过netstat -ano查看被占用的进程PID】</li><li>如果出现闪退：可能是没有配置JAVA_HOME 环境变量</li></ol></blockquote><pre><code>Neither the JAVA_HOME nor the JRE_HOME environment variable is definedAt least one of these environment variable is needed to run this program</code></pre><h3 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h3><ul><li>先启动</li><li>打开浏览器访问</li></ul><pre><code>http://localhost:8080</code></pre><blockquote><p>localhost 本机地址，等于127.0.0.1</p><p>8080 默认端口</p></blockquote><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><ul><li>端口配置  conf/server.xml</li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><Connector port="8888" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>默认端口8080  可以改成其他如：8888</p><p>【注意】一般不建议修改，除非改成80端口，因为80端口是HTTP协议的默认端口号</p></blockquote><ul><li>启动日志乱码 conf/logging.properties</li></ul><pre class="line-numbers language-lang-properties"><code class="language-lang-properties">java.util.logging.ConsoleHandler.level = FINEjava.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatterjava.util.logging.ConsoleHandler.encoding = gbk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>windows 窗口默认编码为GBK,如果输出内容为UTF-8乱码。</p></blockquote><h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>1、直接将项目放到webapps目录下</p><p>2、将项目压缩成war包放到webapps目录下</p><h3 id="idea-整合Tomcat"><a href="#idea-整合Tomcat" class="headerlink" title="idea 整合Tomcat"></a>idea 整合Tomcat</h3><pre><code>1. Settings -&gt; Run Configuration Templates for New Porject2. TomcatServer -&gt; Local3. Application Server  点击  Configuration 找到tomcat安装位置4. OK确认</code></pre><blockquote><p>【一定先把Tomcat整合好】后面创建项目就可以直接选了，如果没有整合，那么需要再创建项目时整合。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="posts/30389.html"/>
      <url>posts/30389.html</url>
      
        <content type="html"><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>Extensible Markup Language可拓展标记语言，是由W3C万维网联盟指定的规范用途:    1. 数据存储，小型数据库，存在一定的CRUD操作可行性    2. 网络端数据的传输    3. 常见配置文件【重要】</code></pre><blockquote><p>【注意】后期大部分配置文件都是XML格式，数据传输不用XML，使用JSON</p></blockquote><h3 id="XML-和-HTML-之间的差异"><a href="#XML-和-HTML-之间的差异" class="headerlink" title="XML 和 HTML 之间的差异"></a>XML 和 HTML 之间的差异</h3><blockquote><p>XML 不是 HTML 的替代。</p><p>XML 和 HTML 为不同的目的而设计：</p><ul><li>XML 被设计用来传输和存储数据，其焦点是数据的内容。</li><li>HTML 被设计用来显示数据，其焦点是数据的外观。</li></ul><p>HTML 旨在显示信息，而 XML 旨在传输信息。</p><p><strong>XML 中的标签可自定义</strong></p></blockquote><h3 id="基本语法【重点】"><a href="#基本语法【重点】" class="headerlink" title="基本语法【重点】"></a>基本语法【重点】</h3><pre><code>1. XML文件后缀名是.xml2. XML第一行是对于当前文件的定义声明3. XML文件中有且只有一个根标签4. 属性值必须使用引号包含，这里推荐使用双引号5. 标签必须正确匹配，正确开始和关闭6. XML标签内严格区分大小写</code></pre><p>案例代码</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"><!--XML声明，版本号加编码集--><?xml version="1.0" encoding="UTF-8"?><students>    <student id = "1">        <name>赵四</name>        <age>18</age>        <gender>男</gender>    </student>    <student id = "2">        <name>刘能</name>        <age>19</age>        <gender>男</gender>    </student>    <student id = "3">        <name>玉田</name>        <age>20</age>        <gender>男</gender>    </student></students><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="XML-文件约束【了解】"><a href="#XML-文件约束【了解】" class="headerlink" title="XML 文件约束【了解】"></a>XML 文件约束【了解】</h3><blockquote><ol><li>DTD<br> 一种简单的约束方式<br> 但是存在一定的约束问题</li></ol><ol><li>Schema<br> 一种复杂XML文件约束方式<br> 非常严谨</li></ol></blockquote><h3 id="XML-实体引用【重点】"><a href="#XML-实体引用【重点】" class="headerlink" title="XML 实体引用【重点】"></a>XML 实体引用【重点】</h3><blockquote><p>且，    对应&amp;</p><pre><code>&amp;amp;</code></pre></blockquote><h3 id="XML-解析【了解】"><a href="#XML-解析【了解】" class="headerlink" title="XML 解析【了解】"></a>XML 解析【了解】</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>XML的解析方式分为四种：</p><p>1、DOM解析；</p><p>2、SAX解析；</p><p>3、JDOM解析；</p><p>4、DOM4J解析。</p><p>其中前两种属于基础方法，是官方提供的平台无关的解析方式；后两种属于扩展方法，它们是在基础的方法上扩展出来的，只适用于java平台。这里只说一下最常用并且性能最好的 <a href="">Dom4j</a> 解析</p></blockquote><h4 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>1、JDOM的一种智能分支，它合并了许多超出基本XML文档表示的功能。</p><p>2、它使用接口和抽象基本类方法。</p><p>3、具有性能优异、灵活性好、功能强大和极端易用的特点。</p><p>4、是一个开放源码的文件，被很多优秀的开源框架所使用</p><h5 id="jar-包"><a href="#jar-包" class="headerlink" title="jar 包"></a>jar 包</h5><pre class="line-numbers language-lang-jar"><code class="language-lang-jar">dom4j-1.6.1.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://share.weiyun.com/rIQCLXRk" target="_blank" rel="noopener">下载传送门</a></p><h5 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 核心类 SAXReaderclass SAXReader {}// 获取Document对象Document read(File file);// 获取指定节点的节点类对象Element element();// 获取指定节点所有的节点对象，返回的是一个listList elements();// 获取节点名String getName();// 获取节点对应的数据String getText();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo {    public static void main(String[] args) throws DocumentException {        // 获取SAXReader对象        SAXReader reader = new SAXReader();        // 获取对应的Document对象        Document document = reader.read(new File("./XML/src/Student.xml"));        // 获取跟节点对象        Element rootElement = document.getRootElement();        // 获取根节点对象的节点名并展示        System.out.println(rootElement.getName());        // 获取根节点下的所有子节点对应的List集合        List<Element> elements = rootElement.elements();        // 遍历获取所有的子节点        for (Element element : elements) {            // 展示子节点的节点名以及id属性所对应的值            System.out.println(element.getName() + ":" + element.attribute("id").getValue());            // 获取更深一层的子节点            List<Element> list = element.elements();            // 遍历获取所有的子节点            for (Element element1 : list) {                // 拿到子节点的节点名以及对应的数据                System.out.println(element1.getName() + ":" + element1.getText());            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在idea中显示并查询MySQL的表</title>
      <link href="posts/12605.html"/>
      <url>posts/12605.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、先下一个jar包"><a href="#一、先下一个jar包" class="headerlink" title="一、先下一个jar包"></a>一、先下一个jar包</h3><p>【注意】一定要下到自己能找到的位置，可根据自己的版本进行下载</p><p><a href="https://share.weiyun.com/IBBDrqk7" target="_blank" rel="noopener">传送门</a></p><p>如传送门并非自己所需jar包，请前往—&gt;下载<a href="https://mvnrepository.com/search?q=mysql" target="_blank" rel="noopener">Attention Required! | Cloudflare (mvnrepository.com)</a></p><h3 id="二、寻找过程"><a href="#二、寻找过程" class="headerlink" title="二、寻找过程"></a>二、寻找过程</h3><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>在idea中找到如图所在位置的Database；</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201095442.png" alt="img"></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>点开然后找到如图所示的“+”后点击“+”</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201100837.png" alt="img"></p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201102426.png" alt="img"></p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>找到MySQL点击，出现如下图所示：再次点击Driver:中的MySQL找到自己的jar包</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201112359.png" alt="20201201112319"></p><p>找到自己的jar包</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201112150.png" alt="jar"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201110605.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201112652.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201132845.png" alt="122"></p><p>到此就完成了·······</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130221106.jpg" alt="110"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用cmd命令使用MySQL</title>
      <link href="posts/3561.html"/>
      <url>posts/3561.html</url>
      
        <content type="html"><![CDATA[<p>本篇文章乃是如何用cmd命令行操作mysql，如想了解在mysql内进行创建数据库等操作请参考：如下这篇</p><p><a href="https://ialoe.top/posts/51549.html">MySQL数据库的创建及使用 | 白月光 | 秦同学 (ialoe.top)</a></p><h3 id="一、进入MySQL数据库"><a href="#一、进入MySQL数据库" class="headerlink" title="一、进入MySQL数据库"></a>一、进入MySQL数据库</h3><pre><code>mysql -h localhost -u root -p</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201129164246.png" alt="image-20201129164243548"></p><p>以下内容为进入MySQL中</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130120608.png" alt="img"></p><h3 id="二、查看数据库"><a href="#二、查看数据库" class="headerlink" title="二、查看数据库"></a>二、查看数据库</h3><pre><code>show databases;</code></pre><p>以下为我的所有数据库</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130121135.png" alt="img"></p><h3 id="三、删除其中为rx1903的数据库；"><a href="#三、删除其中为rx1903的数据库；" class="headerlink" title="三、删除其中为rx1903的数据库；"></a>三、删除其中为rx1903的数据库；</h3><p>输入命令</p><pre><code>drop database rx1903;</code></pre><p>出现以下内容为操作成功！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130122031.png" alt="img"></p><h3 id="四、创建数据库："><a href="#四、创建数据库：" class="headerlink" title="四、创建数据库："></a>四、创建数据库：</h3><p>创建一个名为rx1903的数据库；</p><pre><code>create database rx1903;</code></pre><p>数据库创建完成后，可以使用以下命令查看数据库的定义；</p><pre><code>show create database rx1903;</code></pre><p>定义如下：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130123151.png" alt="img"></p><p>先进入rx1903数据库；</p><pre><code>use rx1903;</code></pre><p>以下为已进入</p><p>【注意】必须进入某个数据库中然后才能创建数据表；</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130123848.png" alt="img"></p><h3 id="MySQL常用指令"><a href="#MySQL常用指令" class="headerlink" title="MySQL常用指令"></a>MySQL常用指令</h3><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">连接：mysql -h主机地址 -u用户名 －p用户密码 （注:u与root可以不用加空格，其它也一样）断开：exit （回车）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">创建授权：grant select on 数据库.* to 用户名@登录主机 identified by \"密码\"修改密码：mysqladmin -u用户名 -p旧密码 password 新密码删除授权: revoke select,insert,update,delete om *.* fromtest2@localhost;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">显示数据库：show databases;显示数据表：show tables;显示表结构：describe 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">创建库：create database 库名;删除库：drop database 库名;使用库：use 库名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">创建表：create table 表名 (字段设定列表);删除表：drop table 表名;修改表：alter table t1 rename t2查询表：select * from 表名;清空表：delete from 表名;备份表: mysqlbinmysqldump -h(ip) -uroot -p(password) databasenametablename > tablename.sql恢复表: mysqlbinmysql -h(ip) -uroot -p(password) databasenametablename < tablename.sql（操作前先把原来表删除）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">增加列：ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,ADDINDEX (c);修改列：ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b cCHAR(20);删除列：ALTER TABLE t2 DROP COLUMN c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">备份数据库：mysql\bin\mysqldump -h(ip) -uroot -p(password) databasename> database.sql恢复数据库：mysql\bin\mysql -h(ip) -uroot -p(password) databasename< database.sql复制数据库：mysql\bin\mysqldump --all-databases >all-databases.sql修复数据库：mysqlcheck -A -o -uroot -p54safer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>文本数据导入：load data local infile \&quot;文件名\&quot; into table 表名;数据导入导出：mysql\bin\mysqlimport database tables.txt</code></pre><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">select * from emp;  #注释#---------------------------#----命令行连接MySql---------#启动mysql服务器net start mysql#关闭 net stop mysql#进入mysql -h 主机地址 -u 用户名 －p 用户密码#退出exitstatus;显示当前mysql的version的各种信息。#---------------------------#----MySql用户管理---------#修改密码:首先在DOS 下进入mysql安装路径的bin目录下，然后键入以下命令:mysqladmin -uroot -p123 password 456;#增加用户#格式:grant 权限 on 数据库.* to 用户名@登录主机 identified by '密码'/*如，增加一个用户user1密码为password1，让其可以在本机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令：grant select,insert,update,delete on *.* to user1@localhost Identified by "password1";如果希望该用户能够在任何机器上登陆mysql，则将localhost改为"%"。如果你不想user1有密码，可以再打一个命令将密码去掉。grant select,insert,update,delete on mydb.* to user1@localhost identified by "";*/grant all privileges on wpj1105.* to sunxiao@localhost identified by '123';   #all privileges 所有权限#----------------------------#-----MySql数据库操作基础-----#显示数据库show databases;#判断是否存在数据库wpj1105,有的话先删除drop database if exists wpj1105;#创建数据库create database wpj1105;#删除数据库drop database wpj1105;#使用该数据库use wpj1105;#显示数据库中的表show tables;#先判断表是否存在,存在先删除drop table if exists student;#创建表create table student(id int auto_increment primary key,name varchar(50),sex varchar(20),date varchar(50),content varchar(100))default charset=utf8;#删除表drop table student;#查看表的结构describe student;  #可以简写为desc student;#插入数据insert into student values(null,'aa','男','1988-10-2','......');insert into student values(null,'bb','女','1889-03-6','......');insert into student values(null,'cc','男','1889-08-8','......');insert into student values(null,'dd','女','1889-12-8','......');insert into student values(null,'ee','女','1889-09-6','......');insert into student values(null,'ff','null','1889-09-6','......');#查询表中的数据select * from student;select id,name from student;#修改某一条数据update student set sex='男' where id=4;#删除数据delete from student where id=5;# and 且select * from student where date>'1988-1-2' and date<'1988-12-1';# or 或select * from student where date<'1988-11-2' or date>'1988-12-1';#betweenselect * from student where date between '1988-1-2' and '1988-12-1';#in 查询制定集合内的数据select * from student where id in (1,3,5);#排序 asc 升序  desc 降序select * from student order by id asc;#分组查询 #聚合函数select max(id),name,sex from student group by sex;select min(date) from student;select avg(id) as '求平均' from student;select count(*) from student;   #统计表中总数select count(sex) from student;   #统计表中性别总数  若有一条数据中sex为空的话,就不予以统计~select sum(id) from student;#查询第i条以后到第j条的数据(不包括第i条)select * from student limit 2,5;  #显示3-5条数据#巩固练习create table c( id int primary key auto_increment, name varchar(10) not null, sex varchar(50) ,  #DEFAULT '男' , age int unsigned, #不能为负值(如为负值 则默认为0) sno int unique    #不可重复);drop table c;desc c;insert into c (id,name,sex,age,sno) values (null,'涛哥','男',68,1);insert into c (id,name,sex,age,sno) values (null,'aa','男',68,2);insert into c (id,name,sex,age,sno) values (null,'平平','男',35,3);...select * from c;#修改数据update c set age=66 where id=2;update c set name='花花',age=21,sex='女' where id=2delete from c where age=21;#常用查询语句select name,age ,id from cselect * from c where age>40 and age<60;  #andselect * from c where age<40 or age<60;  #orselect * from c where age between 40 and 60 #betweenselect * from c where age in (30,48,68,99);     #in 查询指定集合内的数据select * from c order by age desc;      #order by （asc升序 des降序）#分组查询select name,max(age) from c group by sex;  #按性别分组查年龄最大值#聚合函数select min(age) from c;select avg(age) as '平均年龄 ' from c;select count(*) from c;  #统计表中数据总数select sum(age) from c;#修改表的名字#格式:alter table tbl_name rename to new_namealter table c rename to a;#表结构修改create table test(id int not null auto_increment primary key, #设定主键name varchar(20) not null default 'NoName', #设定默认值department_id int not null,position_id int not null,unique (department_id,position_id) #设定唯一值);#修改表的名字#格式:alter table tbl_name rename to new_namealter table test rename to test_rename;#向表中增加一个字段(列)#格式:alter table tablename add columnname type;/alter table tablename add(columnname type);alter table test add  columnname varchar(20);#修改表中某个字段的名字alter table tablename change columnname newcolumnname type;  #修改一个表的字段名alter table test change name uname varchar(50);select * from test;#表position 增加列testalter table position add(test char(10));#表position 修改列testalter table position modify test char(20) not null;#表position 修改列test 默认值alter table position alter test set default 'system';#表position 去掉test 默认值alter table position alter test drop default;#表position 去掉列testalter table position drop column test;#表depart_pos 删除主键alter table depart_pos drop primary key;#表depart_pos 增加主键alter table depart_pos add primary key PK_depart_pos(department_id,position_id);#用文本方式将数据装入数据库表中（例如D:/mysql.txt）load data local infile "D:/mysql.txt" into table MYTABLE;#导入.sql文件命令（例如D:/mysql.sql）source d:/mysql.sql;  #或者  /. d:/mysql.sql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130221106.jpg" alt="110"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC——java与数据库的连接</title>
      <link href="posts/23591.html"/>
      <url>posts/23591.html</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC-概述"><a href="#JDBC-概述" class="headerlink" title="JDBC 概述"></a>JDBC 概述</h3><blockquote><p><code>Java Database Connectivity</code></p><p>由sun公司制定，是<a href="https://baike.baidu.com/item/Java语言" target="_blank" rel="noopener">Java语言</a>中用来规范客户端程序如何来访问数据库的<a href="">应用程序接口</a>，提供了很多直接操作数据库的增删改查方法</p></blockquote><p><strong>JDBC 核心包</strong></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">java.sql.*javax.sql.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="JDBC-MySQL【重点】"><a href="#JDBC-MySQL【重点】" class="headerlink" title="JDBC - MySQL【重点】"></a>JDBC - MySQL【重点】</h3><blockquote><p>用来连接和操作MySQL数据库，需要导入一个核心jar包</p></blockquote><p>【核心 jar 文件】</p><pre><code>mysql-connector-java-5.1.47.jar</code></pre><blockquote><p>【注意】此jar包可以直接在MySQL官网进行下载（比较慢），或者通过 Maven 仓库也能下载（这里能下载到大部分能用到的 jar 包，<strong>建议收藏</strong>）</p><pre class="line-numbers language-lang-url"><code class="language-lang-url">https://mvnrepository.com/artifact/mysql/mysql-connector-java/5.1.47<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="JDBC-Java-数据类型映射"><a href="#JDBC-Java-数据类型映射" class="headerlink" title="JDBC - Java 数据类型映射"></a>JDBC - Java 数据类型映射</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201129114346.png" alt=""></p><h3 id="通过-JDBC-连接-MySQL-数据库"><a href="#通过-JDBC-连接-MySQL-数据库" class="headerlink" title="通过 JDBC 连接 MySQL 数据库"></a>通过 JDBC 连接 MySQL 数据库</h3><p>前提条件</p><pre><code>1、jar包：连接驱动包2、url：确定连接的数据库所在网络地址和对应操作哪一个数据库，由协议名+子协议名+数据源名构成，即        jdbc:mysql://主机地址:端口号/数据库名        【例】jdbc:mysql://localhost:3306/fc20203、user：用户名4、password：密码</code></pre><p>格式</p><pre><code>1、加载驱动2、准备必要的连接参数3、获取数据库连接4、关闭资源！！！</code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/** * 测试数据库连接 */public class Demo1 {    public static void main(String[] args) {        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库以及相关参数、用户名、密码            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8";            String user = "root";            String password = "root";            // 通过参数获取连接            Connection connection = DriverManager.getConnection(url, user, password);            System.out.println(connection);            // 关闭资源            connection.close();        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】连接数据库可以配置一些相关的参数，数据库名与参数之间用 <a href="">?</a> 进行分隔，参数之间通过 <a href="">&amp;</a> 分隔，常用参数及格式如下</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>characterEncoding=utf8</td><td>设置字符集为UTF8</td></tr><tr><td>serverTimezone=Asia/Shanghai</td><td>设置时区<a href="">（JDBC8.0以上必备）</a></td></tr><tr><td>useSSL=true</td><td>使用SSL<a href="">（JDBC8.0以上要改为false）</a></td></tr></tbody></table></div><pre class="line-numbers language-lang-java"><code class="language-lang-java">jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h3 id="数据库驱动加载过程"><a href="#数据库驱动加载过程" class="headerlink" title="数据库驱动加载过程"></a>数据库驱动加载过程</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Driver extends NonRegisteringDriver implements java.sql.Driver {    /*     * Register ourselves with the DriverManager     * 在.class文件加载到内存时运行，并且有且只执行一次     * 代码初始化过程！！！     */     static {        try {            // DriverManager驱动管理器注册了当前com.mysql.jdbc.Driver            // 相对于当前Java程序拥有了连接MySQL数据库的必要的驱动条件            java.sql.DriverManager.registerDriver(new Driver());        } catch (SQLException E) {            throw new RuntimeException("Can't register driver!");        }    }    /**     * Construct a new driver and register it with DriverManager     *      * @throws SQLException     *             if a database error occurs.     */    public Driver() throws SQLException {        // Required for Class.forName().newInstance()    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】后续会用到静态代码块去完成一些初始化的操作</p></blockquote><h3 id="JDBC-核心API"><a href="#JDBC-核心API" class="headerlink" title="JDBC 核心API"></a>JDBC 核心API</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 驱动管理类class java.sql.DriverManager/* * 这里是根据数据库连接URL，对应的user用户名和password密码，获取数据库连接对象 */static java.sql.Connection getConnection(String url, String user, String password);// 数据库连接接口interface java.sql.Connection /* * 获取数据库SQL语句搬运工对象，从Java程序搬运SQL语句到数据库中，同时Statement也是一个资源对象。 */java.sql.Statement createStatement();/* * 获取数据库SQL语句【预处理】搬运工对象，Java程序的SQL语句，在创建PreparedStatement对象时，将SQL语句交给数据库预处理操作，可以解决一定的【SQL语句注入问题】，同时提高一定的效率，PreparedStatement也是一个资源对象 */java.sql.PreparedStatement prepareStatement(String sql);// 数据库SQL语句搬运工对象接口interface java.sql.Statement /* * 执行数据库修改数据，insert,update,delete...，返回值类型是int类型，是当前SQL语句搬运到数据库执行之后，数据库运行对于当前操作受到影响的行数 * 2 rows affected in 5 ms */int executeUpdate(String sql);/* * 执行数据库查询语句，select操作，执行的结果是一个java.sql.ResultSet，结果集对象，当前操作返回值never null */java.sql.ResultSet executeQuery(String sql);// 数据库SQL语句【预处理】搬运工对象接口public interface java.sql.PreparedStatement extends java.sql.Statement/* * 执行数据库修改操作，insert，update，delete...处理的SQL语句是在创建PreparedStatement对象过程预处理的SQL语句，并且返回值是int类型，为当前操作对于数据表中收到影响的行数 */int executeUpdate();/* * 执行数据库查询语句，select操作，的SQL语句是在创建PreparedStatement对象过程预处理的SQL语句，执行的结果是一个java.sql.ResultSet，结果集对象，当前操作返回值never null */java.sql.ResultSet executeQuery();/* * PreparedStatement预处理的SQL语句是可以带有参数的，这里是对于SQL语句参数进行赋值操作，这里有指定的操作下标，和对应的数据，数据类型繁多 */setXXX(int index, XXX value)// 数据库结果集接口interface java.sql.ResultSet /* * 根据查询结果中，字段所处的位置下标获取对应数据，XXX是指定类型(int、String用的最多) */XXX getXXX(int columnIndex);/* * 根据查询结果中，字段所处的字段名获取对应数据，XXX是指定类型(int、String用的最多) * 例int getInt(String columnLabel) */XXX getXXX(String columnLabel);/* * 判断当前查询结果集中是否还有数据可以继续遍历，如果没有。或则当前结果集中是无数据情况 Empty Set，直接返回fasle */boolean next();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Statement-操作-SQL-语句"><a href="#Statement-操作-SQL-语句" class="headerlink" title="Statement 操作 SQL 语句"></a>Statement 操作 SQL 语句</h3><h4 id="增删改操作步骤【重点】"><a href="#增删改操作步骤【重点】" class="headerlink" title="增删改操作步骤【重点】"></a>增删改操作步骤【重点】</h4><pre><code>1、加载驱动2、准备连接数据库所需要的参数3、获取数据库连接4、获取Statement搬运工对象5、准备SQL语句6、执行SQL语句获取受影响的行数</code></pre><h4 id="Statement-插入-SQL-数据操作"><a href="#Statement-插入-SQL-数据操作" class="headerlink" title="Statement 插入 SQL 数据操作"></a>Statement 插入 SQL 数据操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        Connection connection = null;        Statement statement = null;        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库、用户名、密码            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8";            String user = "root";            String password = "root";            // 通过参数获取数据库连接            connection = DriverManager.getConnection(url, user, password);            // 获取Statement对象            statement = connection.createStatement();            // 准备SQL语句            String sql = "insert into student() values(1, '张三', 16, '男', '真帅');";            // 执行SQL语句获取受影响的行数            int affectedRows = statement.executeUpdate(sql);            System.out.println("受影响的行数：" + affectedRows);        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            try {                if (statement != null) {                    statement.close();                }                if (connection != null) {                    connection.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Statement-修改-SQL-数据操作"><a href="#Statement-修改-SQL-数据操作" class="headerlink" title="Statement 修改 SQL 数据操作"></a>Statement 修改 SQL 数据操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    public static void main(String[] args) {        Connection connection = null;        Statement statement = null;        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库、用户名、密码            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8";            String user = "root";            String password = "root";            // 通过参数获取数据库连接            connection = DriverManager.getConnection(url, user, password);            // 获取Statement对象            statement = connection.createStatement();            // 准备SQL语句            String sql = "update student set name = '彭于晏' where id = 1";            // 执行SQL语句获取受影响的行数            int affectedRows = statement.executeUpdate(sql);            System.out.println("受影响的行数：" + affectedRows);        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            try {                if (statement != null) {                    statement.close();                }                if (connection != null) {                    connection.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Statement-删除-SQL-数据操作"><a href="#Statement-删除-SQL-数据操作" class="headerlink" title="Statement 删除 SQL 数据操作"></a>Statement 删除 SQL 数据操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    public static void main(String[] args) {        Connection connection = null;        Statement statement = null;        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库、用户名、密码            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8";            String user = "root";            String password = "root";            // 通过参数获取数据库连接            connection = DriverManager.getConnection(url, user, password);            // 获取Statement对象            statement = connection.createStatement();            // 准备SQL语句            String sql = "delete from student where id = 1;";            // 执行SQL语句获取受影响的行数            int affectedRows = statement.executeUpdate(sql);            System.out.println("受影响的行数：" + affectedRows);        } catch (ClassNotFoundException | SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            try {                if (statement != null) {                    statement.close();                }                if (connection != null) {                    connection.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询操作步骤【重点】"><a href="#查询操作步骤【重点】" class="headerlink" title="查询操作步骤【重点】"></a>查询操作步骤【重点】</h4><pre><code>1、加载驱动2、准备连接数据库所需要的参数3、获取数据库连接4、获取Statement搬运工对象5、准备SQL语句6、执行SQL语句获取结果集对象7、判断结果集对象中是否有数据8、如果结果集对象中存在数据，获取每个数据库字段对应类型的数据</code></pre><h4 id="Statement-查询-SQL-数据操作"><a href="#Statement-查询-SQL-数据操作" class="headerlink" title="Statement 查询 SQL 数据操作"></a>Statement 查询 SQL 数据操作</h4><p>准备实体类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private Integer id;    private String name;    private Integer age;    private String gender;    private String info;    // Constructor、Getter and Setter、toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】根据阿里巴巴开发手册，实体类成员变量要用包装类！！！</p></blockquote><p>案例代码一：查询单行</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    public static void main(String[] args) {        // 声明资源        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 准备参数            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=UTF8";            String user = "root";            String password = "root";            // 获取连接            connection = DriverManager.getConnection(url, user, password);            // 获取搬运工对象            statement = connection.createStatement();            // 准备SQL语句            String sql = "select * from student where id = 1";            // 执行SQL语句并获取结果集            resultSet = statement.executeQuery(sql);            Student student = null;            // 判断结果集中是否还有下一行数据            while (resultSet.next()) {                // 从结果集中获取对应类型的数据                int id = resultSet.getInt(1);                String name = resultSet.getString(2);                int age = resultSet.getInt(3);                String gender = resultSet.getString(4);                String info = resultSet.getString(5);                // 通过获取到的数据创建实体类对象                student = new Student(id, name, age, gender, info);            }            // 展示            System.out.println(student);        } catch (SQLException | ClassNotFoundException e) {            e.printStackTrace();        } finally {            // 关闭资源            try {                if (resultSet != null) {                    resultSet.close();                }                if (statement != null) {                    statement.close();                }                if (connection != null) {                    connection.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码二：查询多行</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo6 {    public static void main(String[] args) {        // 声明资源        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try {            // 加载驱动            Class.forName("com.mysql.jdbc.Driver");            // 准备参数            String url = "jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=UTF8";            String user = "root";            String password = "root";            // 获取连接            connection = DriverManager.getConnection(url, user, password);            // 获取搬运工对象            statement = connection.createStatement();            // 准备SQL语句            String sql = "select * from student";            // 执行SQL语句并获取结果集            resultSet = statement.executeQuery(sql);            // 声明一个集合用来存储多条数据对应的实体类对象            ArrayList<Student> arrayList = new ArrayList<>();            // 判断结果集中是否还有下一行数据            while (resultSet.next()) {                // 从结果集中获取对应类型的数据                int id = resultSet.getInt(1);                String name = resultSet.getString(2);                int age = resultSet.getInt(3);                String gender = resultSet.getString(4);                String info = resultSet.getString(5);                // 通过获取到的数据创建实体类对象                Student student = new Student(id, name, age, gender, info);                // 将实体类对象添加到集合中                arrayList.add(student);            }            // 展示            System.out.println(arrayList);        } catch (SQLException | ClassNotFoundException e) {            e.printStackTrace();        } finally {            // 关闭资源            try {                if (resultSet != null) {                    resultSet.close();                }                if (statement != null) {                    statement.close();                }                if (connection != null) {                    connection.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常见数据库连接"><a href="#常见数据库连接" class="headerlink" title="常见数据库连接"></a>常见数据库连接</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">-------------------------------oracle------------------驱动：oracle.jdbc.driver.OracleDriverURL：jdbc:oracle:thin:@machine_name:port:dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认是1521-------------------------------mysql-------------------驱动：com.mysql.jdbc.DriverURL：jdbc:mysql://machine_name:port/dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认3306    ------------------------------SQL Server---------------驱动：com.microsoft.jdbc.sqlserver.SQLServerDriverURL：jdbc:microsoft:sqlserver://<machine_name><:port>;DatabaseName=<dbname>注：machine_name：数据库所在的机器的名称；      port：端口号，默认是1433------------------------------DB2----------------------驱动：com.ibm.db2.jdbc.app.DB2DriverURL：jdbc:db2://<machine_name><:port>/dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认是5000-------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="封装工具类简化操作"><a href="#封装工具类简化操作" class="headerlink" title="封装工具类简化操作"></a>封装工具类简化操作</h3><p>核心API</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取一个属性对象Properties();// 通过字符输入流加载数据到属性对象中void load(Reader reader);// 获取属性文件中的键的对应值String getProperty(String key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>db.properties</p><pre class="line-numbers language-lang-properties"><code class="language-lang-properties">driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=UTF8user=rootpassword=root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>JdbcUtils</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.io.FileReader;import java.io.IOException;import java.sql.*;import java.util.Properties;/** * JDBC工具类 */public class JdbcUtils {    private static String url = null;    private static String user = null;    private static String password = null;    private static Connection connection = null;    private static Statement statement = null;    private static ResultSet resultSet = null;    // 使用静态代码块进行初始化操作：加载驱动    static {        try {            // 创建Properties对象用于从Properties文件中读取数据            Properties properties = new Properties();            // 通过字符输入流加载数据到properties中            properties.load(new FileReader("./src/db.properties"));            // 获取对应的数据            String driver = properties.getProperty("driver");            url = properties.getProperty("url");            user = properties.getProperty("user");            password = properties.getProperty("password");            // 加载驱动            Class.forName(driver);        } catch (ClassNotFoundException | IOException e) {            e.printStackTrace();        }    }    /**     * 获取连接     *     * @return 返回数据库的连接     */    public static Connection getConnection() {        try {            connection = DriverManager.getConnection(url, user, password);        } catch (SQLException e) {            e.printStackTrace();        }        return connection;    }    /**     * 获取搬运工对象     *     * @return 返回一个搬运工对象     */    private static Statement getStatement() {        if (connection == null) {            connection = getConnection();        }        try {            statement = connection.createStatement();        } catch (SQLException e) {            e.printStackTrace();        }        return statement;    }    /**     * 增删改方法     *     * @param sql 传入一个SQL语句     * @return 返回受影响的行数     */    public static int executeUpdate(String sql) {        if (statement == null) {            statement = getStatement();        }        int affectedRows = 0;        try {            affectedRows = statement.executeUpdate(sql);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            close(statement, connection);        }        return affectedRows;    }    /**     * 查询方法     *     * @param sql 传入一个SQL语句     * @return 返回一个受影响的行数     */    public static ResultSet executeQuery(String sql) {        try {            resultSet = getStatement().executeQuery(sql);        } catch (SQLException e) {            e.printStackTrace();        }        return resultSet;    }    /*     * 重载关闭资源方法，以满足多种场景     */    public static void close(Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet) {        close(resultSet, statement, connection);    }    public static void close(Statement statement, Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet, Statement statement, Connection connection) {        try {            if (resultSet != null) {                resultSet.close();            }            if (statement != null) {                statement.close();            }            if (connection != null) {                connection.close();            }        } catch (SQLException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用单元测试简化操作</p><blockquote><p>【注意】需要导入一个单元测试所需要的 jar 包</p><pre><code>junit-4.10.jar</code></pre><p>使用单元测试不需要再声明 main 方法，只需要在方法声明上加上 <a href="">@Test</a> 注解即可，各个测试方法之间相互独立不受影响</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    /**     * 测试修改数据     */    @Test    public void testUpdate() {        String sql = "update student set age = 20 where id = 1;";        int affectedRows = JdbcUtils.executeUpdate(sql);        System.out.println("受影响的行数为：" + affectedRows);    }    /**     * 测试删除数据     */    @Test    public void testDelete() {        String sql = "delete from student where id = 4;";        int affectedRows = JdbcUtils.executeUpdate(sql);        System.out.println("受影响的行数为：" + affectedRows);    }    /**     * 测试插入数据     */    @Test    public void testInsert() {        String sql = "insert into student(name, age, gender, info) values('张三', 18, '男', '多财多亿');";        int affectedRows = JdbcUtils.executeUpdate(sql);        System.out.println("受影响的行数为：" + affectedRows);    }    /**     * 测试查询单条数据     */    @Test    public void testQueryOne() {        String sql = "select * from student where id = 1";        ResultSet resultSet = JdbcUtils.executeQuery(sql);        try {            while (resultSet.next()) {                int id = resultSet.getInt("id");                String name = resultSet.getString("name");                int age = resultSet.getInt("age");                String gender = resultSet.getString("gender");                String info = resultSet.getString("info");                Student student = new Student(id, name, age, gender.charAt(0), info);                System.out.println(student);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.close(resultSet);        }    }    /**     * 测试查询多条数据     */    @Test    public void testQueryAll() {        ArrayList<Student> list = new ArrayList<>();        String sql = "select * from student";        ResultSet resultSet = JdbcUtils.executeQuery(sql);        try {            while (resultSet.next()) {                int id = resultSet.getInt("id");                String name = resultSet.getString("name");                int age = resultSet.getInt("age");                String gender = resultSet.getString("gender");                String info = resultSet.getString("info");                Student student = new Student(id, name, age, gender.charAt(0), info);                list.add(student);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.close(resultSet);        }        System.out.println(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SQL注入【重点】"><a href="#SQL注入【重点】" class="headerlink" title="SQL注入【重点】"></a>SQL注入【重点】</h3><blockquote><p>SQL 注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的 SQL 语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息，甚至篡改数据库</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    // 使用正确的用户名和密码登录成功    @Test    public void testLogin() {        String sql = "select * from account where username = '张三' and password = '123456';";        ResultSet resultSet = JdbcUtils.executeQuery(sql);        try {            if (resultSet.next()) {                System.out.println("登录成功");            } else {                System.out.println("登录失败");            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.close(resultSet);        }    }    // 通过SQL注入使用异常的密码登录成功    @Test    public void testSqlInject() {        String sql = "select * from account where username = '张三' and (password = 'iglrne' or 1 = 1);";        ResultSet resultSet = JdbcUtils.executeQuery(sql);        try {            if (resultSet.next()) {                System.out.println("登录成功");            } else {                System.out.println("登录失败");            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            JdbcUtils.close(resultSet);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】Statement 存在 SQL 注入问题，而 PreparedStatement 可以有效的避免 SQL 注入！</p><p>以后只能使用 PreparedStatement ，因为操作性更强，并且安全性更高</p></blockquote><h3 id="通过-PreparedStatement-操作-SQL-语句"><a href="#通过-PreparedStatement-操作-SQL-语句" class="headerlink" title="通过 PreparedStatement 操作 SQL 语句"></a>通过 PreparedStatement 操作 SQL 语句</h3><p>PreparedStatement 实例包含已编译的 SQL 语句。这就是使语句“准备好”。包含于 PreparedStatement 对象中的 SQL 语句可具有一个或多个 IN 参数。IN参数的值在 SQL 语句创建时未被指定。相反的，该语句为每个 IN 参数保留一个问号（“？”）作为<a href="https://baike.baidu.com/item/占位符" target="_blank" rel="noopener">占位符</a>。每个问号的值必须在该语句执行之前，通过适当的setXXX 方法来提供。</p><p>由于 PreparedStatement 对象已<a href="https://baike.baidu.com/item/预编译" target="_blank" rel="noopener">预编译</a>过，所以其执行速度要快于 Statement 对象。因此，多次执行的 SQL 语句经常创建为 PreparedStatement 对象，以提高效率。</p><p>作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。另外它还添加了一整套方法，用于设置发送给数据库以取代 IN 参数<a href="https://baike.baidu.com/item/占位符" target="_blank" rel="noopener">占位符</a>的值。同时，三种方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数。这些方法的 Statement 形式（接受 SQL 语句参数的形式）不应该用于 PreparedStatement 对象。</p><blockquote><p>【注意】应该始终以PreparedStatement代替Statement，也就是说，在任何时候都不要使用Statement。</p></blockquote><h4 id="PreparedStatement-查询操作"><a href="#PreparedStatement-查询操作" class="headerlink" title="PreparedStatement 查询操作"></a>PreparedStatement 查询操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    @Test    public void testPreparedStatement() {        // 获取数据库连接        Connection connection = JdbcUtils.getConnection();        // 提取资源        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        // 准备SQL语句，? 是占位符        String sql = "select * from account where username = ? and password = ?;";        try {            // 获取预处理搬运工对象，并对SQL语句进行预处理            preparedStatement = connection.prepareStatement(sql);            // 设置参数            preparedStatement.setObject(1, "张三");            preparedStatement.setObject(2, "123456");            // 执行SQL语句            resultSet = preparedStatement.executeQuery();            // 判断是否还有数据            if (resultSet.next()) {                System.out.println("登录成功");            } else {                System.out.println("登录失败");            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(resultSet, preparedStatement, connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PreparedStatement-增加操作"><a href="#PreparedStatement-增加操作" class="headerlink" title="PreparedStatement 增加操作"></a>PreparedStatement 增加操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    @Test    public void testInsert() {        // 准备SQL语句        String sql = "insert into student(name, age, gender, info) values(?, ?, ?, ?)";        // 获取连接        Connection connection = JdbcUtils.getConnection();        PreparedStatement preparedStatement = null;        try {            // 获取预处理对象            preparedStatement = connection.prepareStatement(sql);            // 设置参数            preparedStatement.setObject(1, "赵四");            preparedStatement.setObject(2, 17);            preparedStatement.setObject(3, "男");            preparedStatement.setObject(4, "你愁啥");            // 执行SQL语句            int affectedRows = preparedStatement.executeUpdate();            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(preparedStatement, connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PreparedStatement-修改操作"><a href="#PreparedStatement-修改操作" class="headerlink" title="PreparedStatement 修改操作"></a>PreparedStatement 修改操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    @Test    public void testUpdate() {        // 准备SQL语句        String sql = "update student set age = ? where id = ?";        // 获取连接        Connection connection = JdbcUtils.getConnection();        PreparedStatement preparedStatement = null;        try {            // 获取预处理对象            preparedStatement = connection.prepareStatement(sql);            // 设置参数            preparedStatement.setObject(1, 61);            preparedStatement.setObject(2, 6);            // 执行SQL语句            int affectedRows = preparedStatement.executeUpdate();            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(preparedStatement, connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="PreparedStatement-删除操作"><a href="#PreparedStatement-删除操作" class="headerlink" title="PreparedStatement 删除操作"></a>PreparedStatement 删除操作</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Demo3{    @Test    public void testDelete() {        // 准备SQL语句        String sql = "delete from student where id = ?";        // 获取连接        Connection connection = JdbcUtils.getConnection();        PreparedStatement preparedStatement = null;        try {            // 获取预处理对象            preparedStatement = connection.prepareStatement(sql);            // 设置参数            preparedStatement.setObject(1, 3);            // 执行SQL语句            int affectedRows = preparedStatement.executeUpdate();            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(preparedStatement, connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JDBC-1"><a href="#JDBC-1" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="轻量级-ORM-框架-DbUtils【重点】"><a href="#轻量级-ORM-框架-DbUtils【重点】" class="headerlink" title="轻量级 ORM 框架 DbUtils【重点】"></a>轻量级 ORM 框架 DbUtils【重点】</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>Commons DbUtils 是 Apache 组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。</p><p>jar包</p><pre><code>commons-dbutils-1.7.jar</code></pre><p>下载路径</p><pre><code>http://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi</code></pre></blockquote><h4 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// DbUtils 核心类，提供简易的对数据库进行操作的方法class QueryRunner {}// update 核心方法对应增删改操作 insert，update，delete// conn   -> 数据库连接// sql    -> sql语句// params -> 参数列表，这里使用可变长参数，底层是Object类型的数组int update(Connection conn, String sql, Object... params);// query 核心方法，对应查询操作// T 泛型// conn   -> 数据库连接// sql    -> sql语句// rsh    -> 结果集处理器接口，需要传入一个实现类，或者使用匿名内部类的形式并重写handler方法，推荐使用其实现类 BeanHandler 以及 BeanListHandler// params -> 参数列表，这里使用可变长参数，底层是Object类型的数组<T> T query(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params)// 结果集映射器接口，核心方法为 handler()interface ResultSetHandler<T> {}// 处理符合JavaBean规范的类对象，传入参数是对应JavaBean规范 Class对象，返回一个对应的实体类对象class BeanHandler<T> implements ResultSetHandler<T> {}// 处理符合JavaBean规范的实体类，并且返回值是一个List集合包含制定的JavaBean实体类    class BeanListHandler<T> implements ResultSetHandler<List<T>> {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-DbUtils-插入数据"><a href="#使用-DbUtils-插入数据" class="headerlink" title="使用 DbUtils 插入数据"></a>使用 DbUtils 插入数据</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    @Test    public void testInsert() {        // 获取 QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 获取连接        Connection connection = JdbcUtils.getConnection();        // 准备SQL语句        String sql = "insert into student(name, age, gender, info) values(?, ?, ?, ?)";        // 准备参数        Object[] parameters = {"刘能", 37, "男", "人生没有如果，只有后果和结果"};        try {            // 执行SQL语句并获取受影响的行数            int affectedRows = queryRunner.update(connection, sql, parameters);            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-DbUtils-修改数据"><a href="#使用-DbUtils-修改数据" class="headerlink" title="使用 DbUtils 修改数据"></a>使用 DbUtils 修改数据</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {       @Test    public void testUpdate() {        // 获取 QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 获取连接        Connection connection = JdbcUtils.getConnection();        // 准备SQL语句        String sql = "update student set age = ? where id = ?";        // 准备参数        Object[] parameters = {48, 7};        try {            // 执行SQL语句并获取受影响的行数            int affectedRows = queryRunner.update(connection, sql, parameters);            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-DbUtils-删除数据"><a href="#使用-DbUtils-删除数据" class="headerlink" title="使用 DbUtils 删除数据"></a>使用 DbUtils 删除数据</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    @Test    public void testDelete() {        // 获取 QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 获取连接        Connection connection = JdbcUtils.getConnection();        // 准备SQL语句        String sql = "delete from student where id = ?";        // 准备参数        Object[] parameters = {7};        try {            // 执行SQL语句并获取受影响的行数            int affectedRows = queryRunner.update(connection, sql, parameters);            System.out.println("受影响的行数：" + affectedRows);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-DbUtils-的-ResultSetHandler-进行查询单条数据【鸡肋】"><a href="#使用-DbUtils-的-ResultSetHandler-进行查询单条数据【鸡肋】" class="headerlink" title="使用 DbUtils 的 ResultSetHandler 进行查询单条数据【鸡肋】"></a>使用 DbUtils 的 ResultSetHandler 进行查询单条数据【鸡肋】</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    @Test    public void testQueryOne() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 获取连接        Connection connection = JdbcUtils.getConnection();        // 准备SQL语句        String sql = "select * from student where id = ?";        // 准备参数        Object[] params = {1};        try {            // 通过匿名内部类实现ResultSetHandler，并重写handler方法，执行SQL语句            Student student = queryRunner.query(connection, sql, new ResultSetHandler<Student>() {                // 重写handler方法                @Override                public Student handle(ResultSet resultSet) throws SQLException {                    Student student1 = null;                    while (resultSet.next()) {                        int id = resultSet.getInt("id");                        String name = resultSet.getString("name");                        int age = resultSet.getInt("age");                        String gender = resultSet.getString("gender");                        String info = resultSet.getString("info");                        student1 = new Student(id, name, age, gender, info);                    }                    return student1;                }            }, params);            System.out.println(student);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用DbUtils-的-BeanHandler-进行查询单条数据"><a href="#使用DbUtils-的-BeanHandler-进行查询单条数据" class="headerlink" title="使用DbUtils 的 BeanHandler 进行查询单条数据"></a>使用DbUtils 的 BeanHandler 进行查询单条数据</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    @Test    public void testQuery() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 准备SQL语句        String sql = "select * from student where id = ?";        // 准备参数        Object[] params = {1};        // 获取连接        Connection connection = JdbcUtils.getConnection();        try {            // 执行SQL语句，传入BeanHandler对象            Student student = queryRunner.query(connection, sql, new BeanHandler<Student>(Student.class), params);            System.out.println(student);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-DbUtils-的-BeanListHandler-进行查询多条数据"><a href="#使用-DbUtils-的-BeanListHandler-进行查询多条数据" class="headerlink" title="使用 DbUtils 的 BeanListHandler 进行查询多条数据"></a>使用 DbUtils 的 BeanListHandler 进行查询多条数据</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    @Test    public void testQueryAll() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 准备SQL语句        String sql = "select * from student";        // 获取连接        Connection connection = JdbcUtils.getConnection();        try {            // 执行SQL语句，传入BeanListHandler对象，获取一个包含实体类对象的集合            List<Student> list = queryRunner.query(connection, sql, new BeanListHandler<Student>(Student.class));            System.out.println(list);        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="【补充】使用-DbUtils-的-ArrayHandler-获取包含对应一条数据的数组"><a href="#【补充】使用-DbUtils-的-ArrayHandler-获取包含对应一条数据的数组" class="headerlink" title="【补充】使用 DbUtils 的 ArrayHandler 获取包含对应一条数据的数组"></a>【补充】使用 DbUtils 的 ArrayHandler 获取包含对应一条数据的数组</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 处理符合JavaBean规范的类对象，能够将数据转为一个Object类型的数组class ArrayHandler implements ResultSetHandler<Object[]> {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    @Test    public void testQueryOne() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 准备SQL语句        String sql = "select * from student where id = 1";        // 获取连接        Connection connection = JdbcUtils.getConnection();        try {            // 执行SQL语句，ArrayHandler，获取一个包含对应字段数据的数组            Object[] objects = queryRunner.query(connection, sql, new ArrayHandler());            // 将数组转为字符串并展示            System.out.println(Arrays.toString(objects));        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="【补充】使用-DbUtils-的-ArrayListHandler-获取包含对应多条数据的数组"><a href="#【补充】使用-DbUtils-的-ArrayListHandler-获取包含对应多条数据的数组" class="headerlink" title="【补充】使用 DbUtils 的 ArrayListHandler 获取包含对应多条数据的数组"></a>【补充】使用 DbUtils 的 ArrayListHandler 获取包含对应多条数据的数组</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 处理符合JavaBean规范的类对象，能够将数据转为一个包含Object类型的数组的集合class ArrayListHandler extends AbstractListHandler<Object[]> {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    @Test    public void testQueryOne() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 准备SQL语句        String sql = "select * from student where id = 1";        // 获取连接        Connection connection = JdbcUtils.getConnection();        try {            // 执行SQL语句，ArrayHandler，获取一个包含对应字段数据的数组            Object[] objects = queryRunner.query(connection, sql, new ArrayHandler());            // 将数组转为字符串并展示            System.out.println(Arrays.toString(objects));        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtils.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p></blockquote><h4 id="常见的数据库连接池"><a href="#常见的数据库连接池" class="headerlink" title="常见的数据库连接池"></a>常见的数据库连接池</h4><blockquote><p>C3P0</p><p>DBCP</p><p>Druid【常用】</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201201142207.png" alt=""></p><h4 id="C3P0连接池的使用"><a href="#C3P0连接池的使用" class="headerlink" title="C3P0连接池的使用"></a>C3P0连接池的使用</h4><p>导入jar包</p><pre><code>mchange-commons-java-0.2.19.jarc3p0-0.9.5.2.jar</code></pre><p>配置文件</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><!-- c3p0-config.xml需要存储于src目录下 --><c3p0-config>    <!-- 使用默认的配置读取连接池对象 -->    <default-config>        <!--  连接参数 -->        <property name="driverClass">com.mysql.jdbc.Driver</property>        <property name="jdbcUrl">jdbc:mysql://localhost:3306/FC2020?useSSL=true&amp;characterEncoding=UTF8</property>        <property name="user">root</property>        <property name="password">root</property>        <!-- 连接池参数 -->        <!--初始化申请的连接数量-->        <property name="initialPoolSize">5</property>        <!--最大的连接数量-->        <property name="maxPoolSize">10</property>        <!--超时时间-->        <property name="checkoutTimeout">3000</property>    </default-config>    <named-config name="otherc3p0">        <!--  连接参数 -->        <property name="driverClass">com.mysql.jdbc.Driver</property>        <property name="jdbcUrl">jdbc:mysql://localhost:3306/student?useSSL=true</property>        <property name="user">root</property>        <property name="password">root</property>        <!-- 连接池参数 -->        <property name="initialPoolSize">5</property>        <property name="maxPoolSize">8</property>        <property name="checkoutTimeout">1000</property>    </named-config></c3p0-config><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】此配置文件需要放在<a href="">src</a>目录下，不需要手动编写，直接复制粘贴后修改数据库名和密码即可！！！</p></blockquote><p>使用 C3P0 封装 JdbcUtilsOnC3P0工具类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class JdbcUtilsOnC3P0 {    // 声明一个c3p0连接池    private static ComboPooledDataSource pool = new ComboPooledDataSource();    private static Connection connection = null;    private static Statement statement = null;    private static ResultSet resultSet = null;    /**     * 获取连接     *     * @return 返回数据库的连接     */    public static Connection getConnection() {        try {            // 通过c3p0连接池获取连接            connection = pool.getConnection();        } catch (SQLException e) {            e.printStackTrace();        }        return connection;    }    /*     * 重载关闭资源方法，以满足多种场景     */    public static void close(Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet) {        close(resultSet, statement, connection);    }    public static void close(Statement statement, Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet, Statement statement, Connection connection) {        try {            if (resultSet != null) {                resultSet.close();            }            if (statement != null) {                statement.close();            }            if (connection != null) {                connection.close();            }        } catch (SQLException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo {    @Test    public void testQuery() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 通过C3P0连接池获取连接        Connection connection = JdbcUtilsOnC3P0.getConnection();        // 准备SQL语句        String sql = "select * from student";        try {            // 使用BeanListHandler执行SQL语句获取对应数据的集合            List<Student> list = queryRunner.query(connection, sql, new BeanListHandler<Student>(Student.class));            // 增强for循环遍历            for (Student student : list) {                System.out.println(student);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtilsOnC3P0.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Druid-连接池的使用"><a href="#Druid-连接池的使用" class="headerlink" title="Druid 连接池的使用"></a>Druid 连接池的使用</h4><p>导包</p><pre><code>druid-1.0.9.jar</code></pre><p>配置文件</p><pre class="line-numbers language-lang-properties"><code class="language-lang-properties"># 文件名 druid.properties 存储在src目录下driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=UTF-8username=rootpassword=root# 初始化数据库连接池容量initialSize=5# 最大容量maxActive=20# TimeOut 等待超时时间maxWait=2000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】此配置文件需要放在<a href="">src</a>目录下，不需要手动编写，直接复制粘贴后修改数据库名和密码即可！！！</p></blockquote><p>使用 Druid 封装JdbcUtilsOnDruid 工具类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class JdbcUtilsOnDruid {    // 数据库源    private static DataSource dataSource;    private static Connection connection = null;    private static Statement statement = null;    private static ResultSet resultSet = null;    static {        try {            // 加载Properties文件            Properties properties = new Properties();            properties.load(new FileReader("./src/druid.properties"));            // 已经完成数据库连接池操作            dataSource = DruidDataSourceFactory.createDataSource(properties);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 返回数据库连接对象，连接失败返回null     *     * @return java.sql.Connection 数据库连接对象     */    public static Connection getConnection() {        try {            // 通过数据源获取连接            connection = dataSource.getConnection();        } catch (SQLException e) {            e.printStackTrace();        }        return connection;    }    /*     * 重载关闭资源方法，以满足多种场景     */    public static void close(Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet) {        close(resultSet, statement, connection);    }    public static void close(Statement statement, Connection connection) {        close(resultSet, statement, connection);    }    public static void close(ResultSet resultSet, Statement statement, Connection connection) {        try {            if (resultSet != null) {                resultSet.close();            }            if (statement != null) {                statement.close();            }            if (connection != null) {                connection.close();            }        } catch (SQLException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo {    @Test    public void testDruid() {        // 获取QueryRunner对象        QueryRunner queryRunner = new QueryRunner();        // 准备SQL语句        String sql = "select * from student";        // 从Druid连接池中获取连接        Connection connection = JdbcUtilsOnDruid.getConnection();        try {            // 使用BeanListHandler执行SQL语句并获取带有数据的集合            List<Student> list = queryRunner.query(connection, sql, new BeanListHandler<Student>(Student.class));            // 增强for循环遍历集合            for (Student student : list) {                System.out.println(student);            }        } catch (SQLException e) {            e.printStackTrace();        } finally {            // 关闭资源            JdbcUtilsOnDruid.close(connection);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="【补充】常见数据库连接"><a href="#【补充】常见数据库连接" class="headerlink" title="【补充】常见数据库连接"></a>【补充】常见数据库连接</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">-------------------------------oracle------------------驱动：oracle.jdbc.driver.OracleDriverURL：jdbc:oracle:thin:@machine_name:port:dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认是1521-------------------------------mysql-------------------驱动：com.mysql.jdbc.DriverURL：jdbc:mysql://machine_name:port/dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认3306    ------------------------------SQL Server---------------驱动：com.microsoft.jdbc.sqlserver.SQLServerDriverURL：jdbc:microsoft:sqlserver://<machine_name><:port>;DatabaseName=<dbname>注：machine_name：数据库所在的机器的名称；      port：端口号，默认是1433------------------------------DB2----------------------驱动：com.ibm.db2.jdbc.app.DB2DriverURL：jdbc:db2://<machine_name><:port>/dbname注：machine_name：数据库所在的机器的名称；      port：端口号，默认是5000-------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库的连接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发手册——嵩山版</title>
      <link href="posts/58907.html"/>
      <url>posts/58907.html</url>
      
        <content type="html"><![CDATA[<p>此处为java开发手册——嵩山版。</p><p>本人已上传微云，快点击下方链接下载观看吧！！！</p><p><a href="https://share.weiyun.com/ZKtny9Ks" target="_blank" rel="noopener">java开发手册——嵩山版</a></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123143458.png" alt="java开发手册——嵩山版"></p>]]></content>
      
      
      <categories>
          
          <category> 开发手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea破解版的安装下载及使用方法</title>
      <link href="posts/4127.html"/>
      <url>posts/4127.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、在安装之前先下载一下吧！"><a href="#一、在安装之前先下载一下吧！" class="headerlink" title="一、在安装之前先下载一下吧！"></a>一、在安装之前先下载一下吧！</h2><p>点击以下传送门去腾讯微云下载！！！</p><p><a href="https://share.weiyun.com/Big4DCy8" target="_blank" rel="noopener">传送门</a></p><h2 id="二、安装方法，及破解方法，如图："><a href="#二、安装方法，及破解方法，如图：" class="headerlink" title="二、安装方法，及破解方法，如图："></a>二、安装方法，及破解方法，如图：</h2><p>请按以下方法一步一步来…………………..！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224752.png" alt="001"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224849.png" alt="002"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224906.png" alt="003"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224916.png" alt="004"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224923.png" alt="005"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224939.png" alt="006"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118224954.png" alt="007"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225011.png" alt="008"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225019.png" alt="009"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225027.png" alt="010"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225036.png" alt="011"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225046.png" alt="012"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225057.png" alt="013"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225106.png" alt="014"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225117.png" alt="015"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225128.png" alt="016"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225138.png" alt="017"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225150.png" alt="018"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201118225204.png" alt="019"></p><h2 id="三、idea的使用方法"><a href="#三、idea的使用方法" class="headerlink" title="三、idea的使用方法"></a>三、idea的使用方法</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>Idea 中的 <code>Project</code> 相当于 eclipse 的 workspace ，<code>Moduel</code> 相当于 eclipse 中的 project。</p><p>创建 project 要指明路径，建议放到同一个目录下，方便管理！！！</p><p>虽然创建 <code>Module</code> 看起来层次结构比较清晰，但涉及的操作太多，建议每次都创建 <code>Project</code>！！！</p><h4 id="创建Java项目"><a href="#创建Java项目" class="headerlink" title="创建Java项目"></a>创建<code>Java</code>项目</h4><p>1、创建项目前先创建一个文件夹，作为 idea 代码的根目录，以后每次创建的项目都放到这个目录下，方便管理</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123134908.png" alt="image-20201119122710589"></p><p>2、使用idea创建项目，首先双击打开idea，会出现如下界面，单击 <code>create new project</code></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123134920.png" alt="image-20201119123051762"></p><p>3、这个时候会跳出我们的创建界面，第一次使用可能会提示没有 <code>SDK</code> ，这里的 <code>SDK</code> 就是我们的 <code>JDK</code> </p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123134938.png" alt="image-20201119123224384"></p><p>4、点击下拉列表，正常情况下会自动找到电脑中的 <code>JDK</code> ，如果没有，就需要通过<code>New</code>手动定位到我们<code>JDK</code>的安装路径</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123134953.png" alt="image-20201119123358192"></p><p>5、选中路径</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135010.png" alt="image-20201119124119262"></p><p>6、此时<code>JDK</code>已经被识别</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135107.png" alt="image-20201119124255483"></p><p>7、这个地方提示使用模板，直接跳过</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135152.png" alt="image-20201119124438228"></p><p>8、这里是非常关键的一步，创建项目需要给定项目的存放路径以及项目名，存放路径应该是刚刚创建好的文件夹中的子文件夹，例如在<code>IdeaWorkSpace</code>文件夹中创建一个项目名为<code>day01_HelloWorld</code>的项目，需要在<code>IdeaWorkSpace</code>路径后直接追加项目名，上面的项目名可以直接复制粘贴。后续新建每个项目都应该和<code>day01_HelloWorld</code>是平级的，这样才能保证一个完整有序的层级结构</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135208.png" alt="image-20201119125133802"></p><p>9、这里会跳出一个弹窗，提示我们的项目路径文件夹不存在，点击OK自动创建一个即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135230.png" alt="image-20201119125214262"></p><p>10、这个时候耐心等待，<code>idea</code>会加载一段时间后跳出这个界面，中间是提示的小技巧，可以看看，或者直接<code>Close</code>关闭，如果取消勾选<code>Show tips on startup</code>以后打开<code>idea</code>都不会再弹出这个提示界面</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135243.png" alt="image-20201119125752675"></p><p>11、这个时候可以看到侧边栏 <code>Project</code> 中已经存在刚刚创建好的 <code>day01_HelloWorld</code> 项目，并且就在路径也在我们指定好的文件夹中。单击左边展开箭头可以看到层次结构</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135251.png" alt="image-20201119130107773"></p><p>12、鼠标选中<code>src</code>，单击右键，鼠标拖到 <code>New</code> 上会跳出子级导航栏，可以在这里创建不同的文件或者文件夹，这里我选择直接创建<code>Java Class</code>，就是我们的<code>Java</code>文件</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135309.png" alt="image-20201119130345378"></p><p>13、这里可以直接输入完整的包名.类名，会自动创建好层级结构</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135318.png" alt="image-20201119131100434"></p><p>14、创建好的效果如下，中间是刚刚创建好的<code>Demo1</code>类的内容主体，左侧<code>Project</code>导航栏是我们项目的层级结构</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135615.png" alt="image-20201119133434917"></p><p>15、可以直接在类内容主体中写Java代码，通过<code>main</code>方法右侧的绿色箭头即可运行</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135446.png" alt="image-20201119133652072"></p><p>16、运行程序</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135501.png" alt="image-20201119133820132"></p><p>17、第一次运行程序会比较慢，耐心等待，会弹出下面的窗口，此时代码已经运行完毕，结果会有所展示，并且在左侧层级结构中会生成对应的存放字节码文件的文件夹<code>out</code></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135647.png" alt="image-20201119134326802"></p><p>18、此时我们的项目已经创建并启动完毕</p><p>【补充】如果我们需要再创建一个新的项目，需要注意填写项目名的地方要和当前项目在同一路径下，便于管理</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135720.png" alt="image-20201119135547108"></p><p>这个时候打开刚刚创建好的<code>IdeaWorkSpace</code>文件夹，发现两个项目的目录是平级的，这样就是我们想要的效果</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135730.png" alt="image-20201119135716221"></p><h4 id="关闭项目"><a href="#关闭项目" class="headerlink" title="关闭项目"></a>关闭项目</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">File -> Close Project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135839.png" alt="image-20201119135025550"></p><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142524.png" alt="image-20201119135110430"></p><h4 id="导入Eclipse中的项目"><a href="#导入Eclipse中的项目" class="headerlink" title="导入Eclipse中的项目"></a>导入<code>Eclipse</code>中的项目</h4><p>1、在项目页面中点击File、New、Project from Existing Sources</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135851.png" alt="image-20201119142220550"></p><p>2、选择我们需要导入的项目的路径</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135911.png" alt="image-20201119143208973"></p><p>3、导入外部模板选择Eclipse</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123135921.png" alt="image-20201119143328823"></p><p>4、这里需要手动选择一个项目路径，使用我们之前的文件夹路径加上项目名即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140115.png" alt="image-20201119143442623"></p><p>5、选中需要导入的项目</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140111.png" alt="image-20201119143442623"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140615.png" alt="image-20201119143519924"></p><p>6、这里是选择字符集，默认即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140638.png" alt="image-20201119143557950"></p><p>7、选择JDK版本，默认即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140722.png" alt="image-20201119143632145"></p><p>8、选择从当前窗口打开</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140734.png" alt="image-20201119143658326"></p><p>9、导入之后左边是项目的层级结构，这个时候可能会提醒没有<code>JDK</code>，点击<code>Setup SDK</code></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140749.png" alt="image-20201119143818714"></p><p>10、选择<code>jdk</code>并点击OK</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140801.png" alt="image-20201119143948290"></p><p>11、这个时候我们发现中文字符发生了乱码，并且上方有错误提示，这个报错是因为Eclipse的默认编码集和IDEA不一致所引起的，点击 <code>Set project encoding to &#39;GBK&#39;</code> 即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140823.png" alt="image-20201119144048396"></p><p>12、中文乱码消失，点击运行</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140839.png" alt="image-20201119144302020"></p><p>13、可以正常运行</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140859.png" alt="image-20201119144417948"></p><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>当我们需要使用外部封装好的<code>jar</code>包就需要进行导包，否则无法使用</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140918.png" alt="image-20201119221801099"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140937.png" alt="image-20201119221918597"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123140953.png" alt="image-20201119222015795"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123141007.png" alt="image-20201119222108396"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123141020.png" alt="image-20201119222207287"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123141030.png" alt="image-20201119222319920"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142614.png" alt="image-20201119222428056"></p><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123141044.png" alt="image-20201119222521412"></p><h3 id="Idea-集成-Tomcat"><a href="#Idea-集成-Tomcat" class="headerlink" title="Idea 集成 Tomcat"></a>Idea 集成 Tomcat</h3><h4 id="Tomcat的安装请前往"><a href="#Tomcat的安装请前往" class="headerlink" title="Tomcat的安装请前往"></a>Tomcat的安装请前往</h4><p><a href="https://ialoe.top/posts/60824.html">Tomcat安装及运行 | 白月光 | 秦同学 (ialoe.top)</a></p><blockquote><p>此操作只需执行一次即可，避免每次重复添加 Tomcat 服务器软件的麻烦</p></blockquote><p>1、任意启动一个 Idea 项目后，在 Run 的下拉列表中选择 Edit Configurations</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120411575987.png" alt=""></p><p>2、点击加号，在下拉列表中选择最后一个选择 <code>35 items more (irrelevant)...</code></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412060456.png" alt="image-2020120412060456"></p><p>3、继续下拉，找到 <code>Tomcat Server</code>，点击后右侧列表中选择 <code>Local</code></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412100336.png" alt="image-2020120412100336"></p><p>4、点击配置</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412112756.png" alt="image-2020120412112756"></p><p>5、选择目录</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412123668.png" alt="image-2020120412123668"></p><p>6、找到 <code>Tomcat</code> 服务器软件的安装路径，选中后点击 OK</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412135914.png" alt="image-2020120412135914"></p><p>7、点击OK</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412143941.png" alt="image-2020120412143941"></p><p>8、此时已经完成了 Idea 集成 Tomcat 的操作，下面的报错不影响，忽略即可</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-2020120412160153.png" alt="image-2020120412160153"></p><p>9、点击 <code>OK</code> 退出即可</p><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p>如果字体太小可以通过下面的路径中的选项进行调整</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">File -> Setting -> Editor -> Font -> Size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142803.png" alt="image-20201119131328377"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142816.png" alt="image-20201119131420633"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142837.png" alt="image-20201119131637253"></p><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142850.png" alt="image-20201119131729321"></p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>晚上看白色背景会感觉刺眼，可以通过以下路径调整<code>idea</code>的主题背景为黑色</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">File -> Setting -> Appearance & Behavior -> Appearance -> Theme -> Darcula<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142912.png" alt="image-20201119132011270"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123142936.png" alt="image-20201119132058395"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123143015.png" alt="image-20201119132828573"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123143035.png" alt="image-20201119132404997"></p><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201123143049.png" alt="image-20201119132435121"></p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Alt + Enter</td><td>自动修复、导包</td></tr><tr><td>Ctrl + Shift + L</td><td>格式化代码</td></tr><tr><td>Ctrl + Shift + O</td><td>自动导包或删除无用包</td></tr><tr><td>Ctrl + Shift + Space</td><td>自动补全代码</td></tr><tr><td>Ctrl + X</td><td>删除行</td></tr><tr><td>Ctrl + D</td><td>复制行</td></tr><tr><td>Ctrl + /</td><td>单行注释</td></tr><tr><td>Ctrl + Shift + /</td><td>多行注释</td></tr><tr><td>Ctrl + B</td><td>跳转到光标所在处的类或方法</td></tr></tbody></table></div><p>长路漫漫，水分多多，又水完一篇文章！！！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="posts/48508.html"/>
      <url>posts/48508.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><blockquote><p>Throwable 类是Java语言中所有错误和异常的顶级父类，直接子类为 Error 和 Exception</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 无参构造：构造一个新的 throwable 对象，其详细信息为nullpublic Throwable()// 有参构造：使用指定的详细信息(message)构造一个新的 throwable 对象public Throwable(String message)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 返回此 throwable 对象的详细信息字符串public String getMessage()// 返回一个简要信息描述public String toString()// 打印此 throwable 对象及其详细信息字符串到标准错误流(控制台)public void printStackTrace()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Throwable throwable1 = new Throwable();        System.out.println(throwable1.getMessage());        System.out.println(throwable1.toString());        throwable1.printStackTrace();        Throwable throwable2 = new Throwable("错误信息！！！");        System.out.println(throwable2.getMessage());        System.out.println(throwable2.toString());        throwable2.printStackTrace();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote><p>Error 类是 Throwable 的子类，它指出了一个合理的应用程序不应该试图捕捉的严重问题</p></blockquote><p>【注意】Error 结尾的是严重问题，无法解决</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote><p>Exception 类及其子类是一种 Throwable 的子类，指示了一个合理的应用程序可能想要捕获的条件。</p></blockquote><p>【注意】Exception 结尾的是我们可以处理的，一般我们需要关注的是 RuntimeException</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><blockquote><p>异常处理分为两种：捕获和抛出</p><p><strong>有能力处理就进行捕获，没有就抛出</strong></p></blockquote><h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    try {        // 有可能出现问题的代码，存在一定隐患的代码    } catch (异常类型 变量名) {        // 对应当前异常类型的处理方式    } finally {        // 无论是否捕获，都会执行，常用于释放资源    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        int num1 = 0;        int num2 = 20;        int ret = 0;        /*         * 除数不能为0         */        try {            ret = num2 / num1;        } catch (ArithmeticException e) {            e.printStackTrace();        }        System.out.println(ret);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">java.lang.ArithmeticException: / by zero    at code.exception.Test.main(Test.java:11)0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【注意】</p><blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、代码中出现异常，JVM会终止代码运行，如果使用try catch捕获处理异常，JVM会认为当前代码中不存在异常，可以继续运行。2、try - catch代码块中声明的都是局部变量，需要提前声明3、try - catch捕获处理异常，可以处理多种异常情况4、代码中存在多种隐患，存在多个异常情况，try - catch捕获有且只能处理第一个出现异常的代码，因为JVM从异常代码开始直接进入异常捕获阶段5、Exception作为Java中所有异常的超类，在捕获异常处理时如果直接使用Exception进行捕获处理，无法具体到对某一个异常来处理6、Exception可以作为try - catch 最后一个，用于处理其他异常捕获之后没有对症方式遗留问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">关键字:    throw        在方法内特定条件下抛出指定异常，后面跟异常类型的对象    throws        在【方法声明】位置，告知调用者，当前方法有哪些异常抛出，后面跟异常的类型    用于处理非当前方法操作问题，导致出现的异常，一般情况下是用于处理方法运行过程中因为参数传入，参数处理，运算结果导致的问题，抛出异常。    throw是一个稍微高级的参数合法性判断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestThrows {    public static void main(String[] args) {        try {            test(1, 0);        } catch (ArithmeticException e) {            e.printStackTrace();        }    }    /**     * 测试方法，打印两个数的差     *      * @param num1 第一个参数，被除数     * @param num2 第二个参数，除数     * @throws ArithmeticException 如果除数为0，抛出异常     */    public static void test(int num1, int num2) throws ArithmeticException {        if (0 == num2) {            throw new ArithmeticException("除数不能为0");        }        System.out.println(num1 / num2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">java.lang.ArithmeticException: 除数不能为0    at code.exception.TestThrows.test(TestThrows.java:23)    at code.exception.TestThrows.main(TestThrows.java:7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、throw 和 throws 必须同时出现，并且体现在注释上2、代码如果运行到throw抛出异常，之后的代码不再运行，之后的代码是成为无法抵达的代码3、代码中存在多种隐患，按照隐含的情况，分门别类处理，不能在同一个条件内抛出两个异常。并且在方法的声明位置，throws之后，不同的异常，使用逗号隔开4、当调用带有异常抛出的方法时，对于方法抛出的异常，有两种处理方式，可以捕获处理，也可以抛出处理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">RuntimeException：代码运行过程中出现的异常，没有强制处理的必要性，因为JVM会处理RuntimeException异常，即报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="其他异常"><a href="#其他异常" class="headerlink" title="其他异常"></a>其他异常</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">强制要求处理，不管是捕获处理还是抛出处理，都需要进行操作，如果未处理就会报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><blockquote><p>继承自 Exception 或者 RuntimeException，只需要提供无参构造和一个带参构造即可</p><p>【注意】如果继承自Exception，调用抛出了此异常的方法需要手动对其捕获或者抛出</p></blockquote><p>自定义异常类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyException extends Exception {    public MyException() {}    public MyException(String message) {        super(message);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        try {            buy(false);        } catch (MyException e) {            e.printStackTrace();        }    }    /**     * 买方法，当没有女朋友的时候，抛出异常     * @param hasGirlFriend boolean类型，是否有女朋友     * @throws MyException 自定义单身狗异常     */    public static void buy(boolean hasGirlFriend) throws MyException {        if (false == hasGirlFriend) {            throw new MyException("你还没有女朋友");        }        System.out.println("买一送一");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">code.myexception.MyException: 你还没有女朋友    at code.myexception.Test.buy(Test.java:19)    at code.myexception.Test.main(Test.java:6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、父类的方法有异常抛出，子类的重写方法在抛出异常的时候必须要小于等于父的异常2、父类的方法没有异常抛出，子类的重写方法不能有异常抛出3、父类的方法抛出多个异常，子类的重写方法必须比父少或者小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、异常的存在是非常有必要的，可以帮助我们定位和解决问题</p><p>2、异常的处理方式：捕获和抛出</p><p>3、自定义异常一定要有无参构造和有参构造</p><p>4、后期会遇到大量的异常，一般使用快捷键就能搞定</p><p>​        Eclipse：Ctrl + 1</p><p>​        Idea：Alt + Enter</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用String和集合语句</title>
      <link href="posts/24535.html"/>
      <url>posts/24535.html</url>
      
        <content type="html"><![CDATA[<p>此内容必须会！！！</p><h2 id="String语句"><a href="#String语句" class="headerlink" title="String语句"></a>String语句</h2><p>用老师的话说，如果在上班的时候你不会这些，去搜索被领导看到，就可以领盒饭了</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">//获取字符串的长度int length();//获取指定下标位置的字符char charAt(int index);//获取指定字符在字符串中首此出现的下标位置int indexOf(int ch);//获取指定字符串在字符串中首此出现的下标位置int indexOf(String str);//获取指定字符在字符串中最后一次出现的下标位置int lastIndexOf(char ch);//获取指定字符串在字符串中最后一次出现的下标位置int lastIndexOf(String str);//从指定下标位置开始，到字符串结尾截取字符串String substring(int beginIndex);//从指定beginIndex开始，到endIndex结束，截取字符串【注意】要头不要尾String substring(int beginIndex,int endIndex);//去除字符串两端空格String trim();//使用指定字符串对当前字符串进行切割，获取一个字符串数组String[] split(String regex);//判断是否以指定字符串作为前缀结束boolean startsWith(String prefix);//判断是否以指定字符串作为后缀结束boolean endsWith(String suffix);//判断字符串是否为空boolean isEmpty();//与指定对象比较，判断是否相等boolean equals(Object anObject);//忽略大小写判断是否与指定字符串相等boolean equalslgnoreCase(String anotherString);//判断是否包含指定序列（搜索）boolean contains(String str);//字符数组转字符串String(char [] value);//从字符串数组的指定位置开始，截取指定个数的字符转为字符串String (char[] value,int offset,int count);//同理String（char[]value）static String valueOf(char[] data);//同理String(char[] value,int offset,int count);static String valueOf(char[] data,int offset,int count);//使用新字符替换字符串中的旧字符String replace(char oldChar,char newChar);//将字符串转换为字符数组char[] toCharArray();//将字符串中所有的英文字母转大写String toUpperCase();//将字符串中所有的英文字母转小写String toLowerCase();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201113093848.jpg" alt="String"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 添加当前集合约束的指定数据类型到当前集合中add(E e);// 添加另一个集合到当前集合中，要求添加集合中保存的元素必须是当前集合中//保存元素本身或者其子类对象addAll(Collection<? extends E> e);// 删除集合中的指定元素，删除成功返回true,未找到指定元素，无法删除返回false，//并且在多个元素的情况下，删除找到的第一个元素。boolean remove(Object obj);// 在当前集合中删除两个集合的交集    boolean removeAll(Collection<?> c);// 在当前集合中保留两个集合的交集boolean retainAll(Collection<?> c);// 清空整个集合中的所有元素void clear();// 获取集合中有效元素的个数int size();// 判断当前集合是否为空，是否存在有效元素boolean isEmpty();// 判断指定元素是否在当前集合中存在boolean contains(Object obj);// 判断传入的参数集合是不是当前集合的子集合boolean containsAll(Collection<?> c);// 返回集合中所有保存元素的Object类型数组Object[] toArray();// 获取集合的迭代器对象，泛型对应的具体数据类型和集合中约束的泛型具体数据类型一致。Iterator<K> iterator();    // 判断当前集合中是否可以继续得到元素，(是否可以继续遍历)    boolean hasNext();    // 1. 获取迭代器当前指向的元素    // 2. 将迭代器指向下一个元素    E next();    // 删除通过next方法获取到元素    /*      * 【注意】     *      *    1、remove方法只能删除next方法获取到元素     *    2、remove方法只能在next方法之后执行，且不能跨过一个next执行     *    3、没有next不能使用remove     */    boolean    remove();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// List接口继承Collection接口 add方法，使用操作和Collection一致，//并且这里采用的添加方式是【尾插法】add(E e);// List接口【特有方法】，在指定位置，添加指定元素add(int index, E e);// List接口继承Collection接口 addAll方法，使用操作和Collection一致，//并且这里采用的添加方式是【尾插法】addAll(Collection<? extends E> e);// List接口【特有方法】，在指定下标位置，添加另一个集合中所有内容addAll(int index, Collection<? extends E> e);// List接口【特有方法】，获取指定下标位置的元素并删除E remove(int index);// List接口继承Collection接口方法。删除集合中的指定元素boolean remove(Object obj);// List接口继承Collection接口方法。删除当前集合中和参数集合重复元素boolean removeAll(Collection<E> e);// List接口继承Collection接口方法。保留当前集合中和参数集合重复元素boolean retainAll(Collection<E> e);// List接口继承Collection接口方法。清空整个集合中的所有元素void clear();// List接口【特有方法】，使用指定元素替代指定下标的元素，返回值是被替换的元素E set(int index, E e);// List接口继承Collection接口方法。获取集合中有效元素个数int size();// List接口继承Collection接口方法。判断当前集合是否为空boolean isEmpty();// List接口继承Collection接口方法。判断指定元素是否包含在当前集合中boolean contains(Object obj);// List接口继承Collection接口方法。判断参数集合是不是当前集合在子集合boolean containsAll(Collection<?> c);// List接口继承Collection接口方法。获取当前集合中所有元素Object数组Object[] toArray();// List接口【特有方法】。获取指定下标对应的元素E get(int index);// List接口【特有方法】。获取当前集合指定子集合，从fromIndex开始，到toIndex结束。fromIndex <= 范围 < toIndexList<E> subList(int fromIndex, int toIndex);// List接口【特有方法】。获取指定元素在集合中第一次出现位置int indexOf(Object obj);// List接口【特有方法】。获取指定元素在集合中最后一次出现的位置int lastIndexOf(Object o);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在当前链表开始位置加元素boolean addFirst(E e);// 在当前链表末尾添加元素    boolean addLast(E e);// 获取第一个Node节点元素数据        E getFirst();// 获取末尾Node节点元素数据        E getLast();// 删除头节点    E removeFirst();// 删除末尾节点        E removeLast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 添加符合Map要求的键值对存入到双边队列中V put(K key, V value);// 添加另一个Map到当前Map中，要求K是当前Map本身对应的K，//或者其子类，V是当前Map本身对应的V，或者其子类        void putAll(Map<? extends K, ? extends V> map)// 删除对应Key键值对V remove(Object key); // 使用value修改已存在的key对应的值V put(K key, V value);// Map双边队列个数int size();// 判断当前Map双边队列中是否为空boolean isEmpty();// 判断指定Key是否存在boolean containsKey(Object key);// 判断指定Value是否存在boolean containsValue(Object value);// 返回Map双边队列中所有Key对应的Set集合Set<K> keySet();// 返回Map双边队列中所有value对应Collection集合Collection<V> values();// 返回值类型是Entry键值对形式数据的Set集合Set<Map.Entry<K, V>> entrySet();/* * Set<Map.Entry<K, V>> * * Map.Entry<K, V> Map接口的内部接口Entry，使用的泛型 K,V对应Map 创建过程中约束的K,V因为返回值是Set集合， 集合带有泛型 Set<Map接口中的内部接口Entry> */Entry 对应的方法    // 返回与此项对应的键    K getKey();    // 返回与此项对应的值。    V getValue();    // 用指定的值替换与此项对应的值，返回与此项对应的旧值     V setValue(V value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此地方有集合如何使用的具体用法    <a href="https://ialoe.top/posts/9443.html">https://ialoe.top/posts/9443.html</a></p>]]></content>
      
      
      <categories>
          
          <category> String语句 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel</title>
      <link href="posts/3086.html"/>
      <url>posts/3086.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、求和函数SUM"><a href="#1、求和函数SUM" class="headerlink" title="1、求和函数SUM()"></a>1、求和函数SUM()</h3><blockquote><p><strong>SUM</strong>函数将为值求和。 可以将单个值、单元格引用或是区域相加，或者将三者的组合相加。</p></blockquote><p>1、指定数值求和</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(10,20,30)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求和：输入=sum()，在括号中间按住ctrl连续点击即可选择需要求和的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C5,C9,C3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、也可以将指定单元格直接相加</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2 + C4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、区域求和，输入=sum()，在括号中间按住ctrl选中所需要求和的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5、多个区域求和，输入=sum()，在括号中间分别按住ctrl选中所需要的多个区域的数据</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C4,C6:C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6、配合固定值进行求和，中间使用英文的逗号分隔</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUM(C2:C11,100)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、条件求和函数SUMIF"><a href="#2、条件求和函数SUMIF" class="headerlink" title="2、条件求和函数SUMIF()"></a>2、条件求和函数SUMIF()</h3><blockquote><p>按条件求和</p></blockquote><p>sumif函数的语法格式</p><blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=sumif(range，criteria，sum_range)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Sumif（条件区域，求和条件，实际求和区域），第二个求和条件参数在第一个条件区域里。</p></blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=SUMIF(D2:D11,D4,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>求和所有性别中性别为女的年龄</p><h3 id="3、求平均值函数AVERAGE"><a href="#3、求平均值函数AVERAGE" class="headerlink" title="3、求平均值函数AVERAGE()"></a>3、求平均值函数AVERAGE()</h3><blockquote><p>获取平均值</p></blockquote><p>1、指定数值求平均值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(10,20)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求平均值:括号内按ctrl选择需要求平均值的单元格</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(C2,C8)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、范围单元格求平均值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=AVERAGE(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、求最大值函数MAX"><a href="#4、求最大值函数MAX" class="headerlink" title="4、求最大值函数MAX()"></a>4、求最大值函数MAX()</h3><blockquote><p>获取最大值</p></blockquote><p>1、指定数值求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最大值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MAX(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、求最小值函数MIN"><a href="#5、求最小值函数MIN" class="headerlink" title="5、求最小值函数MIN()"></a>5、求最小值函数MIN()</h3><blockquote><p>获取最小值</p></blockquote><p>1、指定数值求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(30,40)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、指定单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C5,C11,C7)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格求最小值</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=MIN(C3:C4,C7,C10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、计数函数COUNT"><a href="#6、计数函数COUNT" class="headerlink" title="6、计数函数COUNT()"></a>6、计数函数COUNT()</h3><blockquote><p>获取指定单元格非空数据数值类型的个数，对于空单元格、逻辑值或者文本数据将被忽略。可以用来判断是否有空白单元格</p></blockquote><p>1、指定数值获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(1,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格中非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C10,F10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、指定范围获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C10:C12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、指定多个范围单元格获取非空数值的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNT(C8,C10,C12,F4:F12)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7、非空计数函数COUNTA"><a href="#7、非空计数函数COUNTA" class="headerlink" title="7、非空计数函数COUNTA()"></a>7、非空计数函数COUNTA()</h3><blockquote><p>统计区域内包含文本和逻辑值的单元格个数。</p><p>注意counta函数与count函数的区别。</p><p>Count函数只统计区域内包含数字的单元格个数。</p></blockquote><p>1、指定多个范围单元格获取非空数据的个数</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=COUNTA(E4:E7,C2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8、四舍五入函数ROUND"><a href="#8、四舍五入函数ROUND" class="headerlink" title="8、四舍五入函数ROUND()"></a>8、四舍五入函数ROUND()</h3><blockquote><p>对数值进行四舍五入</p></blockquote><p>ROUND函数语法格式：</p><blockquote><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">ROUND(number, num_digits)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中</p><p>number表示需要进行四舍五入的数值或单元格内容。</p><p>num_digits表示需要取多少位的参数。</p><p>num_digits&gt;0时，表示取小数点后对应位数的四舍五入数值。</p><p>num_digits=0时，表示则将数字四舍五入到最接近的整数。</p><p>num_digits&lt; 0时，表示对小数点左侧前几位进行四舍五入。</p></blockquote><p>1、对指定单元格进行四舍五入</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=ROUND(E7,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK"><a href="#9、排名次函数RANK" class="headerlink" title="9、排名次函数RANK()"></a>9、排名次函数RANK()</h3><blockquote><p>返回一列数字的数字排位。 数字的排位是相对于列表中的其他值的大小。</p></blockquote><p>语法：RANK(number,ref,[order])</p><blockquote><p>RANK 函数语法具有下列参数：</p><ul><li><p><strong>Number</strong>   必需。 要找到其排位的数字。</p></li><li><p><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</p></li><li><p><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</p><p>如果 order 为 0（零）或省略，Microsoft Excel 对数字的排位是基于 ref 为按照降序排列的列表。</p><p>如果 order 不为零，Microsoft Excel 对数字的排位是基于 ref 为按照升序排列的列表。</p></li></ul></blockquote><p>1、获取指定单元格在范围内进行排名</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK(C3,C2:C11)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="9、排名次函数RANK-EQ"><a href="#9、排名次函数RANK-EQ" class="headerlink" title="9、排名次函数RANK.EQ()"></a>9、排名次函数RANK.EQ()</h3><p><code>与RANK函数用法一致</code></p><blockquote><p>返回一列数字的数字排位。 其大小与列表中其他值相关；如果多个值具有相同的排位，则返回该组值的最高排位。</p><p>如果要对列表进行排序，则数字排位可作为其位置。</p></blockquote><p>语法</p><blockquote><p>RANK.EQ(number,ref,[order])</p><p>RANK.EQ 函数语法具有下列参数：</p><ul><li><strong>Number</strong>   必需。 要找到其排位的数字。</li><li><strong>Ref</strong>   必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。</li><li><strong>Order</strong>   可选。 一个指定数字排位方式的数字。</li></ul><p>【注意】</p><ul><li>如果 Order 为 0（零）或省略，Excel 对数字的排位是基于 Ref 为按降序排列的列表。</li><li>如果 Order 不为零， Excel 对数字的排位是基于 Ref 为按照升序排列的列表。</li></ul></blockquote><p>1、升序排名</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK.EQ(C3,C2:C11,1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、降序排名(0可以省略)</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RANK.EQ(C3,C2:C11,0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10、取整函数INT"><a href="#10、取整函数INT" class="headerlink" title="10、取整函数INT()"></a>10、取整函数INT()</h3><blockquote><p>将数字向下舍入到最接近的整数。</p></blockquote><p>1、对指定单元格进行取整，忽略小数位</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=INT(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11、求字符串长度函数LEN"><a href="#11、求字符串长度函数LEN" class="headerlink" title="11、求字符串长度函数LEN()"></a>11、求字符串长度函数LEN()</h3><blockquote><p>返回文本字符串中的字符个数</p><p>【注意】数字，字符，汉字都属于一个字符，包括小数点</p></blockquote><p>1、对指定单元格获取长度</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEN(E3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12、左取字符串函数LEFT"><a href="#12、左取字符串函数LEFT" class="headerlink" title="12、左取字符串函数LEFT()"></a>12、左取字符串函数LEFT()</h3><blockquote><p>从文本字符串的第一个字符开始返回指定个数的字符</p></blockquote><p>语法</p><blockquote><p>LEFT(text, [num_chars])</p><p>该函数语法具有下列参数：</p><ul><li><strong>Text</strong>  必需。 包含要提取的字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定要由 LEFT 提取的字符的数量。<ul><li>num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 LEFT 返回全部文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></li></ul></blockquote><p>1、获取指定单元格从左开始的第一个字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEFT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=LEFT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13、右取字符串函数RIGHT"><a href="#13、右取字符串函数RIGHT" class="headerlink" title="13、右取字符串函数RIGHT()"></a>13、右取字符串函数RIGHT()</h3><blockquote><p>根据所指定的字符数返回文本字符串中最后一个或多个字符</p></blockquote><p>语法</p><blockquote><p>RIGHT(text,[num_chars])</p><p>RIGHT  函数具有下列参数：</p><ul><li><strong>文本</strong>  必需。 包含要提取字符的文本字符串。</li><li><strong>num_chars</strong>  可选。 指定希望 RIGHT 提取的字符数。</li><li>Num_chars 必须大于或等于零。</li><li>如果 num_chars 大于文本长度，则 RIGHT 返回所有文本。</li><li>如果省略 num_chars，则假定其值为 1。</li></ul></blockquote><p>1、获取指定单元格从右开始的第一个字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RIGHT(F2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、获取指定单元格从左开始的指定长度个数的字符</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=RIGHT(F2,3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="14、日函数DAY"><a href="#14、日函数DAY" class="headerlink" title="14、日函数DAY()"></a>14、日函数DAY()</h3><blockquote><p>返回以序列数表示的某日期的天数。 天数是介于 1 到 31 之间的整数。</p></blockquote><p>语法</p><blockquote><p>DAY(serial_number)</p><p>DAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f" target="_blank" rel="noopener">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=DAY(A2)</td><td>单元格 A2 (15) 中日期的天数</td><td>15</td></tr></tbody></table></div><h3 id="15、月函数MONTH"><a href="#15、月函数MONTH" class="headerlink" title="15、月函数MONTH()"></a>15、月函数MONTH()</h3><blockquote><p>返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。</p></blockquote><p>语法</p><blockquote><p>MONTH(serial_number)</p><p>MONTH 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 尝试查找的月份的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果<a href="https://support.microsoft.com/zh-cn/office/更改日期系统、格式或两位数年份表示方式-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f" target="_blank" rel="noopener">日期以文本形式输入</a>，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2011-4-15</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>说明</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=MONTH(A2)</td><td>单元格 A2 中日期的月份</td><td>4</td></tr></tbody></table></div><h3 id="16、年函数YEAR"><a href="#16、年函数YEAR" class="headerlink" title="16、年函数YEAR()"></a>16、年函数YEAR()</h3><blockquote><p>返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。</p></blockquote><p>语法</p><blockquote><p>YEAR(serial_number)</p><p>YEAR 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 要查找的年份的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th><strong>日期</strong></th><th></th><th></th></tr></thead><tbody><tr><td>2008-7-5</td><td></td><td></td></tr><tr><td>2010-7-5</td><td></td><td></td></tr><tr><td><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td>=YEAR(A3)</td><td>单元格 A3 中日期的年份 (2008)</td><td>2008</td></tr><tr><td>=YEAR(A4)</td><td>单元格 A4 中日期的年份 (2010)</td><td>2010</td></tr></tbody></table></div><h3 id="17、星期函数WEEKDAY"><a href="#17、星期函数WEEKDAY" class="headerlink" title="17、星期函数WEEKDAY()"></a>17、星期函数WEEKDAY()</h3><blockquote><p>返回对应于某个日期的一周中的第几天。 默认情况下，天数是 1（星期日）到 7（星期六）范围内的整数。</p></blockquote><p>语法</p><blockquote><p>WEEKDAY(serial_number,[return_type])</p><p>WEEKDAY 函数语法具有下列参数：</p><ul><li><strong>Serial_number</strong>  必需。 一个序列号，代表尝试查找的那一天的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。</li><li><strong>Return_type</strong>  可选。 用于确定返回值类型的数字。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Return_type</strong></th><th style="text-align:left"><strong>返回的数字</strong></th></tr></thead><tbody><tr><td style="text-align:left">1 或省略</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。 同 Microsoft Excel 早期版本。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">数字 0（星期一）到 6（星期日）。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">数字 1（星期一）到 7（星期日）。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">数字 1（星期二）到数字 7（星期一）。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">数字 1（星期三）到数字 7（星期二）。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">数字 1（星期四）到数字 7（星期三）。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">数字 1（星期五）到数字 7（星期四）。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">数字 1（星期六）到数字 7（星期五）。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">数字 1（星期日）到 7（星期六）。</td></tr></tbody></table></div></blockquote><p>备注</p><blockquote><ul><li>Microsoft Excel 可将日期存储为可用于计算的序列号。 默认情况下，1900 年 1 月 1 日的序列号是 1，而 2008 年 1 月 1 日的序列号是 39448，这是因为它距 1900 年 1 月 1 日有 39448 天。</li><li>如果当前日期基值的 serial_number 超出范围，则 #NUM！ 返回错误。</li><li>如果 return_type 超出了上表中指定的范围，则 #NUM！ 返回错误。</li></ul></blockquote><p>用法</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>数据</strong></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">2008-2-14</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>公式</strong></td><td><strong>描述（结果）</strong></td><td><strong>结果</strong></td></tr><tr><td style="text-align:left">=WEEKDAY(A2)</td><td>使用数字 1（星期日）到 7（星期六）表示的一周中的第几天 (5)</td><td>5</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 2)</td><td>使用数字 1（星期一）到 7（星期日）表示的一周中的第几天 (4)</td><td>4</td></tr><tr><td style="text-align:left">=WEEKDAY(A2, 3)</td><td>使用数字 0（星期一）到 6（星期日）表示的一周中的第几天 (3)</td><td>3</td></tr></tbody></table></div><h3 id="18、日期函数-DATE"><a href="#18、日期函数-DATE" class="headerlink" title="18、日期函数 DATE()"></a>18、日期函数 DATE()</h3><blockquote><p>返回表示特定日期的连续序列号。</p></blockquote><p>语法：</p><blockquote><p>DATE(year,month,day)</p><p>DATE 函数语法具有下列参数：</p><ul><li><strong>Year</strong>  ：必需。<strong><em>year\</em></strong> 参数的值可以包含一到四位数字。Excel 将根据计算机正在使用的日期系统来解释 <strong><em>year\</em></strong> 参数。默认情况下，Microsoft Excel for Windows 使用的是 1900 日期系统，这表示第一个日期为 1900 年 1 月 1 日。</li></ul><p><strong>提示:</strong> 为避免出现意外结果，请对 <strong><em>year\</em></strong> 参数使用四位数字。例如，“07”可能意味着“1907”或“2007”。因此，使用四位数的年份可避免混淆。</p><ul><li>如果 <strong><em>year\</em></strong> 介于 0（零）到 1899 之间（包含这两个值），则 Excel 会将该值与 1900 相加来计算年份。例如，DATE(108,1,2) 返回 2008 年 1 月 2 日 (1900+108)。</li><li>如果 <strong><em>year\</em></strong> 介于 1900 到 9999 之间（包含这两个值），则 Excel 将使用该数值作为年份。例如，DATE(2008,1,2) 将返回 2008 年 1 月 2 日。</li><li><p>如果 <strong><em>year\</em></strong> 小于 0 或大于等于 10000，则 Excel 返回 错误值 #NUM!。</p></li><li><p><strong>Month</strong>  必需。一个正整数或负整数，表示一年中从 1 月至 12 月（一月到十二月）的各个月。</p></li><li><p>如果 <strong><em>month\</em></strong> 大于 12，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始加上该月份数。例如，DATE(2008,14,2) 返回表示 2009 年 2 月 2 日的序列数。</p></li><li><p>如果 <strong><em>month\</em></strong> 小于 1，则 <strong><em>month\</em></strong> 会从指定年份的第一个月开始减去该月份数，然后再加上 1 个月。例如，DATE(2008,-3,2) 返回表示 2007 年 9 月 2 日的序列号。</p></li><li><p><strong>Day</strong>  必需。一个正整数或负整数，表示一月中从 1 日到 31 日的各天。</p></li><li><p>如果 <strong><em>day\</em></strong> 大于指定月中的天数，则 <strong><em>day\</em></strong> 会从该月的第一天开始加上该天数。例如，DATE(2008,1,35) 返回表示 2008 年 2 月 4 日的序列数。</p></li><li>如果 <strong><em>day\</em></strong> 小于 1，则 <strong><em>day\</em></strong> 从指定月份的第一天开始减去该天数，然后再加上 1 天。例如，DATE(2008,1,-15) 返回表示 2007 年 12 月 16 日的序列号。</li></ul><p><strong>注意:</strong> Excel 可将日期存储为连续序列号，以便能在计算中使用它们。1900 年 1 月 1 日的序列号为 1，2008 年 1 月 1 日的序列号为 39448，这是因为它与 1900 年 1 月 1 日之间相差 39,447 天。需要更改数字格式（设置单元格格式）以显示正确的日期。</p></blockquote><p>用法</p><p><strong>=DATE(C2,A2,B2)</strong> 将单元格 C2 中的年、单元格 A2 中的月以及单元格 B2 中的日合并在一起，并将它们放入一个单元格内作为日期。</p><pre class="line-numbers language-lang-excel"><code class="language-lang-excel">=DATE(C2,A2,B2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Excel函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的创建及使用</title>
      <link href="posts/51549.html"/>
      <url>posts/51549.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>第一步肯定是创建数据库了.看下图操作：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224153.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224722.png" alt=""></p><p>先创建一个名字为 <font color='red'>company的数据库</font> 输入以下内容然后全选右键运行，如图（最好先保存防止下次找不到上次所写内容）</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104224844.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201104225129.png" alt=""></p><p> 点击最下方的刷新</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091503.png" alt=""></p><p>然后自己所创建的数据库就出来了，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105091636.png" alt=""></p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>以下为添加数据的内容，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105092334.png" alt=""></p><p>选中添加内容，运行，如图</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101502.png" alt=""></p><h2 id="查询emp表"><a href="#查询emp表" class="headerlink" title="查询emp表"></a>查询emp表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101742.png" alt=""></p><h2 id="修改表内容"><a href="#修改表内容" class="headerlink" title="修改表内容"></a>修改表内容</h2><h3 id="注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样"><a href="#注意：-修改后运行上方所写查询就可看到修改的内容-后续修改的内容同此方法一样" class="headerlink" title="注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样"></a>注意： 修改后运行上方所写查询就可看到修改的内容 后续修改的内容同此方法一样</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101854.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102729.png" alt=""></p><h2 id="删除表内容"><a href="#删除表内容" class="headerlink" title="删除表内容"></a>删除表内容</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105101935.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103100.png" alt=""></p><h2 id="更改表名"><a href="#更改表名" class="headerlink" title="更改表名"></a>更改表名</h2><h3 id="运行后到最左方右键，点击刷新就可看到更改的表名"><a href="#运行后到最左方右键，点击刷新就可看到更改的表名" class="headerlink" title="运行后到最左方右键，点击刷新就可看到更改的表名"></a>运行后到最左方右键，点击刷新就可看到更改的表名</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102030.png" alt=""></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105103458.png" alt=""></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105030.png" alt=""></p><h2 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102148.png" alt="image-20201105102145614"></p><p>修改前</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105239.png" alt="image-20201105105238598"></p><p>修改后</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105500.png" alt="image-20201105105459408"></p><h2 id="添加列及删除列"><a href="#添加列及删除列" class="headerlink" title="添加列及删除列"></a>添加列及删除列</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105102228.png" alt="image-20201105102227470"></p><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105635.png" alt="image-20201105105632391"></p><p>删除列</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105105726.png" alt="image-20201105105725397"></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110012.png" alt="image-20201105110011837"></p><h2 id="创建新表添加新内容"><a href="#创建新表添加新内容" class="headerlink" title="创建新表添加新内容"></a>创建新表添加新内容</h2><p>注意：逐条运行   出现如下图最下方受影响及时间为运行成功！</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105110906.png" alt="image-20201105110904752"></p><p>运行结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201105111129.png" alt="image-20201105111128007"></p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">#创建数据库create database company charset=utf8;use company;create table emp(    eid int primary key,    ename varchar(20),    eage int,    esex varchar(5),  joindate date) charset=utf8;#添加数据insert into emp(eid,ename,eage,esex,joindate)     value(1,'张三',18,'男','2019-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(2,'李四',19,'男','2018-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(3,'王五',17,'女','2017-09-05');insert into emp(eid,ename,eage,esex,joindate)     value(4,'赵六',20,'男','2020-09-05');#查询emp表select eid,ename,eage,esex,joindate from emp;select eid,ename,eage from emp;select * from emp;#把eid等于4的记录的ename的值改为赵若男update emp set ename='赵若男',esex='女' where eid=4;#删除eid等于3的数据delete from emp where eid=3;#更改表结构#把表名改为employalter table emp rename employ;select * from employ;#把字段名esex改为egenderalter table employ change esex egender varchar(5);#添加etel列alter table employ add etel varchar(17); #删除etel列alter table employ drop etel;#删除employ表drop table employ;drop table emp;use company;create table emp(    eid int primary key,    ename varchar(20) not null,    esex  enum('男','女') default '男',    etel varchar(17)  not null unique)insert into emp(eid,ename,esex,etel) value(1,'张三','男','18530900286');insert into emp(eid,ename,esex,etel) value(2,'张三','女','18530900287');insert into emp(eid,ename,etel) value(3,'赵四','18530900288');insert into emp(eid,ename,etel) value(4,'赵三','18530900289');insert into emp(eid,ename,etel) value(5,'赵五','18530900290');insert into emp(eid,ename,etel) value(6,'赵六','18530900277');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql"># 删除某表delete from 表名;# truncate table 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MySQL语句"><a href="#MySQL语句" class="headerlink" title="MySQL语句"></a>MySQL语句</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">1、说明：创建数据库CREATE DATABASE database-name2、说明：删除数据库drop database dbname3、说明：备份sql server--- 创建 备份数据的 deviceUSE masterEXEC sp_addumpdevice 'disk', 'testBack', 'c:\mssql7backup\MyNwind_1.dat'--- 开始 备份BACKUP DATABASE pubs TO testBack4、说明：创建新表create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)根据已有的表创建新表：A：create table tab_new like tab_old (使用旧表创建新表)B：create table tab_new as select col1,col2… from tab_old definition only5、说明：删除新表drop table tabname6、说明：增加一个列Alter table tabname add column col type注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。7、说明：添加主键： Alter table tabname add primary key(col)说明：删除主键： Alter table tabname drop primary key(col)8、说明：创建索引：create [unique] index idxname on tabname(col….)删除索引：drop index idxname注：索引是不可更改的，想更改必须删除重新建。9、说明：创建视图：create view viewname as select statement删除视图：drop view viewname10、说明：几个简单的基本的sql语句选择：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table111、说明：几个高级查询运算词A： UNION 运算符UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。B： EXCEPT 运算符EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。C： INTERSECT 运算符INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。注：使用运算词的几个查询结果行必须是一致的。12、说明：使用外连接A、left （outer） join：左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.cB：right （outer） join:右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。C：full/cross （outer） join：全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。12、分组:Group by:  一张表，一旦分组完成后，查询后只能得到组相关的信息。 组相关的信息：（统计信息） count,sum,max,min,avg  分组的标准)    在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据 在selecte统计函数中的字段，不能和普通的字段放在一起；13、对数据库进行操作： 分离数据库： sp_detach_db; 附加数据库：sp_attach_db 后接表明，附加需要完整的路径名14.如何修改数据库的名称:sp_renamedb 'old_name', 'new_name'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="提升语句及案例"><a href="#提升语句及案例" class="headerlink" title="提升语句及案例"></a>提升语句及案例</h2><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">二、提升1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)法一：select * into b from a where 1<>1（仅用于SQlServer）法二：select top 0 * into b from a2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)insert into b(a, b, c) select d,e,f from b;3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件例子：..from b in '"&Server.MapPath(".")&"\data.mdb" &"' where..4、说明：子查询(表名1：a 表名2：b)select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)5、说明：显示文章、提交人和最后回复时间select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b6、说明：外连接查询(表名1：a 表名2：b)select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c7、说明：在线视图查询(表名1：a )select * from (SELECT a,b,c FROM a) T where t.a > 1;8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括select * from table1 where time between time1 and time2select a,b,c, from table1 where a not between 数值1 and 数值29、说明：in 的使用方法select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)10、说明：两张关联表，删除主表中已经在副表中没有的信息delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )11、说明：四表联查问题：select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....12、说明：日程安排提前五分钟提醒SQL: select * from 日程安排 where datediff('minute',f开始时间,getdate())>513、说明：一条sql 语句搞定数据库分页select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段具体实现：关于数据库分页：  declare @start int,@end int  @sql  nvarchar(600)  set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid>-1)’  exec sp_executesql @sql注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）14、说明：前10条记录select top 10 * form table1 where 范围15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表(select a from tableA ) except (select a from tableB) except (select a from tableC)17、说明：随机取出10条数据select top 10 * from tablename order by newid()18、说明：随机选择记录select newid()19、说明：删除重复记录1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)2),select distinct * into temp from tablename  delete from tablename  insert into tablename select * from temp评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段alter table tablename--添加一个自增列add  column_b int identity(1,1) delete from tablename where column_b not in(select max(column_b)  from tablename group by column1,column2,...)alter table tablename drop column column_b20、说明：列出数据库里所有的表名select name from sysobjects where type='U' // U代表用户21、说明：列出表里的所有的列名select name from syscolumns where id=object_id('TableName')22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。select type,sum(case vender when 'A' then pcs else 0 end),sum(case vender when 'C' then pcs else 0 end),sum(case vender when 'B' then pcs else 0 end) FROM tablename group by type显示结果：type vender pcs电脑 A 1电脑 A 1光盘 B 2光盘 A 2手机 B 3手机 C 323、说明：初始化表table1TRUNCATE TABLE table124、说明：选择从10到15的记录select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">三、技巧1、1=1，1=2的使用，在SQL语句组合时用的较多“where 1=1” 是表示选择全部    “where 1=2”全部不选，如：if @strWhere !=''beginset @strSQL = 'select count(*) as Total from [' + @tblName + '] where ' + @strWhereendelsebeginset @strSQL = 'select count(*) as Total from [' + @tblName + ']'end我们可以直接写成错误！未找到目录项。set @strSQL = 'select count(*) as Total from [' + @tblName + '] where 1=1 安定 '+ @strWhere 2、收缩数据库--重建索引DBCC REINDEXDBCC INDEXDEFRAG--收缩数据和日志DBCC SHRINKDBDBCC SHRINKFILE3、压缩数据库dbcc shrinkdatabase(dbname)4、转移数据库给新用户以已存在用户权限exec sp_change_users_login 'update_one','newname','oldname'go5、检查备份集RESTORE VERIFYONLY from disk='E:\dvbbs.bak'6、修复数据库ALTER DATABASE [dvbbs] SET SINGLE_USERGODBCC CHECKDB('dvbbs',repair_allow_data_loss) WITH TABLOCKGOALTER DATABASE [dvbbs] SET MULTI_USERGO7、日志清除SET NOCOUNT ONDECLARE @LogicalFileName sysname, @MaxMinutes INT, @NewSize INTUSE tablename -- 要操作的数据库名SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名@MaxMinutes = 10, -- Limit on time allowed to wrap log. @NewSize = 1  -- 你想设定的日志文件的大小(M)Setup / initializeDECLARE @OriginalSize intSELECT @OriginalSize = size FROM sysfiles WHERE name = @LogicalFileNameSELECT 'Original Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' + CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameCREATE TABLE DummyTrans (DummyColumn char (8000) not null)DECLARE @Counter    INT, @StartTime DATETIME, @TruncLog   VARCHAR(255)SELECT @StartTime = GETDATE(), @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'DBCC SHRINKFILE (@LogicalFileName, @NewSize)EXEC (@TruncLog)-- Wrap the log if necessary.WHILE @MaxMinutes > DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)  AND (@OriginalSize * 8 /1024) > @NewSize  BEGIN -- Outer loop.SELECT @Counter = 0 WHILE   ((@Counter < @OriginalSize / 16) AND (@Counter < 50000)) BEGIN -- update INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans SELECT @Counter = @Counter + 1 END EXEC (@TruncLog)  ENDSELECT 'Final Size of ' + db_name() + ' LOG is ' + CONVERT(VARCHAR(30),size) + ' 8K pages or ' + CONVERT(VARCHAR(30),(size*8/1024)) + 'MB' FROM sysfiles WHERE name = @LogicalFileNameDROP TABLE DummyTransSET NOCOUNT OFF8、说明：更改某个表exec sp_changeobjectowner 'tablename','dbo'9、存储更改全部表CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch@OldOwner as NVARCHAR(128),@NewOwner as NVARCHAR(128)ASDECLARE @Name    as NVARCHAR(128)DECLARE @Owner   as NVARCHAR(128)DECLARE @OwnerName   as NVARCHAR(128)DECLARE curObject CURSOR FORselect 'Name'    = name,   'Owner'    = user_name(uid)from sysobjectswhere user_name(uid)=@OldOwnerorder by nameOPEN   curObjectFETCH NEXT FROM curObject INTO @Name, @OwnerWHILE(@@FETCH_STATUS=0)BEGIN   if @Owner=@OldOwnerbegin   set @OwnerName = @OldOwner + '.' + rtrim(@Name)   exec sp_changeobjectowner @OwnerName, @NewOwnerend-- select @name,@NewOwner,@OldOwnerFETCH NEXT FROM curObject INTO @Name, @OwnerENDclose curObjectdeallocate curObjectGO10、SQL SERVER中直接循环写入数据declare @i intset @i=1while @i<30begin    insert into test (userid) values(@i)    set @i=@i+1end案例：有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格: Name     score Zhangshan 80 Lishi       59 Wangwu      50 Songquan 69while((select min(score) from tb_table)<60)beginupdate tb_table set score =score*1.01where score<60if  (select min(score) from tb_table)>60  break else    continueend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据开发-经典"><a href="#数据开发-经典" class="headerlink" title="数据开发-经典"></a>数据开发-经典</h3><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">1.按姓氏笔画排序:Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多2.数据库加密:select encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同 encrypt('原始密码')select pwdencrypt('原始密码')select pwdcompare('原始密码','加密后密码') = 1--相同；否则不相同3.取回表中字段:declare @list varchar(1000),@sql nvarchar(1000)select @list=@list+','+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name='表A'set @sql='select '+right(@list,len(@list)-1)+' from 表A'exec (@sql)4.查看硬盘分区:EXEC master..xp_fixeddrives5.比较A,B表是否相等:if (select checksum_agg(binary_checksum(*)) from A)     =    (select checksum_agg(binary_checksum(*)) from B)print '相等'elseprint '不相等'6.杀掉所有的事件探察器进程:DECLARE hcforeach CURSOR GLOBAL FOR SELECT 'kill '+RTRIM(spid) FROM master.dbo.sysprocessesWHERE program_name IN('SQL profiler',N'SQL 事件探查器')EXEC sp_msforeach_worker '?'7.记录搜索:开头到N条记录Select Top N * From 表-------------------------------N到M条记录(要有主索引ID)Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID   Desc----------------------------------N到结尾记录Select Top N * From 表 Order by ID Desc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】本文章从MySQL语句开始并非本人所写，转自于<a href="https://www.cnblogs.com/zhuyongzhe/p/7686098.html" target="_blank" rel="noopener">mysql sql语句大全（MySQL语句 整理一） - zhuyongzhe - 博客园 (cnblogs.com)</a>，写到这里只为方便自己查看</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130224112.jpg" alt="110"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201130224041.jpeg" alt="1606644654915"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的安装</title>
      <link href="posts/24482.html"/>
      <url>posts/24482.html</url>
      
        <content type="html"><![CDATA[<p>想学MySQL首先要学会安装，安装包如下：</p><p><a href="https://share.weiyun.com/NvbChzFu" target="_blank" rel="noopener">传送门</a></p><h2 id="一、-什么是数据库"><a href="#一、-什么是数据库" class="headerlink" title="一、 什么是数据库"></a>一、 什么是数据库</h2><p>数据库是用来存储数据的仓库，互联的数据中心(idc ),绝大部分数据是通过数据库存储的。</p><h2 id="二、-数据库的种类"><a href="#二、-数据库的种类" class="headerlink" title="二、 数据库的种类"></a>二、 数据库的种类</h2><p>数据库有两大类：第一类是关系型数据库，第二类非关系型数据库</p><p>关系型数据库：mysql、oracle、sql server、mariadb</p><p>非关系型数据库：redis </p><h2 id="三、-数据库的安装"><a href="#三、-数据库的安装" class="headerlink" title="三、 数据库的安装"></a>三、 数据库的安装</h2><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124903.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124926.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124936.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102124958.png" alt=""></p><p>点击finish安装完成，开始对mysql进行配置</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125028.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125037.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125053.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125109.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125124.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125139.png" alt=""></p><p>这一步是调整允许数据库最大并发连接数</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125203.png" alt=""></p><p>这一步是设置mysql的端口号，默认是3306</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125219.png" alt=""></p><p>这一步是设置数据库的编码格式，改为了utf-8</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125236.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125246.png" alt=""></p><p>这一步设置数据库的密码，要输入两次一样的密码，不要设置过于复杂的密码</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125304.png" alt=""></p><p>四个对号安装成功，并且启动成功</p><h2 id="四、mysql服务器与客户端"><a href="#四、mysql服务器与客户端" class="headerlink" title="四、mysql服务器与客户端"></a>四、mysql服务器与客户端</h2><p>​    以上的过程安装的是mysql服务器。如果想对mysql服务器进行操作，还需要安装客户端连接上mysql服务器。比较常用的客户端有navicat、sql yog.</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201102125348.png" alt=""></p><h2 id="五、mysql数据库的名词解释"><a href="#五、mysql数据库的名词解释" class="headerlink" title="五、mysql数据库的名词解释"></a><strong>五、mysql数据库的名词解释</strong></h2><h3 id="数据库与数据表"><a href="#数据库与数据表" class="headerlink" title="数据库与数据表"></a>数据库与数据表</h3><p>​    数据库不直接存放数据，而先把数据存放到一张张数据表里，然后再把表放到数据库里。一个数据库里表都是相互有关系的。</p><h3 id="数据表的字段属性、记录"><a href="#数据表的字段属性、记录" class="headerlink" title="数据表的字段属性、记录"></a><strong>数据表的字段属性、记录</strong></h3><p> 数据表的列称为字段或属性，数据表的行称为记录。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a><strong>实体</strong></h3><p> 实体就是客观存在并可以相互区别的事物。表就是用来记录实体的信息的。</p><h2 id="六、创建数据库"><a href="#六、创建数据库" class="headerlink" title="六、创建数据库"></a>六、创建数据库</h2><p>​    Mysql服务器上默认有三个数据库，其中mysql数据库里边存储着用户信息等重要内容。当然也可以自己创建数据库。</p><h2 id="七、mysql数据库的数据类型"><a href="#七、mysql数据库的数据类型" class="headerlink" title="七、mysql数据库的数据类型"></a><strong>七、mysql数据库的数据类型</strong></h2><p>  <strong>整型：</strong> int</p><p>  <strong>浮点型</strong>： float(默认有七位小数)  double(默认有15位小数)  decimal(P,S) S是保留的小数位数，P数值的长度</p><p>  <strong>字符型：</strong>char(固定长度的类型) varchar(可变长度的类型)  text</p><p>​        固定长度和可变长度的区别：以char(20) varchar(20)为例。Char(20)不管存储内容长度是几个字节，都占内存的20个字节。Varchar(20) 存储的内容长度是几个字节，就占内存的几个字节。</p><p>  <strong>日期时间：</strong></p><p>​    日期： date（YYYY-MM-DD）</p><p>​    时间： time (HH:MM:SS)</p><p>​    日期时间：datetime (YYYY-MM-DD HH:MM:SS)</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github图床搭建</title>
      <link href="posts/53653.html"/>
      <url>posts/53653.html</url>
      
        <content type="html"><![CDATA[<p>由于平时在写markdown文档时会引用很多的图片，但是图片是不可以直接粘贴上去的，所以我一般都要把图片放在一个文件夹里面，再导入图片。这样做比较繁琐，而且还存在如果我修改了路径，图片就不显示的问题。<br> 于是就发现了这个神器——<strong>PicGo</strong></p><h3 id="1、先下载个PicGo，如下"><a href="#1、先下载个PicGo，如下" class="headerlink" title="1、先下载个PicGo，如下"></a>1、先下载个PicGo，如下</h3><p><a href="https://share.weiyun.com/mSUFa7MN" target="_blank" rel="noopener">传送门</a></p><h3 id="2-安装软件，打开软件，图床设置"><a href="#2-安装软件，打开软件，图床设置" class="headerlink" title="2 安装软件，打开软件，图床设置"></a>2 安装软件，打开软件，图床设置</h3><pre class="line-numbers language-lang-json"><code class="language-lang-json">{  "repo": "", // 仓库名，格式是username/reponame  "token": "", // github token  "path": "", // 自定义存储路径，比如img/  "customUrl": "", // 自定义域名，注意要加http://或者https://  "branch": "" // 分支名，默认是master}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-首先你得有一个GitHub账号。注册GitHub就不用我多言。"><a href="#1-首先你得有一个GitHub账号。注册GitHub就不用我多言。" class="headerlink" title="1. 首先你得有一个GitHub账号。注册GitHub就不用我多言。"></a><strong>1.</strong> 首先你得有一个GitHub账号。注册GitHub就不用我多言。</h4><h4 id="2-新建一个仓库"><a href="#2-新建一个仓库" class="headerlink" title="2. 新建一个仓库"></a><strong>2.</strong> 新建一个仓库</h4><p>记下你取的仓库名。</p><p>如我的：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031123905.png" alt="1"></p><h4 id="3-生成一个token用于PicGo操作你的仓库："><a href="#3-生成一个token用于PicGo操作你的仓库：" class="headerlink" title="3. 生成一个token用于PicGo操作你的仓库："></a><strong>3.</strong> 生成一个token用于PicGo操作你的仓库：</h4><p>访问：<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a></p><p>然后点击<code>Generate new token</code>。</p><p>把repo的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成token。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><p>这个token生成后只会显示一次！你要把这个token复制一下存到其他地方以备以后要用。</p><h4 id="4-配置PicGo"><a href="#4-配置PicGo" class="headerlink" title="4. 配置PicGo"></a><strong>4.</strong> 配置PicGo</h4><p><strong>注意：</strong>仓库名的格式是<code>用户名/仓库</code>  中间不能出现空格，比如我创建了一个叫做Picture的仓库，在PicGo里我要设定的仓库名就是<code>wind-qin/Picture</code>。一般我们选择<code>master</code>分支即可。然后记得点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是GitHub。</p><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201031124250.png" alt="图床1"></p><h4 id="5-配置Typora"><a href="#5-配置Typora" class="headerlink" title="5. 配置Typora"></a><strong>5.</strong> 配置Typora</h4><p>然后点击Typora左上角文件     偏好设置 点击图像</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120628.png" alt="image-20201106120619756"></p><p>点击验证图片上传选项为true则配置正确</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201106120714.png" alt="image-20201106120711559"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了：</p><p>如想了解其他图床的安装请前往：</p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" target="_blank" rel="noopener">https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A</a></p>]]></content>
      
      
      <categories>
          
          <category> github图床搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora写法</title>
      <link href="posts/28493.html"/>
      <url>posts/28493.html</url>
      
        <content type="html"><![CDATA[<h1 id="Typora的下载"><a href="#Typora的下载" class="headerlink" title="Typora的下载"></a>Typora的下载</h1><p><a href="https://share.weiyun.com/QOIBRwsr" target="_blank" rel="noopener">下载</a></p><h1 id="Typora的写法"><a href="#Typora的写法" class="headerlink" title="Typora的写法"></a>Typora的写法</h1><h3 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h3><h4 id="标题的使用格式"><a href="#标题的使用格式" class="headerlink" title="标题的使用格式"></a>标题的使用格式</h4><p># 一阶标题 或者快捷键Ctrl+1</p><p>##二阶标题 或者快捷键Ctrl+2</p><p>###三阶标题 或者快捷键Ctrl+3</p><p>####四阶标题 或者快捷键Ctrl+4</p><p>#####五阶标题 或者快捷键Ctrl+5</p><p>######六阶标题 或者快捷键Ctrl+6</p><h4 id="标题Typora显示形式是"><a href="#标题Typora显示形式是" class="headerlink" title="标题Typora显示形式是"></a>标题Typora显示形式是</h4><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图01.png" alt=""></p><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><h4 id="文本居中使用格式"><a href="#文本居中使用格式" class="headerlink" title="文本居中使用格式"></a>文本居中使用格式</h4><pre><code>&lt;center&gt;这是要居中的文本内容&lt;/center&gt;</code></pre><h4 id="文本居中显示形式是"><a href="#文本居中显示形式是" class="headerlink" title="文本居中显示形式是"></a>文本居中显示形式是</h4><p><center>这是要居中的文本内容</center><br>注：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。 </p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><h4 id="下划线使用格式"><a href="#下划线使用格式" class="headerlink" title="下划线使用格式"></a>下划线使用格式</h4><pre><code> &lt;u&gt;下划线的内容&lt;u&gt;</code></pre><p>或者快捷键Ctrl+U</p><h4 id="下划线在Typora显示形式是"><a href="#下划线在Typora显示形式是" class="headerlink" title="下划线在Typora显示形式是"></a>下划线在Typora显示形式是</h4><p> <u>这就是我亲测的下划线</u></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>删除线使用格式</p><pre><code>~~删除线的内容~~</code></pre><h4 id="删除线在Typora显示形式是"><a href="#删除线在Typora显示形式是" class="headerlink" title="删除线在Typora显示形式是"></a>删除线在Typora显示形式是</h4><p><del>这是删除线的内容</del></p><h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><h4 id="字体加粗使用格式"><a href="#字体加粗使用格式" class="headerlink" title="字体加粗使用格式"></a>字体加粗使用格式</h4><pre><code> **加粗字体**</code></pre><p> 或者快捷键Ctrl+B </p><h4 id="字体加粗在Typora显示形式是"><a href="#字体加粗在Typora显示形式是" class="headerlink" title="字体加粗在Typora显示形式是"></a>字体加粗在Typora显示形式是</h4><p><strong>加粗字体 This is a bold font</strong></p><h3 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h3><h4 id="字体倾斜使用格式"><a href="#字体倾斜使用格式" class="headerlink" title="字体倾斜使用格式"></a>字体倾斜使用格式</h4><pre><code>*字体倾斜了*</code></pre><p> 或者快捷键Ctrl+I </p><h4 id="字体倾斜在Typora的显示形式"><a href="#字体倾斜在Typora的显示形式" class="headerlink" title="字体倾斜在Typora的显示形式"></a>字体倾斜在Typora的显示形式</h4><p> <em>字体倾斜了 This is a alanted font</em> </p><h3 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h3><p> 最简单粗暴的图片插入方式如图 :</p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图05.gif" alt=""></p><h3 id="视频的插入"><a href="#视频的插入" class="headerlink" title="视频的插入"></a>视频的插入</h3><p>方法一：</p><pre><code>&lt;video src=&quot;地址&quot;&gt;&lt;/video&gt;</code></pre><p>方法二：</p><pre><code>&lt;/iframe height=498 width=510 src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot;&gt;</code></pre><p>注意：方法一可如插入图片般直接拉入，方法二由于插入视频后在博客中会将视频以下内容顶掉，在此将不再添加，如有兴趣可在Typora中添加尝试</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="超链接使用格式"><a href="#超链接使用格式" class="headerlink" title="超链接使用格式"></a>超链接使用格式</h4><p>第一种：<a href="http://www.simba.com" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：快捷键Ctrl+K</p><pre><code> [自定义内容](超链接地址) 例如：[百度一下](www.baidu.com)</code></pre><h4 id="超链接在Typora显示形式是：（必须以http开头）"><a href="#超链接在Typora显示形式是：（必须以http开头）" class="headerlink" title="超链接在Typora显示形式是：（必须以http开头）"></a>超链接在Typora显示形式是：（必须以http开头）</h4><p>第一种：<a href="http://www.simba.com" target="_blank" rel="noopener">http://www.simba.com</a></p><p>第二种：<a href="https://blog.csdn.net/SIMBA1949/article/details/www.baidu.com" target="_blank" rel="noopener">百度一下</a></p><p>按住Ctrl键+点击上面链接就可以直接访问该链接</p><h3 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h3><p> Typora支持对多种语言的代码区域进行<strong>语法高亮</strong>。这些语言可以说是<strong>涵盖了绝大部分经常使用的编程语言</strong>，包括C++，Python，MATLAB，甚至包含spreadsheet（也就是Excel电子表格）。用Typora记编程笔记，看起来一清二楚。如果设置代码语言为flow，那么可以直接画出一个流程图；还可以使用相应的方法画出时序图等图表。 </p><h4 id="代码区域的使用格式"><a href="#代码区域的使用格式" class="headerlink" title="代码区域的使用格式"></a>代码区域的使用格式</h4><pre><code>` ` `+编程语言：例如java代码：` ` `java</code></pre><p>在代码块的右下角写所用的编程语言</p><h4 id="代码区域在typora中显示形式"><a href="#代码区域在typora中显示形式" class="headerlink" title="代码区域在typora中显示形式"></a>代码区域在typora中显示形式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class simba{  public static void main(String[] args){    System.out.println("梦回大唐");  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h3><h4 id="表格的二种使用格式"><a href="#表格的二种使用格式" class="headerlink" title="表格的二种使用格式"></a>表格的二种使用格式</h4><p> 第一种：快捷键<strong>Ctrl+T</strong>，会自动跳出设置行和列的设置框，如下图 </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图06.jpg" alt=""></p><p>第二种：</p><p>|国籍|省份|市区|</p><h3 id="表格在typora中显示形式"><a href="#表格在typora中显示形式" class="headerlink" title="表格在typora中显示形式"></a>表格在typora中显示形式</h3><p>第一种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>李太白</td><td>123456</td></tr></tbody></table></div><p>第二种：</p><div class="table-container"><table><thead><tr><th>id</th><th>username</th><th>password</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><h3 id="任务列表使用格式"><a href="#任务列表使用格式" class="headerlink" title="任务列表使用格式"></a>任务列表使用格式</h3><p>右键  如图：</p><p> <img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图07.png" alt=""></p><h3 id="任务列表在typora中的显示形式"><a href="#任务列表在typora中的显示形式" class="headerlink" title="任务列表在typora中的显示形式"></a>任务列表在typora中的显示形式</h3><ul><li><p>[x] JAVA</p></li><li><p>[x]  C</p></li><li><p>[ ]  C++</p></li><li><p>[ ]  Python</p><p>（注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图08.png" alt=""></p></li></ul><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="列表的使用格式"><a href="#列表的使用格式" class="headerlink" title="列表的使用格式"></a>列表的使用格式</h4><p>+ 、- 、* 创建无序列，任意数字开始+空格创建有序列表</p><h4 id="列表在typora中的显示形式"><a href="#列表在typora中的显示形式" class="headerlink" title="列表在typora中的显示形式"></a>列表在typora中的显示形式</h4><ul><li>java</li><li>C</li><li>C++</li><li>Python</li></ul><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><h4 id="水平分割线的使用格式"><a href="#水平分割线的使用格式" class="headerlink" title="水平分割线的使用格式"></a>水平分割线的使用格式</h4><p><em>*</em>或者- - -</p><h4 id="水平分割线在typora中显示形式"><a href="#水平分割线在typora中显示形式" class="headerlink" title="水平分割线在typora中显示形式"></a>水平分割线在typora中显示形式</h4><hr><hr><p> 注意：在CSDN博客上未显示，但是在Typora上显示如下图： </p><p><img src="http://qinjunxiang.gitee.io/Pictures\Typora用法图03.png" alt=""></p><h3 id="改变字体的颜色"><a href="#改变字体的颜色" class="headerlink" title="改变字体的颜色"></a>改变字体的颜色</h3><h4 id="改变颜色的格式"><a href="#改变颜色的格式" class="headerlink" title="改变颜色的格式"></a>改变颜色的格式</h4><pre><code>&lt;font color=&#39;red&#39;&gt;改变字体的颜色&lt;/font&gt;</code></pre><h4 id="字体在typora中显示形式"><a href="#字体在typora中显示形式" class="headerlink" title="字体在typora中显示形式"></a>字体在typora中显示形式</h4><font color='red'>改变字体的颜色</font><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="注释的格式"><a href="#注释的格式" class="headerlink" title="注释的格式"></a>注释的格式</h4><pre><code>&lt;!--才能够显示--&gt;</code></pre><p>注意：注释后Typora中显示注释的内容，但展示页面中不显示</p><h3 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl+1</td><td>一阶标题</td><td>Ctrl+B</td><td>字体加粗</td></tr><tr><td>Ctrl+2</td><td>二阶标题</td><td>Ctrl+I</td><td>字体倾斜</td></tr><tr><td>Ctrl+3</td><td>三阶标题</td><td>Ctrl+U</td><td>下划线</td></tr><tr><td>Ctrl+4</td><td>四阶标题</td><td>Ctrl+Home</td><td>返回Typora顶部</td></tr><tr><td>Ctrl+5</td><td>五阶标题</td><td>Ctrl+End</td><td>返回Typora底部</td></tr><tr><td>Ctrl+6</td><td>六阶标题</td><td>Ctrl+T</td><td>创建表格</td></tr><tr><td>Ctrl+L</td><td>选中某句话</td><td>Ctrl+K</td><td>创建超链接</td></tr><tr><td>Ctrl+D</td><td>选中某个单词</td><td>Ctrl+F</td><td>搜索</td></tr><tr><td>Ctrl+E</td><td>选中相同格式的文字</td><td>Ctrl+H</td><td>搜索并替换</td></tr><tr><td>Alt+Shift+5</td><td>删除线</td><td>Ctrl+Shift+I</td><td>插入图片</td></tr></tbody></table></div><p>注：一些实体符号需要在实体符号之前加””</p>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>甫子寸诗集</title>
      <link href="posts/36937.html"/>
      <url>posts/36937.html</url>
      
        <content type="html"><![CDATA[<p>在此处甫子寸的诗纯个人喜欢的节选。</p><p>世间有些许荒唐，不如与我兴风作浪。</p><h3 id="《天经地义》"><a href="#《天经地义》" class="headerlink" title="《天经地义》"></a>《天经地义》</h3><p>知道吗，</p><p>这世间有很多事</p><p>是不用讲道理的，</p><p>就像我喜欢你，</p><p>不用落笔，</p><p>天经地义.</p><p>​                     —————甫子寸诗歌《天经地义》</p><h3 id="《东坡先生》"><a href="#《东坡先生》" class="headerlink" title="《东坡先生》"></a>《东坡先生》</h3><p> 大宋的明月照耀了千里，<br>却唯独照不到你。<br>你说沙洲寂寥，<br>倒也好过寒枝凄栖。<br>只寻常的入京赴考，<br>一纸策论便横空临世，<br>许是锋芒太盛？<br>竟令那山水醉翁也自叹弗如？</p><p>天才与伟人只差一个悲剧，<br>那权倾朝野的政敌沉迷变法，<br>乌台狂风起于你自由的豪尖，<br>向来墙倒众人推，<br>书生杀人不见血。<br>虎落平阳本就有趣，<br>落井下石是否更大快人心？！</p><p>自京师一贬直下到黄州，<br>耕垦隔绝新党的冷笑，<br>吹散天朝的遗风，<br>给大宋的文坛拆了细看，<br>竟再出不得如此人物，<br>上下五千年的洒脱，<br>败给谁的竹杖芒鞋。<br>把酒问天上宫阙，<br>抬眸见阴晴圆缺，<br>仙心欲归琼楼，<br>落笔却是那烟火人间。</p><p>大江东去，<br>你也随之东去，<br>雄姿英发，谈笑赤壁，<br>究竟是周郎还是你东坡居士？<br>擦去这些年的斜风细雨，<br>仍旧说着诗酒年华忘却鬓角的银发。<br>生平一点浩然气，<br>十年生死别亡妻，<br>门前的流水当真能西行？<br>如今恍惚相遇的互望无言，<br>不过又是一个明月照进松林的夜。 </p><p>​                     —————甫子寸《东坡先生》</p><h3 id="《乡愁其四》"><a href="#《乡愁其四》" class="headerlink" title="《乡愁其四》"></a>《乡愁其四》</h3><p>我问我外公什么是乡愁，</p><p>外公没有说话，</p><p>他在眼中，</p><p>藏入一坛浊酒.</p><p>​                        —————甫子寸《乡愁其四》</p><h3 id="《沉沦》"><a href="#《沉沦》" class="headerlink" title="《沉沦》"></a>《沉沦》</h3><p>你是我今后岁月难舍难分，</p><p>也是我荒凉宇宙明月星辰。</p><p>我爱你冰冷美艳凶险万分，</p><p>也爱你一笑嫣然撩我心魂。</p><p>题得出最美的诗文，</p><p>写不来你清透眼神。</p><p>你微微蹙眉，</p><p>使万物皆醺，英雄饮恨。</p><p>我轻轻一笑，</p><p>道茶还未凉，尚留余温。</p><p>一抹红唇，乱了方寸。</p><p>眉间一吻，我愿沉沦。</p><p>​                        —————甫子寸《沉沦》</p><h3 id="《钓鱼人》"><a href="#《钓鱼人》" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>这一生只想纵横，</p><p>谁又管身后的风？</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《钓鱼人》-1"><a href="#《钓鱼人》-1" class="headerlink" title="《钓鱼人》"></a>《钓鱼人》</h3><p>你不懂我的梦，</p><p>便不知我热冷</p><p>​                        —————甫子寸《钓鱼人》节选</p><h3 id="《诗歌之路在何方》"><a href="#《诗歌之路在何方》" class="headerlink" title="《诗歌之路在何方》"></a>《诗歌之路在何方》</h3><p> 舀下一瓢星光，</p><p>浇灌我的豪肠.</p><p>​                        —————甫子寸《诗歌之路在何方》节选</p><h3 id="《说与浮云听》"><a href="#《说与浮云听》" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>在最失意时纵马，</p><p>在最得意处品茶.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《说与浮云听》-1"><a href="#《说与浮云听》-1" class="headerlink" title="《说与浮云听》"></a>《说与浮云听》</h3><p>一生很长，几度春夏?<br>纸张太短，无边风雅.</p><p>​                        —————甫子寸《说与浮云听》节选</p><h3 id="《随笔》"><a href="#《随笔》" class="headerlink" title="《随笔》"></a>《随笔》</h3><p>少年向来不识天高地厚，</p><p>放眼处皆自负才高八斗.</p><p>虽是自命风流，</p><p>倒也坦诚无忧.</p><p>我爱这样的少年，</p><p>谦和而狂妄，</p><p>骄傲又坦然.</p><p>​                        —————甫子寸《随笔》</p><h3 id="《月下随笔》"><a href="#《月下随笔》" class="headerlink" title="《月下随笔》"></a>《月下随笔》</h3><p>我是此间少年郎，</p><p>你是天上明月光</p><p>​                        —————甫子寸《月下随笔》节选</p><h3 id="《诗人》"><a href="#《诗人》" class="headerlink" title="《诗人》"></a>《诗人》</h3><p>我说诗人啊，</p><p>做自己的将军，</p><p>在自己的世界里统率三军.</p><p>​                        —————甫子寸《诗人》节选</p><h3 id="《诗心》"><a href="#《诗心》" class="headerlink" title="《诗心》"></a>《诗心》</h3><p>忙过了最近的忙，</p><p>醒来已是华灯初上，</p><p>太阳无缘见我，能作陪的只剩月光.</p><p>​                        —————甫子寸《诗心》节选</p><h3 id="《最绝伦的笔墨》"><a href="#《最绝伦的笔墨》" class="headerlink" title="《最绝伦的笔墨》"></a>《最绝伦的笔墨》</h3><p>你是我最绝伦的笔墨，</p><p>也是我诗里最美的传说.</p><p>​                        —————甫子寸《最绝伦的笔墨》节选</p><h3 id="《无题》"><a href="#《无题》" class="headerlink" title="《无题》"></a>《无题》</h3><p>龙有逆鳞不可触，</p><p>人无傲气不可交。</p><p>​                        —————甫子寸《无题》节选</p><h3 id="《劫》"><a href="#《劫》" class="headerlink" title="《劫》"></a>《劫》</h3><p>我于昨晚霸占了所有的月光，<br>等天亮却只想给一人写文章.</p><p>​                        —————甫子寸《劫》节选</p><h3 id="《只是想你》"><a href="#《只是想你》" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>这世间众生皆孤寂，<br>应怪众生未见过你。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《只是想你》-1"><a href="#《只是想你》-1" class="headerlink" title="《只是想你》"></a>《只是想你》</h3><p>我扛得住所有白天的泪，</p><p>却熬不住漫漫长夜的黑。</p><p>​                        —————甫子寸《只是想你》节选</p><h3 id="《不想》"><a href="#《不想》" class="headerlink" title="《不想》"></a>《不想》</h3><p>我其实一点也不想念，<br>和月色也能相谈甚欢</p><p>​                        —————甫子寸《不想》节选</p><h3 id="《陷半生》"><a href="#《陷半生》" class="headerlink" title="《陷半生》"></a>《陷半生》</h3><p>误把眉目作山河，</p><p>沦陷半生未肯脱。</p><p>​                        —————甫子寸《陷半生》节选</p><h3 id="《野望》"><a href="#《野望》" class="headerlink" title="《野望》"></a>《野望》</h3><p>野心总是在深夜开始酝酿，</p><p>等天亮又黯然收场.</p><p>​                        —————甫子寸《野望》节选</p><h3 id="《格局》"><a href="#《格局》" class="headerlink" title="《格局》"></a>《格局》</h3><p>书生口中三寸兵，</p><p>不斩小人斩不平.</p><p>​                        —————甫子寸《格局》节选</p><h3 id="《随笔·热爱》"><a href="#《随笔·热爱》" class="headerlink" title="《随笔·热爱》"></a>《随笔·热爱》</h3><p> 人生九分只顾开怀，<br>对世界宣泄年轻的爱。<br>留一分写诗感慨，<br>等老去为自己喝彩。<br>到那时你会不会期待，<br>我敛去一身桀骜，<br>淋着星光向你走来，<br>为你捧起世上最温柔的海。 </p><p>​                        —————甫子寸《随笔·热爱》节选</p><h3 id="《我想把余生都送你》"><a href="#《我想把余生都送你》" class="headerlink" title="《我想把余生都送你》"></a>《我想把余生都送你》</h3><p>总有那么一天啊，</p><p>我会向那个不屈的少年告别，</p><p>柴米油盐酱醋茶，</p><p>目睹青丝成白发，</p><p>我不再心怀天下，</p><p>却只想接你回家.</p><p>​                        —————甫子寸《我想把余生都送你》</p><h3 id="《此刻此间》"><a href="#《此刻此间》" class="headerlink" title="《此刻此间》"></a>《此刻此间》</h3><p>你如今回眸看我一眼，</p><p>满天风光尽收你眉间.</p><p>​                        —————甫子寸《此刻此间》节选</p><h3 id="《三寸情书》"><a href="#《三寸情书》" class="headerlink" title="《三寸情书》"></a>《三寸情书》</h3><p>我说，瀚海可尽，明月可鞠，</p><p>落不得太多字句，</p><p>只为你一生眉目清举。</p><p>​                        —————甫子寸《三寸情书》节选</p><h3 id="《青云》"><a href="#《青云》" class="headerlink" title="《青云》"></a>《青云》</h3><p>闻听书中游侠，并无轻剑快马，</p><p>只凭背井离乡，丈量山河天下。</p><p>​                        —————甫子寸《青云》节选</p>]]></content>
      
      
      <categories>
          
          <category> 诗集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 甫子寸诗集节选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象知识点大集合</title>
      <link href="posts/9443.html"/>
      <url>posts/9443.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="为什么要使用方法"><a href="#为什么要使用方法" class="headerlink" title="为什么要使用方法"></a>为什么要使用方法</h3><h4 id="生活中的方法（工具）"><a href="#生活中的方法（工具）" class="headerlink" title="生活中的方法（工具）"></a>生活中的方法（工具）</h4><p>螺丝刀，锤子，扳手</p><blockquote><p>1、提高复用度，可重复使用</p><p>2、提高效率</p></blockquote><p>开发中使用方法来实现同样的效果，<a href="">为了解决复用和效率的问题</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><a href="">实现特定功能的一段代码，可以被反复使用</a></p><h3 id="方法的构成"><a href="#方法的构成" class="headerlink" title="方法的构成"></a>方法的构成</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">固定格式：    public static返回值类型：    表示方法执行完成后返回的数据类型    如果没有返回值类型就用 void ，如果有就使用对应的返回值类型方法名：    小驼峰命名，见名知意，动宾结构形参列表：    用来接收用户传入的数据，可以是基本数据类型或者引用数据类型，需要声明局部变量。    如果不需要形参就写 ()，如果有多个就写多个方法体：    {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><blockquote><p>1、固定的格式（public static）不要问，因为不影响我们写代码，后期会讲！！！</p><p>2、方法要写上文档注释，为了更方便地阅读代码</p></blockquote><h3 id="方法声明格式"><a href="#方法声明格式" class="headerlink" title="方法声明格式"></a>方法声明格式</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static returnType methodName(dataType FormerParameter) {    method body;}public static 返回值类型 方法名(数据类型 形参名) {    方法体;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="声明位置"><a href="#声明位置" class="headerlink" title="声明位置"></a>声明位置</h3><p><a href="">定义在类中，与其他方法（main方法）并列</a></p><h3 id="无返回值方法调用"><a href="#无返回值方法调用" class="headerlink" title="无返回值方法调用"></a>无返回值方法调用</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">mothodName(actualParameter);方法名(实参);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：</p><blockquote><p>方法和变量最大的区别就是方法后面有小括号，即便没有参数也有小括号</p><p>小驼峰</p></blockquote><h4 id="3-6-1-无参无返回值调用"><a href="#3-6-1-无参无返回值调用" class="headerlink" title="3.6.1 无参无返回值调用"></a>3.6.1 无参无返回值调用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod1 {    public static void main(String[] args) {        printHelloWorld();    }    /**    * 打印Hello World    */    public static void printHelloWorld() {        System.out.println("Hello World");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、main方法是程序的入口，所有的代码和方法都需要在main方法中被完成和调用2、方法名的后面一定要跟 ()3、方法和其他方法的关系是并列关系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-6-2-有参无返回值调用"><a href="#3-6-2-有参无返回值调用" class="headerlink" title="3.6.2 有参无返回值调用"></a>3.6.2 有参无返回值调用</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.util.Scanner;class TestMethod3 {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        System.out.println("请输入一个数：");        int num = scanner.nextInt();        printIntNum(num);    }    /**    * 展示用户传入的int类型数据    *    * @param num 这里需要传入一个int类型的数据    */    public static void printIntNum(int num) {        System.out.println("您输入的数为：" + num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、如果方法声明时带有形式参数，那么方法调用时就必须携带实际参数2、如果方法声明时没有形式参数，方法调用时就不能有实参3、声明时有几个形式参数，调用时就传入几个实际参数，形参实参个数不一样编译会报错4、实参与形参的数据类型不一样，编译器会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><blockquote><p>形参：用来接收调用该方法时传递的参数。只有在被调用的时候才分配内存空间，一旦调用结束，就释放内存空间。因此仅仅在方法内有效。<br>实参：方法调用时用于传入的数据，用来给形参赋值，数据类型要求一致</p></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>方法中的返回值有两种情况，即有返回值和无返回值，如果定义方法时有返回值类型，就需要返回相对应的数据类型</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">基本数据类型    值传递，不改变自身引用数据类型    引用传递，改变自身void    无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、一个方法只能有一个返回值2、分支结构的每一个分支都需要正确的返回值3、返回值可以接收也可以不接收<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="return-关键字"><a href="#return-关键字" class="headerlink" title="return 关键字"></a>return 关键字</h4><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>结束当前方法，返回至调用方法处，如果定义了返回值类型就返回对应类型的数据</p><p>【注意】<a href="">数据类型一致化</a></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">return 需要返回的数据;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、单一职能原则，一个方法只做一件事2、注意形参和实参数据类型一致化3、返回值类型和参数没有关系4、方法名要符合小驼峰命名规则5、return的下一行代码不会执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有返回值方法调用"><a href="#有返回值方法调用" class="headerlink" title="有返回值方法调用"></a>有返回值方法调用</h3><h4 id="无参有返回值的方法：give-me-five"><a href="#无参有返回值的方法：give-me-five" class="headerlink" title="无参有返回值的方法：give me five"></a>无参有返回值的方法：give me five</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod1 {    public static void main(String[] args) {        System.out.println(giveMeFive());    }    /**    * 返回一个整数 5    *    * @return 5 int类型    */    public static int giveMeFive() {        return 5;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="有参有返回值的方法：两个数求和"><a href="#有参有返回值的方法：两个数求和" class="headerlink" title="有参有返回值的方法：两个数求和"></a>有参有返回值的方法：两个数求和</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemo6 {    public static void main(String[] args) {        /*         * 调用自定义getSumOfTwoNumber方法，需要两个int类型的参数，并得到一个int类型的返回值         *          * 参数列表一定要和方法声明上的参数类型完全一致         */         int total = getSumOfTwoNumber(1, 2);        System.out.println(total);    }    /**     * 两个整数进行求和     *      * @param num1 求和的第一个数     * @param num2 求和的第二个数     * @return 返回两个参数的和，int类型     */    public static int getSumOfTwoNumber(int num1, int num2){        return num1 + num2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】调用带有多参数的方法，要求传入的参数数据类型，个数和顺序还有数据类型必须和方法声明一致</p><h4 id="规范化return"><a href="#规范化return" class="headerlink" title="规范化return"></a>规范化return</h4><p>在一个方法中，return出现的次数要尽可能得少，为了提高阅读性和逻辑性</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class TestMethod4 {    public static void main(String[] args) {        System.out.println(getCompare(3,2));    }    /**    * 比较大小，返回较大的那个数    *    * @param num1 int类型    * @param num2 int类型    * @return int类型的结果    */    public static int getCompare(int num1, int num2) {        return num1 > num2 ? num1 : num2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、break 是退出当前循环结构，return 是退出当前方法2、如果返回值类型是 void ，可以返回 null 或者不返回或者 return;3、一个方法可以有多个 return，但只能有一个返回值4、返回值可以接收也可以不接收，由调用者决定如何调用5、分支结构里的每一个分支都需要有正确的返回值6、对返回值的处理方式因情况而定，可以打印、参与运算或者当做其他方法的实参7、调用带有多参数的方法，要求传入的参数数据类型，个数和顺序和类型必须和方法声明一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】方法具有单一职能原则，一个函数只做一件事</p><h3 id="方法重载【Overload】"><a href="#方法重载【Overload】" class="headerlink" title="方法重载【Overload】"></a>方法重载【Overload】</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>一个类或者接口中定义多个相同名称的方法</p><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、必须在同一个类中2、方法名必须一致3、参数必须不一致(个数，顺序，类型)    4、与访问修饰符、返回值类型无关<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemo9 {    public static void main(String[] args) {        // 调用同名方法，传入不同的参数列表，即可实现方法的重载        play();        play("英雄联盟");        play("红色警戒", 2);        play(1, "DNF");    }    public static void play() {        System.out.println("玩王者荣耀");    }    public static void play(String gameName) {        System.out.println("玩" + gameName);    }    public static void play(String gameName, int time) {        System.out.println("玩" + gameName + time + "小时");    }    public static void play(int time, String gameName) {        System.out.println("玩" + gameName + time + "小时");    }    /*      * Duplicate method play(String, int) in type MethodDemo9     *      * 跟返回值类型无关，只关注方法名和参数类型     *///    public static String play(String gameName, int time) {//        return "玩" + gameName + time + "小时";//    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>满足需求多样化，屏蔽使用差异，灵活、方便</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p>方法的重载我们只关注方法名和参数类型，要求方法名必须一致，参数列表必须不一致（个数，顺序，类型）</p></blockquote><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>在方法内部或者形参列表上定义的变量（包括mian方法）</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>从定义局部变量的那一行到所在的代码块结束</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int i = 1; i <= 10; i++) {}for (int i = 1; i <= 10; i++) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】两个for循环中，i 循环变量分别属于不同的大括号以内，不同的作用域空间，并不冲突</p><h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>从方法被调用的时刻算起到函数返回调用处的时刻结束</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">for (int i = 1; i <= 10; i++) {}System.out.println(i); // 报错，找不到符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】for 循环结束时局部变量 i 的生存期结束，在 for 循环外无法使用 i</p><h4 id="单一性，不能重名"><a href="#单一性，不能重名" class="headerlink" title="单一性，不能重名"></a>单一性，不能重名</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 报错！for (int i = 1; i <= 10; i++) {    for (int i = 1; i <= 10; i++) {    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】在一个方法内局部变量不能多次定义</p><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Test {    public static void main(String[] args) {        int num = 5;        test(num);        System.out.println(num);    // 5    }    public static void test(int num) {        num = 10;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】基本数据类型作为参数传递给局部变量时，传递的是值，局部变量的更改不影响实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">值传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\值传递.jpg" alt="值传递"></td></tr></tbody></table></div><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MethodDemoC {    public static void main(String[] args) {        int[] arr = new int[5];        System.out.println("调用方法前：" + arr[0]);        test(arr);        System.out.println("调用方法后：" + arr[0]);    }    public static void test(int[] arr) {        arr[0] = 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】引用数据类型传递时传递的是地址，局部变量直接作用于实参本身</p><div class="table-container"><table><thead><tr><th style="text-align:center">引用传递分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\引用传递.jpg" alt="引用传递"></td></tr></tbody></table></div><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">局部变量声明在函数中，从定义的那一行开始到函数结束时被销毁局部变量必须先赋值再使用局部变量不能重复定义值传递：基本数据类型的传递不改变实参引用传递：引用数据类型的传递会改变实参Java中只有值传递，引用传递传递的是地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="学习要求"><a href="#学习要求" class="headerlink" title="学习要求"></a>学习要求</h4><blockquote><p>1、听不懂没关系，不影响写代码，读着代码就会写了。</p><p>2、先会用，在用的过程中逐渐加深对面向对象的理解。</p><p>3、利用不断地练习，形成<code>肌肉记忆</code>(代码格式)和<code>意识记忆</code>(要啥给啥)。（<font color='red'>开发中重要的思想而不是语法</font>）</p></blockquote><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><blockquote><p>面向过程编程（POP —&gt; <strong>Process-Oriented Programming</strong>）代表：C语言</p><p>面向对象编程（OOP —&gt; <strong>Object-Oriented Programming</strong>）代表：C++、Java</p><p>面向切面编程（AOP —&gt; <strong>Aspect-Oriented Programming</strong>）代表：Java</p></blockquote><h4 id="面向对象的定义"><a href="#面向对象的定义" class="headerlink" title="面向对象的定义"></a>面向对象的定义</h4><p>面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p><p><a href="">找合适的人做合适的事</a></p><h4 id="生活中的面向对象和面向过程"><a href="#生活中的面向对象和面向过程" class="headerlink" title="生活中的面向对象和面向过程"></a>生活中的面向对象和面向过程</h4><p>举例：<strong>想吃烤羊排</strong></p><blockquote><p>面向对象：找个店铺吃</p><p>​    1、去羊排店</p><p>​    2、点一斤羊排</p><p>​    3、等25分钟</p><p>​    4、吃</p><p>​    5、付款走人</p><p>面向过程：自己做着吃</p><p>​    1、自己做羊排</p><p>​        1.准备材料（羊、辅料、调料）</p><p>​        2.备料</p><p>​        3.烤箱预热，开烤</p><p>​        4.15分钟翻面一次</p><p>​        5.取出</p><p>​    2、吃</p><p>​    3、洗锅刷碗，打扫卫生</p></blockquote><h4 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、面向对象是基于面向过程的编程思想2、万物皆对象3、对象具有唯一性4、任何对象都具有一定的特征和行为；特征是事物的基本描述，行为是事物的功能5、类是一组相关的属性和方法的集合，是一个抽象的概念6、对象是类的具体存在7、在一组相同或相似的对象中，抽取出共性的特征和行为，保留所关注的部分就是类的抽取8、类是模板、图纸，通过类创造的对象就是实体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面向对象的优点"><a href="#面向对象的优点" class="headerlink" title="面向对象的优点"></a>面向对象的优点</h4><ul><li>直观，高效，与人类的思维习惯一致</li><li>信息隐藏，提高了程序的可维护性和安全性</li><li>提高了程序的可重用性</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><blockquote><p>面向过程：亲力亲为，自力更生，所有过程都要经历（诸葛亮是怎么死的，累死的）</p><p>面向对象：找合适的人做合适的事，直观高效（烤羊排）</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="生活中的类和对象"><a href="#生活中的类和对象" class="headerlink" title="生活中的类和对象"></a>生活中的类和对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">对象</th></tr></thead><tbody><tr><td style="text-align:center">人类</td><td style="text-align:center">马云爸爸，麻花藤（<font color='red'>隔壁老王、女朋友</font>）</td></tr><tr><td style="text-align:center">狗类</td><td style="text-align:center">史努比，忠犬八公，高飞，斯派克，小白，王可可（<font color='red'>单身狗、旺财、金毛、哈士奇</font>）</td></tr><tr><td style="text-align:center">英雄类</td><td style="text-align:center">Faker的劫，The Shy的卢锡安，霸哥的石头人，马老师的螳螂（<font color='red'>盖伦、锤石、EZ</font>）</td></tr><tr><td style="text-align:center">化妆品类</td><td style="text-align:center">我的洗面奶（<font color='red'>阿玛尼405唇釉，chill小辣椒口红，黛珂水乳，雅诗兰黛粉底液，nars腮红</font>）</td></tr></tbody></table></div><p>这些对象有什么特点？</p><blockquote><p>人类：</p><ul><li>马云爸爸，麻花藤</li></ul><p>​    都是特立独行的个体，我们一提起这个个体脑海中就能浮现出他的形象，</p><ul><li>隔壁老王、女朋友</li></ul><p>​    这些都不是对象，因为每个人都会有自己的隔壁老王，都有自己的女朋友，你脑海中的隔壁老王和你同桌脑海中的隔壁老王是同一个人吗？除非你们是同一个邻居还姓王那就不说了。但你们的女朋友总不会也是同一个吧？所以说，女朋友，隔壁老王都不是对象，你的隔壁老王，你的女朋友才是个对象！！！</p><p>狗类：</p><ul><li>史努比，忠犬八公，高飞，斯派克，小白，王可可</li></ul><p>​    这些都是独一无二的</p><ul><li>单身狗、旺财、金毛、哈士奇</li></ul><p>​    这些全都是类</p></blockquote><h4 id="Java中的类和对象"><a href="#Java中的类和对象" class="headerlink" title="Java中的类和对象"></a><font color='red'>Java中的类和对象</font></h4><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>类是对某一类事物的描述，是抽象的、概念上的定义。<strong>类是模板，包含了一类事物所共有的特征(属性)和行为(方法)</strong></p><p>以人类为例：</p><blockquote><p>属性描述：学号、姓名、性别、年龄、身高、体重、地址、电话、微信、QQ…</p><p>行为描述：吃饭、睡觉、上班、学习、娱乐…</p></blockquote><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>对象是类的具体体现（<a href="">属性和方法</a>），是具体的、独一无二的个体。</strong></p><p>以班长为例：</p><blockquote><p>属性描述：班长的学号、班长的姓名、班长的身高…</p><p>行为描述：班长吃饭、班长睡觉、班长学习…</p></blockquote><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><p>类是对象的抽象，对象是类的具体实现</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><font color='red'>类的定义</font></h4><p>类是一种自定义的数据类型</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">格式：    class 类名 {        成员变量;// Field        成员方法;// Method    }class：    定义类的关键字类名：    大驼峰命名，首字母大写，见名知意    类名就是一种数据类型（自定义引用的数据类型），就是模板的名字成员变量（属性/特征描述）：    定义在类中，方法外的变量，用来描述类的特征成员方法（行为描述）：    定义在类中，用来描述类的功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Student {    // 成员变量【Field】    String name;    int age;    char sex;    // 成员方法【Method】    public void eat() {        System.out.println("吃");    }    public void sleep() {        System.out.println("睡");    }    public void play() {        System.out.println("玩");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类和对象-1"><a href="#类和对象-1" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><font color='red'>对象的创建</font></h4><p>参考Scanner的创建，依葫芦画瓢</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Scanner sc = new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 格式：    类名 对象名 = new 类名([参数...]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">Person person = new Person();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a><font color='red'>对象的使用</font></h4><p>参考数组和 Scanner 的使用，依葫芦画瓢</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int[] array = new int[10];array.length    // 注意：这里没有 ()，说明这不是方法，那它是什么？我们用它来表示数组的长度，数组的长度是数组的一个属性Scanner sc = new Scanner(System.in);sc.nextInt();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    使用成员变量：        对象名.成员变量    使用成员方法：        对象名.成员方法()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 通过Person类对象person操作name、sex、age属性// 进行赋值操作person.name = "张三";person.age = 25;person.sex = '男';// 通过person进行取值操作System.out.println(person.name);System.out.println(person.age);System.out.println(person.sex);person.eat();person.sleep();person.play();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>. 的含义是 “的”</p><p>person.name：person的name</p><p>person.age：person的年龄</p><p>person.sex：person的性别</p><p>扩展：</p><p>如果直接打印对象名，会得到一个对象的【地址】，这个地址包含两部分：1、完整的包名；2、当前对象存储在堆区内存中的空间首地址</p></blockquote><h4 id="对象内存分析图"><a href="#对象内存分析图" class="headerlink" title="对象内存分析图"></a>对象内存分析图</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\java面向对象01.png" alt=""></td></tr></tbody></table></div><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><blockquote><p>没听懂没关系，多敲代码，读着代码就懂了</p><p>生活中的类和对象</p><ul><li>类是事物的统称，是一个抽象的概念</li><li>对象是事物的表现，是具体的，独一无二的</li></ul><p>Java中的类和对象</p><ul><li>类是对象的抽象，具有公共的特征和行为，对象是类的具体实现，具有唯一的特征和行为</li></ul><p>基础数据类型与类和对象</p><ul><li>类就是一种自定义的数据类型，由类名，属性和方法构成</li><li>对象就是一种数据类型的数据，由对象名，属性和方法构成</li></ul><p>类和对象的定义和使用</p><ul><li>格式和规范，一定要按照标准</li></ul><p><strong>注意</strong></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">大写开头的都是类小写开头的都是变量带()的都是方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><blockquote><p>构造方法很重要，但是比较鸡肋</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>构造方法（<code>Constructor</code>）的名称和类名相同，没有返回值类型。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>类中的特殊方法，用于<font color='red'>创建对象</font>，在创建对象的时候会执行一些初始化操作，如给成员属性赋初值</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    类名([参数...]){}    Student(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><font color='red'>注意</font>：格式问题>1、构造方法的方法名与类名完全相同>>2、构造方法没有返回值类型>>3、创建对象时，触发构造方法的调用，不可手动调用>>4、如果没有声明构造方法，编译器默认生成无参构造方法>>5、如果定义了有参构造方法，编译器就不会创建无参构造方法>>【<font color='red'>强制要求</font>】>>```shell>无论什么时候，都要加上一个无参构造方法！！！>```#### 构造方法的使用```java// 自定义有参构造方法，并给name属性赋值Dog(String n) {    name = n;}// 自定义无参构造方法Dog(){}```### 构造方法的重载```javapublic Dog(String n){    name = n;}public Dog(String n, int i){    name = n;    age = i;}```#### 总结>1. 构造方法是用来创建对象，在创建对象的过程中会进行初始化操作（为对象赋值）>>2. 构造方法也是方法，除了没有返回值，其他的都跟方法一样>>按照方法参数列表的类型、个数、顺序去匹配，如果没有找到对应的就会报错>>3. 无论什么时候，都一定要给一个无参构造方法#### 扩展：反编译```shelljavap -c -l -private 类名.class```#### 扩展：对象的创建过程```shell1、类加载2、内存中开辟对象空间3、为各个属性赋予初始值4、执行构造方法中的代码5、将对象的地址赋值给变量```### this关键字#### 概述this代表所在类的对象引用，即当前对象>new 创建出来的对象>>调用方法的对象#### 作用1、<font color='red'>调用本类中的属性和方法（区别成员变量和局部变量）</font><p>2、调用本类中的其他构造方法：this()</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">格式：    this([参数...]);会根据参数列表调用对应的构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Rabbit(String color) {    // 调用本类中的属性    this.color = color;}public Rabbit(String color, int age, double weight) {    // 调用本类中的其他构造方法    this(color);    this.age = age;    this.weight = weight;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、this()只能在构造方法中使用2、this()只能在第一行3、构造方法中不能同时出现两个this()，因为24、不能自己调用自己，不能相互调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="规范化this"><a href="#规范化this" class="headerlink" title="规范化this()"></a>规范化this()</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Son {    String name;    int age;    float salary;    public Son() {    }    public Son(String name) {        // 调用Son(String name, int age, float salary)        this(name, 0, 0.0F);    }    public Son(String name, int age) {        // 调用Son(String name, int age, float salary)        this(name, age, 0.0F);    }    public Son(String name, int age, float salary) {        this.name = name;        this.age = age;        this.salary = salary;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>this表示的是当前对象</li><li>this可以调用本类中的属性和方法，最常用与区分成员变量和局部变量</li><li>this还可以调用本类中的构造方法，但是要注意有坑</li></ul></blockquote><h3 id="访问-权限-修饰符"><a href="#访问-权限-修饰符" class="headerlink" title="访问(权限)修饰符"></a>访问(权限)修饰符</h3><h4 id="private-私有-关键字"><a href="#private-私有-关键字" class="headerlink" title="private(私有)关键字"></a>private(私有)关键字</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、可以修饰成员变量和成员方法2、被private修饰的变量和方法仅本类中可用3、被private修饰的变量需要提供get、set方法供类外调用使用    4、boolean类型的 get 方法比较特殊：    public boolean isName(String name){        return name;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Dog {    private String name;    int age;    public String getName() {        return this.name;    }    public void setName(String name) {        this.name = name;    }    private void function() {        System.out.println("method be execute!");    }    public void executeFunction() {        this.function();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Java中的访问修饰符"><a href="#Java中的访问修饰符" class="headerlink" title="Java中的访问修饰符"></a>Java中的访问修饰符</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">类内部</th><th style="text-align:center">同包下</th><th style="text-align:center">子类中</th><th style="text-align:center">非同包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">默认不写</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></div><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、一般我们最常用的就是private和public，建议任何情况下都使用访问修饰符对变量和方法进行限制</p><p>2、public权限最高，整个项目中都可以访问（同一个项目），private权限最小，只能在本类中使用</p><p>3、被private修饰的变量和方法可以通过提供公共的方法对其进行访问</p></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><blockquote><p>封装</p><p>继承</p><p>多态</p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。核心是<font color='red'>归纳总结</font></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>提高代码的复用度、安全性，不必关心具体细节，便于开发</p><h4 id="JavaBean-规范化封装"><a href="#JavaBean-规范化封装" class="headerlink" title="JavaBean 规范化封装"></a>JavaBean 规范化封装</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1. 要求Java中的所有实体类成员变量全部私有化，最少提供一个无参数构造方法，对应成员变量实现setter和getter方法2. JavaBean规范，是为了后期开发汇总更好的代码适配度，提高代码运行的统一性，能够满足框架的使用3. JavaBean规范只是一个规范，而且是作为一个基础规范，操作都是可以使用快捷键来完成的！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    private char sex;    private boolean alive;    public Person() {}    public String getName() {        return this.name;    }    public int getAge() {        return this.age;    }    public char getSex() {        return this.sex;    }    public boolean isAlive() {        return alive;    }    public void setAlive(boolean alive) {        this.alive = alive;    }    public void setName(String name) {        this.name = name;    }    public void setAge(int age) {        this.age = age;    }    public void setSex(char sex) {        this.sex = sex;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>没有名字的对象，是对象的一种简化表示形式</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>一次性，每次使用都是一个新的对象</p><h4 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h4><blockquote><p>1、对象调用方法仅使用一次，然后等待销毁</p><p>2、作为实际参数传递</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestDog{    public static void main(String[] args) {        // 对象调用方法仅使用一次        new Dog().sleep();        // 作为实际参数传递        useDog(new Dog());    }    public static void useDog(Dog dog) {        dog.sleep();    }}class Dog {    String name;    int age;    public void sleep() {        System.out.println("小狗睡觉.....");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>提高开发效率，简化代码结构</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容。这个关系叫继承。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">关键字：extends格式:    class Son extends Father {    }一个孩子只能有一个父亲一个父亲可以有多个孩子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、Java为单继承，一个类只能有一个直接父类，但可以多级继承，属性和方法逐级叠加2、构造方法只可服务于本类，不可继承，子类执行构造方法前会默认调用父类的无参构造方法。可以通过super()去访问父类的构造方法3、private 修饰的属性和方法不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo {    public static void main(String[] args) {        // 创建一个父类对象        Father father = new Father();        // 父类调用父类的属性和方法        father.name = "父";        System.out.println(father.name);        father.game();        System.out.println("-------------");        // 创建一歌子类对象        Son son = new Son();        // 子类调用子类的属性和方法        son.age = 16;        System.out.println(son.age);        son.study();        // 子类调用父类的属性和方法(public修饰)        son.name = "子";        System.out.println(son.name);        son.game();        /*         * 子类调用父类private修饰的属性和方法         *          * 报错         * The field Father.suffer is not visible         * The method cook() from the type Father is not visible         *          * 由此可知子类不能调用父类私有化的属性和方法         *///        son.suffer = 10;//        son.cook();    }}public class Father {    public String name;    private int suffer;    public void game() {        System.out.println("下棋");    }    private void cook() {        System.out.println("做饭");    }}public class Son extends Father{    public int age;    public void study() {        System.out.println("子类 -- 学习");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="子类构造方法执行前默认先执行父类的无参构造方法"><a href="#子类构造方法执行前默认先执行父类的无参构造方法" class="headerlink" title="子类构造方法执行前默认先执行父类的无参构造方法"></a>子类构造方法执行前默认先执行父类的无参构造方法</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Father {    String name;    public Father() {        System.out.println("Father's Constrator be performed");    }}class Son extends Father {    int age;    public Son() {        System.out.println("Son's Constrator be performed");    }}public class TestSon {    public static void main(String[] args) {        Son son = new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Father's Constrator be performedSon's Constrator be performed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】Son 的构造方法中编译器默认生成 super(); 用来调用父类的构造方法，目的是为了初始化父类字段，因为子类可能会用到</p><div class="table-container"><table><thead><tr><th style="text-align:center">继承内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\继承内存分析图.jpg" alt="继承内存分析图"></td></tr></tbody></table></div><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、提高了代码的复用性2、提高了代码的维护性3、让类与类之间产生了一个关系，是多态的前提<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、让类的耦合性增强。这样某个类的改变，就会影响到其他和该类相关的类2、打破了封装性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Java中只有单继承</p><p>子类可以继承父类的非私有属性和方法（非private修饰的）</p><p>执行子类的构造方法前会默认执行父类的无参构造方法</p></blockquote><h3 id="方法重写【Override】"><a href="#方法重写【Override】" class="headerlink" title="方法重写【Override】"></a>方法重写【Override】</h3><h4 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h4><p>开发中父类的方法不一定适用于子类，因为父类方法不能更改，在子类中新增方法会造成代码的冗余，而且不符合逻辑</p><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、应用于继承和实现接口2、方法的返回值类型，方法名，形参列表与父类一致3、使用@Override注解来标识4、重写方法的访问修饰符权限不能低于父类    private < 默认(什么都不写) < protected < public<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Son extends Father{    public int age;    @Override    public void game() {        System.out.println("玩红色警戒");    }    public void study() {        System.out.println("子类 -- 学习");    }}public class Father {    public String name;    private int suffer;    public void game() {        System.out.println("下棋");    }    private void cook() {        System.out.println("做饭");    }}public class Demo1 {    public static void main(String[] args) {        Son son = new Son();        son.game();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>既沿袭了父类的方法名，又实现了子类的扩展</p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、方法的重写能够在不新增方法的情况下实现子类的扩展</p><p>2、方法重写要求方法声明格式和父类完全一致（访问修饰符不能小于父类）</p><p>3、@Overrid关键字用来开启格式检测，如果不一致就会报错</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><blockquote><p>super指父类对象，用来区分父类和子类，用于调用父类的属性和方法</p><p>用法和this非常类似：this指当前对象，super指父类对象</p></blockquote><h4 id="调用父类的属性和方法"><a href="#调用父类的属性和方法" class="headerlink" title="调用父类的属性和方法"></a>调用父类的属性和方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Father {    public int age = 60;    public void play() {        System.out.println("下象棋");    }}public class Son extends Father {    public int age = 16;    @Override    public void play() {        System.out.println("玩游戏");    }    public void showAge() {        int age = 20;        System.out.println("局部变量：" + age);        System.out.println("当前对象成员变量：" + this.age);        System.out.println("父类对象成员变量：" + super.age);    }    public void callPlay() {        // 调用当前对象的方法        this.play();        // 调用父类对象的方法        super.play();    }}public class Demo {    public static void main(String[] args) {        Son son = new Son();        son.showAge();        son.callPlay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="调用父类的构造方法"><a href="#调用父类的构造方法" class="headerlink" title="调用父类的构造方法"></a>调用父类的构造方法</h4><p>默认调用父类的无参构造，且必须在代码的第一行</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Father {    private String name;    public Father() {        System.out.println("Father's Constrator be performed");    }    public Father(String name) {        System.out.println("Father's Constrator be performed with name");    }}class Son extends Father {    private int age;    public Son() {        super();        System.out.println("Son's Constrator be performed");    }    public Son(String name, int age) {        super(name);        this.age = age;        System.out.println("Son's Constrator be performed with name and age");    }}public class TestSon {    public static void main(String[] args) {        Son son = new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、super指父类对象，对比this关键字，使用方法都一样</p><p>2、super() 和this() 代码不能共存(都必须在首行)，但是实际效果其实是可以的，如果不写 super() 也会自动调用</p><p>3、父类的属性要交给父类的构造方法去操作，没什么事就不要去使用 super() 来调用父类的构造方法了</p></blockquote><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>final表示最终的，用来修饰变量，方法和类</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、final 修饰的局部变量只能被赋值一次2、final 修饰的成员变量只能被赋值一次，并且必须在声明时就赋值3、final 修饰的基本类型变量是一个常量(只能被赋值一次)，引用类型变量不可修改地址，如对象4、final 修饰的方法不能被重写5、final 修饰的类不能被继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.fc.j._final;/* * final修饰的局部变量 */public class FinalDemo1 {    public static void main(String[] args) {        // 测试final修饰的修饰的变量        final int num;        num = 10;        System.out.println(num);        /*         * 被final修饰的变量只能赋值一次         *          * The final local variable num may already have been assigned         *          * 被final修饰的局部变量num可能已经被赋值         */        // num = 20;    }}// final修饰的类不能被继承，断子绝孙class Father {    /*     * final 修饰的成员变量必须在声明时就赋值     *      * The blank final field age may not have been initialized     * 空白的final成员变量可能未被初始化     */     // final int age;    final int age = 16;    public final void play() {        System.out.println("下棋");    }}class Son extends Father {    /*     *  Cannot override the final method from Father     *  无法重写被final修饰的方法     *///    @Override//    public final void play() {//        //    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>final修饰可以保证安全性，比如数组的长度属性，String类，这些都是final修饰的，保证不可变</p><h4 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、final表示最终的，可以修饰变量，属性和方法</p><p>2、final修饰的基本数据类型的成员变量只能被赋值一次</p><p>3、final修饰的引用数据类型的成员变量地址不可变，但不影响地址所指向的对象的操作</p><p>4、final修饰的方法不能被重写</p><p>5、final修饰的类不能被继承</p></blockquote><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>static 关键字方便在<strong>没有创建对象的情况下来进行调用方法和变量</strong>(优先级高于对象)，可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能</p><h4 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h4><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class PersonDemo {    public static void main(String[] args) {        Person person1 = new Person("张三", 16);        Person person2 = new Person("李四", 17);        Person person3 = new Person("王五", 18);        Person person4 = new Person("赵六", 19);        /*         * The static field Person.address should be accessed in a static way         * 静态成员变量应该通过静态的方式访问（注意这里是应该，不是必须）         *          * Change access to static using 'Person' (declaring type)         * 使用Person声明类型来更改对静态的访问         * 通过类名来操作成员变量：Person.address         */        System.out.println("姓名：" + person1.name + " 年龄：" + person1.age + " 地址：" + Person.address);        System.out.println("姓名：" + person2.name + " 年龄：" + person2.age + " 地址：" + Person.address);        System.out.println("姓名：" + person3.name + " 年龄：" + person3.age + " 地址：" + Person.address);        System.out.println("姓名：" + person4.name + " 年龄：" + person4.age + " 地址：" + Person.address);        // 通过类名直接调用static修饰的成员变量，此时是没有对象的        System.out.println("没有对象：" + Person.address);        /*         *  Cannot make a static reference to the non-static field Person.name         *           *  将name添加static后没有报错         *///        System.out.println("没有对象：" + Person.name);        /*         * 通过对象调用statice修饰的成员方法         *          * The static method test() from the type Person should be accessed in a static way         */        // person1.testStatic();        // 通过类名直接调用静态方法        Person.testStatic();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、通过类名调用静态成员变量，因为静态变量与对象无关2、静态变量被所有对象共享，一处更改处处更改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h4><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Person {    public String name = "张三";    public int age;    public static String address = "郑州";    public Person() {        super();    }    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    // 自定义static修饰的成员方法    public static void testStatic() {        /*         * 静态方法不能调用非静态方法         * Cannot make a static reference to the non-static method test() from the type Person         */        // test();        System.out.println("static mothed");        /*         * 不能再静态方法中使用this关键字         *          * Cannot use this in a static context         */        // this.name;    }    public void test() {        System.out.println("method");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、static修饰的方法不能访问本类中的非静态变量和方法，不能使用this2、通过类名来调用静态成员方法，工具类的应用很广泛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、static修饰的成员变量和方法都是对象所共享的资源，对其进行的操作回作用于所有对象。</p><p>2、static修饰的成员变量和方法依赖于类不依赖于对象，即没有对象</p><p>3、static修饰的成员变量和成员方法都可以通过类名调用，没有对象</p><p>4、静态不能调用费静态，不能使用this关键字，没有对象</p><p>5、静态变量常和final关键字搭配作为常量使用，静态方法常用于工具类</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">static成员变量内存分析图</th></tr></thead><tbody><tr><td style="text-align:center"><img src="http://qinjunxiang.gitee.io/Pictures\static成员变量内存分析图.jpg" alt="static成员变量内存分析图"></td></tr></tbody></table></div><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>在 Java 中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)</p><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、用于给对象初始化，多个构造方法中相同的代码存放到一起，每次调用构造方法都会执行，并且在构造方法前执行2、只有创建对象时调用，类不能调用3、构造代码块可以有多个，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    {        System.out.println("Person构造代码块执行");    }    public Person() {        System.out.println("Person构造方法执行");    }}public class TestPerson {    public static void main(String[] args) {        System.out.println("main方法");        new Person();        new Person();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    static {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、用于给类进行初始化，在加载的时候就执行，并且只执行一次2、优先级高于主函数3、静态代码块可以有多个，顺序执行，建议只写一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    static {        System.out.println("Person静态代码块执行");    }    public Person() {        System.out.println("Person构造方法执行");    }}public class TestPerson {    static {        System.out.println("静态代码块1执行");    }    public static void main(String[] args) {        System.out.println("main方法");        new Person();        new Person();    }    static {        System.out.println("静态代码块2执行");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">静态代码块1执行静态代码块2执行main方法Person静态代码块执行Person构造方法执行Person构造方法执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="代码块相关执行顺序"><a href="#代码块相关执行顺序" class="headerlink" title="代码块相关执行顺序"></a>代码块相关执行顺序</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Father {    public Father() {        System.out.println("父类构造方法执行~~~");    }    {        System.out.println("父类构造代码块执行~~~");    }    static {        System.out.println("父类静态代码块执行~~~");    }    public static void function() {        System.out.println("父类静态成员方法执行~~~");    }}public class Son extends Father{    public Son() {        System.out.println("子类构造方法执行~~~");    }    {        System.out.println("子类构造代码块执行~~~");    }    static {        System.out.println("子类静态代码块执行~~~");    }    public static void function() {        System.out.println("子类静态成员方法执行~~~");    }    public static void main(String[] args) {                System.out.println("main方法执行~~~");        new Son();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">父类静态代码块执行~~~子类静态代码块执行~~~main方法执行~~~父类构造代码块执行~~~父类构造方法执行~~~子类构造代码块执行~~~子类构造方法执行~~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>执行顺序</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    static Test test1 = new Test();    static Test test2 = new Test();    static {        System.out.println("静态代码块");    }    {        System.out.println("构造代码块");    }    public Test() {        System.out.println("构造方法");    }    public static void main(String[] args) {        System.out.println("main方法");        new Test();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">构造代码块构造方法构造代码块构造方法静态代码块main方法构造代码块构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、构造代码块用于给对象初始化，每次创建对象都会调用构造代码块，并且执行顺序在构造方法之前</p><p>2、静态代码块用于给类初始化，当类被加载的时候就会调用静态代码块（只执行一次），执行顺序在main方法之前</p></blockquote><h3 id="abstract关键字【抽象类】"><a href="#abstract关键字【抽象类】" class="headerlink" title="abstract关键字【抽象类】"></a>abstract关键字【抽象类】</h3><p>不能实例化的类就是抽象类，用 abstract 修饰</p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">abstract class 类名 {    成员变量    构造方法    成员方法        非抽象方法        抽象方法}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、抽象类和抽象方法必须用关键字 abstract 修饰2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类3、abstract 修饰的方法没有方法体，且子类必须重写4、抽象类不能实例化，因为 abstract 类中有 abstract 方法5、抽象类的子类        也可以是一个抽象类，可以重写也可以不重写父类的抽象方法。        可以是一个具体类。这个类必须重写抽象类中的所有抽象方法。(可以实例化)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestSon {    public static void main(String[] args) {        Son son = new Son();        son.play();    }}// 抽象类abstract class Father {    String name;    int age;    public Father() {    }    public void eat() {        System.out.println("吃饭");    }    // 抽象方法    abstract public void play();}class Son extends Father {    // 抽象方法的重写    @Override    public void play() {        System.out.println("玩游戏");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h4><p>接口是一系列方法的声明，是一些方法特征的集合，<strong>一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</strong>。</p><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><p>interface ：用来声明接口的关键字</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">声明格式：    interface 接口名 {        静态常量;        抽象方法;    }实现格式：    class 类名 implements 接口名 {    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、接口中的成员变量只能是静态常量，定义时必须初始化。默认修饰符：public static final2、接口中没有构造方法，因为接口不能实例化对象3、接口中的成员方法只能是抽象方法，没有方法体。默认修饰符：public abstract4、接口的实现类必须重写接口中方法，或者是一个抽象类(可以重写也可以不重写接口中的方法)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口的声明和实现"><a href="#接口的声明和实现" class="headerlink" title="接口的声明和实现"></a>接口的声明和实现</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface play{    // 常量，缺省修饰符：public static final    int time = 10;    // 抽象方法，缺省修饰符：public abstract    void geme();}public class TestInterface3 implements play{    // 重写接口中的方法    @Override    public void geme() {        System.out.println("玩游戏");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写接口中的方法</p><h4 id="抽象类实现接口"><a href="#抽象类实现接口" class="headerlink" title="抽象类实现接口"></a>抽象类实现接口</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface servlet {    void init();    void service();}abstract class BaseServlet implements servlet {    // 重写init()方法    @Override    public void init() {        System.out.println("初始化");    }}class MyServlet extends BaseServlet {    @Override    public void service() {        System.out.println("服务方法");    }}public class Test {    public static void main(String[] args) {        new MyServlet().init();        new MyServlet().service();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】抽象类实现接口，可以选择性重写也可以不重写接口中的方法</p><h4 id="类的接口多实现"><a href="#类的接口多实现" class="headerlink" title="类的接口多实现"></a>类的接口多实现</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Play {    void geme();}interface Eat {    void noodles();}public class TestInterface3 implements Play, Eat {    // 重写Play类中的方法    @Override    public void geme() {        System.out.println("玩游戏");    }    // 重写Eat类中的方法    @Override    public void noodles() {        System.out.println("吃面条");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口的实现类必须重写所有接口中的方法</p><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Eat {    void noodles();}interface Play {    void happy();}// 单继承interface Person extends Play {}// 多继承interface Animal extends Play, Eat {}// 实体类实现Animal接口，重写所有方法class Biology implements Animal {    @Override    public void happy() {        System.out.println("玩得开心");    }    @Override    public void noodles() {        System.out.println("面条好吃");    }}public class Test {    public static void main(String[] args) {        Biology biology = new Biology();        biology.happy();    // 玩得开心        biology.noodles();    // 面条好吃    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】接口之间可以单继承，也可以多继承</p><h3 id="jdk1-8新特性：default接口"><a href="#jdk1-8新特性：default接口" class="headerlink" title="jdk1.8新特性：default接口"></a>jdk1.8新特性：default接口</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Function {    void test();    default void testDefault() {        System.out.println("default修饰的接口可以有方法体");    }}// default 修饰的接口可以不被重写class Base implements Function {    @Override    public void test() {        System.out.println("Base类重写Function接口中的方法");    }}// default 修饰的接口也可以重写class Boost implements Function {    @Override    public void test() {        System.out.println("Boost类重写Function接口中的方法");    }    @Override    public void testDefault() {        System.out.println("Boost类重写Function接口中的default方法");    }}public class TestInterface2 {    public static void main(String[] args) {        Base base = new Base();        Boost boost = new Boost();        base.test();        // Base类重写Function接口中的方法        base.testDefault();    // default修饰的接口可以有方法体        boost.test();        // Boost类重写Function接口中的方法        boost.testDefault();// Boost类重写Function接口中的default方法    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】default修饰的接口可以不被重写</p><h4 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、接口是对类的扩展，通过接口可以让类拥有更多更强的功能2、接口中只有全局常量和抽象方法，所以不能实例化3、接口的实现类必须重写所有方法，或者是个抽象类4、接口可以多实现5、接口可以单继承，也可以多继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>二者具有直接或间接的继承关系时，父类引用指向子类对象，从而产生多种形态；接口的引用指向实现接口的类对象也是多态</strong></p><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p>多态场景下，父类引用调用方法，如果被子类重写过，优先执行子类重写过后的方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestCar {    public static void main(String[] args) {        // 父类引用指向子类对象        Vehicle vehicle = new Car();        // 优先执行子类重写过的方法        vehicle.run();    // Car run！！！    }}class Vehicle {    public void run() {        System.out.println("Vehicle run！！！");    }}class Car extends Vehicle {    @Override    public void run() {        System.out.println("Car run！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景一"><a href="#应用场景一" class="headerlink" title="应用场景一"></a>应用场景一</h4><p>使用父类作为方法形参实现多态，使方法参数的类型更为宽泛</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestCar {    public static void main(String[] args) {                Vehicle vehicle = new Car();        vehicle.type = "小汽车";        Bike bike = new Bike();        bike.type = "自行车";        Bus bus = new Bus();        bus.type = "公交车";        Employee employee = new Employee("你的迪丽热巴");        employee.goHome(vehicle);        employee.goHome(bus);    }}class Employee {    String name;    public Employee() {    }    public Employee(String name) {        this.name = name;    }    public void goHome(Vehicle vehicle) {        System.out.println(this.name + "乘坐" + vehicle.type + "交通工具回家");    }}class Vehicle {    String type;    public void run() {        System.out.println("Vehicle run！！！");    }}class Bus extends Vehicle {    @Override    public void run() {        System.out.println("Bus run！！！");    }}class Car extends Vehicle {    @Override    public void run() {        System.out.println("Car run！！！");    }}class Bike extends Vehicle {    @Override    public void run() {        System.out.println("Bike run！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">你的迪丽热巴乘坐小汽车回家Car run！！！你的迪丽热巴乘坐公交车回家Bus run！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="应用场景二"><a href="#应用场景二" class="headerlink" title="应用场景二"></a>应用场景二</h4><p>使用父类作为方法返回值实现多态，使方法可以返回不同子类对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Vehicle buyVehicle(int money) {        Vehicle vehicle = null;        if (money >= 100) {            Bus bus = new Bus();            bus.speed = 60;            bus.price = 1230000.0;            bus.seatNum = 16;            bus.type = "公交车";            vehicle = bus;        } else if (money >= 30) {            Car car = new Car();            car.price = 310000.0;            car.speed = 90;            car.type = "小汽车";            car.brand = "BMW";            vehicle = car;        } else if (money >= 1) {            Bike bike = new Bike();            bike.type = "捷安特自行车";            bike.speed = 40;            bike.price = 2000.0;            bike.color = "红色";            vehicle = bike;        }        return vehicle;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="向上装箱与向下拆箱"><a href="#向上装箱与向下拆箱" class="headerlink" title="向上装箱与向下拆箱"></a>向上装箱与向下拆箱</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Animal{}class Cat extends Animal{}class Dog extends Animal{}class Fish extends Animal {}public class Test {    public static void main(String[] args) {        showAnimal(new Animal());    // code.polymorphic.animal.Animal@7852e922        // 向上转型        showAnimal(new Cat());    // code.polymorphic.animal.Cat@4e25154f        // 向上转型        showAnimal(new Dog());    // code.polymorphic.animal.Dog@70dea4e        // 向上转型        showAnimal(new Fish());    // code.polymorphic.animal.Fish@5c647e05        System.out.println("----------------------");        Animal animal = getAnimal();        // 向下转型        Cat cat = (Cat) getCat();        // 向下转型        Dog dog = (Dog) getDog();        // 向下转型        Fish fish = (Fish) getFish();        System.out.println(animal);    // code.polymorphic.animal.Animal@33909752        System.out.println(cat);    // code.polymorphic.animal.Cat@55f96302        System.out.println(dog);    // code.polymorphic.animal.Dog@3d4eac69        System.out.println(fish);    // code.polymorphic.animal.Fish@42a57993    }    /**     * 展示动物     * @param animal     */    public static void showAnimal(Animal animal) {        System.out.println(animal);    }    /**     * 得到动物     * @return 返回一个Animal对象     */    public static Animal getAnimal() {        return new Animal();    }    /**     * 得到猫     * @return 返回一个Cat对象     */    public static Animal getCat() {        return new Cat();    }    /**     * 得到狗     * @return 返回一个Dog对象     */    public static Animal getDog() {        return new Dog();    }    /**     * 得到鱼     * @return 返回一个Fish对象     */    public static Animal getFish() {        return new Fish();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h4><p>用于判断当前对象是否是某个类，或者其子类、实现类的实例。如果是返回true，否则返回false。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 动物类 */class Animal {}/** * 老虎类 */class Tiger extends Animal {}/** * 熊猫类 */class Panda extends Animal {}/** * 猴子类 */class Monkey extends Animal {}public class AnimalDemo {    public static void main(String[] args) {        Animal ani = getAnimal();        if (ani instanceof Panda) {            // ani一定是panda对象或子类对象            Panda panda2 = (Panda) ani;            System.out.println("这是熊猫：" + panda2);            showPanda(panda2);        } else {            System.out.println("这是动物：" + ani);        }    }    // 获取动物，返回一个Panda对象    public static Animal getAnimal() {        return new Panda();    }    // 展示熊猫对象    public static void showPanda(Panda panda) {        System.out.println(panda);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】<strong>使用 instanceof 关键字做判断时， instanceof 操作符的左操作数必须和右操作数存在继承或实现关系</strong></p><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、父类引用指向子类对象，接口引用指向实现类对象</p><p>2、instanceof用以比较对象是否是类或父类的实例，接口的实现类</p></blockquote><h3 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h3><blockquote><p>API(Application Programming Interface) 应用程序编程接口</p></blockquote><p>编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑、向后跑、射门、抢球等各种命令，没有编过程序的人很难想象这样的程序如何编写。但是对于有经验的开发人员来说，知道机器人厂商一定会提供一些用于控制机器人的Java类，这些类中定义好了操作机器人各种动作的方法。其实，这些Java类就是机器人厂商提供给应用程序编程的接口，大家把这些类称为Xxx Robot API。本章涉及的Java API指的就是JDK中提供的各种功能的Java类。</p><h4 id="学习汉语和学习编程的异同点"><a href="#学习汉语和学习编程的异同点" class="headerlink" title="学习汉语和学习编程的异同点"></a>学习汉语和学习编程的异同点</h4><p>相同点</p><ul><li>基本语法</li><li>大量成语</li><li>写文章的手法和技巧</li></ul><p>不同点</p><ul><li>学习汉语 必须先学后用</li><li>学习编程 可以现用现学</li></ul><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><p>Object类是类层次结构的根类，所有类都直接或者间接的继承自该类</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Object()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】Object 只有一个无参构造方法</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>用来返回对象的字符串表示形式</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public String toString()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值为：包名.类名@当前对象在内存空间中的首地址</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">getClass().getName() + '@' + Integer.toHexString(hashCode())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写toString"><a href="#重写toString" class="headerlink" title="重写toString()"></a>重写toString()</h4><p>由于默认情况下的数据对我们来说没有意义，一般会重写该方法用以展示对象的字段信息</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 toString 方法    @Override    public String toString() {        return "Student [name=" + name + ", age=" + age + "]";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student = new Student("Buffer",23);                System.out.println(student);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">Student [name=Buffer, age=23]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h4><blockquote><p>toString方法用来展示一些对象的基本信息：完整的包名.类名@堆内存地址，通常我们用快捷键来重写这个方法来获取我们需要的数据信息</p></blockquote><h3 id="Object-类-1"><a href="#Object-类-1" class="headerlink" title="Object 类"></a>Object 类</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>用来比较两个对象的地址是否相同</p><pre><code>public boolean equals(Object obj) {        return (this == obj);}</code></pre><p>如果调用此方法的对象与 obj 的地址相同(即为同一个对象)，返回true，否则返回false</p><h4 id="重写equals-思路"><a href="#重写equals-思路" class="headerlink" title="重写equals()思路"></a>重写equals()思路</h4><p>一般需要重写 equals() 方法用以判断两个对象的字段是否相同</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、判断两个对象的地址是否相同2、判断两个对象的类型是否一致3、判断两个对象所存储的数据是否相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals()"></a>重写equals()</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 equals 方法    @Override    public boolean equals(Object obj) {        // 判断是否是同一个对象(地址相同)，如果是返回 true        if (this == obj) {            return true;        }        // 判断数据类型是否一致，如果不一致返回 false        if (!(obj instanceof Student)) {            return false;        }        // 强制类型转换为当前类对象        Student student = (Student) obj;        // 所有字段全部满足时返回 true ，否则返回false        return this.name.equals(student.name) && this.age == student.age;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student1 = new Student("Buffer",23);        Student student2 = new Student("Banlance",22);        Student student3 = new Student("Buffer",23);        System.out.println(student1.equals(student2));        System.out.println(student1.equals(student3));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">falsetrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【注意】基本数据类型不能使用 equals() 方法</p><h4 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、equals方法用来判断两个对象是否相同，默认比较的是两个对象的内存首地址。我们可以通过重写equals方法实现对两个对象的比较</p><p>2、注意equals方法的调用者，不同的调用者调用方法是不一样的</p></blockquote><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p>返回对象的哈希码值，<strong>具有唯一指向性</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public int hashCode()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重写hashCode"><a href="#重写hashCode" class="headerlink" title="重写hashCode()"></a>重写hashCode()</h4><p>hashCode方法要求必须和 equals() 方法的结果是对应的，如果两个对象的 equals 的结果为 true ，那这两个对象的 hashCode 的值一定相同，所以<strong>只要重写了 equals 方法，就必须重写 hashCode 方法</strong></p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    String name;    int age;    // 重写 equals 方法    @Override    public boolean equals(Object obj) {        if (this == obj) {            return true;        }        if (!(obj instanceof Student)) {            return false;        }        Student student = (Student) obj;        return this.name.equals(student.name) && this.age == student.age;    }    // 重写 hashCode 方法    @Override    public int hashCode() {        // 调用 Objects 工具类的 hash 方法，根据传入的参数生成一个指定的 hashCode 值        return Objects.hash(name, age);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestStudent {    public static void main(String[] args) {        Student student1 = new Student("Buffer",23);        Student student2 = new Student("Banlance",22);        Student student3 = new Student("Buffer",23);        System.out.println(student1.equals(student2));        System.out.println(student1.equals(student3));        System.out.println(student1.hashCode());        System.out.println(student2.hashCode());        System.out.println(student3.hashCode());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">falsetrue18926508722470635951892650872<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>student1 和 student3 的 equals 方法返回值是 true ，所以他们的 hashCode 值相同</p><h4 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1、hashCode()用来获取当前对象的哈希值，表示对象的唯一标识。如果重写equals()则必须重写hashCode()方法</p><p>2、equals相同hashCode一定相同，hashCode相同equals不一定相同</p></blockquote><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>获取当前对象的 Class 对象（字节码对象），直接打印会显示包含完整的包名,类名的信息</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public final native Class<?> getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Cat {}public class GetClassDemo {    public static void main(String[] args) {        Cat cat = new Cat();        System.out.println(cat.getClass());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">protected void finalize()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><h4 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Object类是所有类的基类，提供了一个无参的构造方法和一些公共方法</p><p>通过重写toString方法来获取对象中的数据</p><p>通过重写equals方法和hashCode方法来判断两个对象是否相同，这两个方法必须同时重写</p><p>getClass用来获取Class对象</p><p>finalize方法用于垃圾回收，不可控</p></blockquote><h3 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h3><p><code>System</code> 类包含一些有用的类字段和方法。它不能被实例化。 </p><p>在 <code>System</code>  类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 标准输入流，常用于键盘录入public final static InputStream in = null// 标准输出流，常用于打印信息public final static PrintStream out = null;// 标准错误输出流，常用于打印错误信息public final static PrintStream err = null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class SystemFieldDemo {    public static void main(String[] args) {        // 通过Scanner测试标准输入        Scanner sc = new Scanner(System.in);        String next = sc.next();        // 通过System.out.print测试标准输出流        System.out.println(next);        sc.close();        // 通过System.err.print测试标准输出流        System.err.println("打印错误报告");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法私有化，无法创建对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** Don't let anyone instantiate this class */private System() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h3><p>这个方法表示复制数组，从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static native void arraycopy(Object src,  int  srcPos,                                        Object dest, int destPos,                                        int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数解释</p><blockquote><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ArraycopyDemo {    public static void main(String[] args) {        // 创建一个长度为5的int类型数组arr        int[] arr = new int[5];        // 为数组arr赋值        for (int i = 0; i < arr.length; i++) {            arr[i] = i;        }        // 遍历数组arr        for (int i = 0; i < arr.length; i++) {            System.out.println(arr[i]);        }        System.out.println("------------------");        // 创建一个新的长度为5的int类型数组newArr        int[] newArr = new int[5];        // 调用System的arraycopy方法，分别传入对应的参数        System.arraycopy(arr, 0, newArr, 0, 5);        // 遍历newArr数组        for (int i = 0; i < newArr.length; i++) {            System.out.println(newArr[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><p>返回以毫秒为单位的当前时间。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static native long currentTimeMillis();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【注意】</p><blockquote><p>1、这个方法的返回值是long类型</p><p>2、当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class CurrentTimeMillsDemo {    public static void main(String[] args) {        long currentTimeMillis = System.currentTimeMillis();        System.out.println("毫秒：" + currentTimeMillis);        System.out.println("年：" + currentTimeMillis/1000/60/60/24/365);            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String date = sdf.format(currentTimeMillis);        System.out.println(date); // 2020-10-06 17:53:02    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gc"><a href="#gc" class="headerlink" title="gc()"></a>gc()</h3><p>运行垃圾回收器。在此之前会调用Object的finalize()</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void gc()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>System.gc()可用于垃圾回收。当使用System.gc()回收某个对象所占用的内存之前，通过要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，Java提高了默认机制来清理该对象的资源，就是调用Object类的finalize()方法。finalize()方法的作用是释放一个对象占用的内存空间时，会被JVM调用。而子类重写该方法，就可以清理对象占用的资源，该方法有没有链式调用，所以必须手动实现。</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Person {    private String name;    private int age;    // 构造方法，getter、setter方法、toString方法    /*     * 通过重写finalize方法验证调用gc会执行此方法     */    @Override    protected void finalize() throws Throwable {        System.out.println("执行finalize方法回收垃圾：" + this);        super.finalize();    }}public class GcDemo {    public static void main(String[] args) {        System.out.println(new Person("张三", 16));        System.gc();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从程序的运行结果可以发现，执行System.gc()前，系统会自动调用finalize()方法清除对象占有的资源，通过super.finalize()方式可以实现从下到上的finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。</p><p>但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的Java程序运行争抢资源，只有在执行大量的对象的释放，才调用垃圾回收最好</p></blockquote><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static void exit(int status)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ExitDemo {    public static void main(String[] args) {        System.out.println("程序执行开始");        // 执行此方法后关闭虚拟机，程序不会再向下执行        System.exit(0);        System.out.println("程序执行结束");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h4><blockquote><p>System类提供了一些和系统相关的类字段和方法，便于我们和底层进行交互。</p><p>比较常用的就是arraycopy()和currentTimeMills()，其他不需要关注</p></blockquote><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><p>一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 </p><h4 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public final class Scanner implements Iterator<String>, Closeable {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这里我们需要关注三个点：</p><p>1、final修饰，不能被继承</p><p>2、实现了 Iterator 接口(迭代器接口)，主要使用其中的 hasNext 方法和 next 方法</p><p>3、实现了 Closeable 接口，主要使用其中的 close 方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 用来判断是否还有下一个元素录入public boolean hasNext()// 用来接收录入的数据public String next()// 用来关闭资源(输入流)public void close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><p>从指定的扫描输入流构造一个 Scanner</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public Scanner(InputStream source)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        // java.util.Scanner.Scanner(InputStream source)        // 使用构造方法，传入一个标准输入流，创建一个Scanner对象        Scanner sc = new Scanner(System.in);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 此方法用于接收从键盘录入的字符串public String next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        // 从键盘录入一个字符串        String str = sc.next();        System.out.println(str);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nextInt"><a href="#nextInt" class="headerlink" title="nextInt()"></a>nextInt()</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 此方法用于从键盘获取一个int类型的数据public int nextInt()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        // 从键盘录入一个字符串        int num = sc.nextInt();        System.out.println(num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法的重载：nextInt-int-radix"><a href="#方法的重载：nextInt-int-radix" class="headerlink" title="方法的重载：nextInt(int radix)"></a>方法的重载：nextInt(int radix)</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 指定进制数从键盘录入一个int类型的数据public int nextInt(int radix)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>int radix参数表示一个进制数，如果从键盘录入的数据超过了指定的进制数就会报错，默认是10</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        /*         * 8表示接收8进制内的数，及0~7         *          * 从键盘录入的数据中不能出现8及其以上的数字，如果有会报错：         * InputMismatchException 输入类型不匹配异常         */        int num = sc.nextInt(8);        System.out.println(num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="相关方法：用法类似，要求触类旁通"><a href="#相关方法：用法类似，要求触类旁通" class="headerlink" title="相关方法：用法类似，要求触类旁通"></a>相关方法：用法类似，要求触类旁通</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public String nextLine()public byte nextByte()public byte nextByte(int radix)public short nextShort()public long nextLong()public float nextFloat()public double nextDouble()public BigInteger nextBigInteger()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hasNextInt"><a href="#hasNextInt" class="headerlink" title="hasNextInt()"></a>hasNextInt()</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。public boolean hasNext()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>此方法可用于合法性判断</p></blockquote><p>案例</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        if (sc.hasNextInt()) {            System.out.println(sc.nextInt());        } else {            System.out.println("输入的数据类型有误");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他相关方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public boolean hasNext()public boolean hasNextLine()public boolean hasNextBoolean()public boolean hasNextByte()public boolean hasNextShort()public boolean hasNextLong()public boolean hasNextFloat()public boolean hasNextDouble()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩展：回车换行问题"><a href="#扩展：回车换行问题" class="headerlink" title="扩展：回车换行问题"></a>扩展：回车换行问题</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo3 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int num = sc.nextInt();        String str = sc.nextLine();        System.out.println("str:" + str + "，num:" + num);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当从键盘录入第一个数字后，敲下的回车键实际是两个字符：\r\n，所以键盘实际是录入了这两个字符并且结束，显示的效果和没有录入字符串相同</p><p>补充：</p><p>\r：回车，回到行首</p><p>\n：换行</p><p>电脑上的回车键(Enter键)实际上是回车式换行，会先执行回车，后执行换行</p></blockquote><p>扩展：多行录入</p><p>可以通过hasNext的重载方法来实现多行录入</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 如果从键盘录入指定的pattern标记，则返回true，否则返回falsepublic boolean hasNext(String pattern)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>案例</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        StringBuffer sb = new StringBuffer();        // 将#作为结束的标记，当遇到#时结束循环        while (!sc.hasNext("#")) {            sb.append(sc.next());        }        System.out.println(sb);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Scanner 通过标准输入流来从键盘输入，后期不会用到，目前常用的方法为nextXxx()和hasNextXxx()</p></blockquote><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><blockquote><p>静态常量，全大写，通过类名调用</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 比任何其他值都更接近 e（即自然对数的底数）的 double 值public static final double E = 2.7182818284590452354;// 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值public static final double PI = 3.14159265358979323846;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><p>构造方法私有化，不能创建对象</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">private Math() {}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><blockquote><p>所有方法全部都被 static 修饰，可以通过类名直接调用</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取绝对值public static int abs(int a)// 对数据进行向上取整public static double ceil(double a)// 对数据进行向下取整public static double floor(double a)// 获取最大值public static int max(int a,int b) // 获取最小值public static int min(int a, int b)// 获取a的b次幂public static double pow(double a,double b)// 随机数，范围：[0.0, 1.0)，注意左闭右开，包含左边不包含右边，public static double random()// 四舍五入public static int round(float a)// 获取正平方根public static double sqrt(double a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package com.fc.r.math;public class MathDemo1 {    public static void main(String[] args) {        // 自然对数的底        System.out.println("Math.E:" + Math.E);        // π        System.out.println("Math.PI:" + Math.PI);        System.out.println("-----------------");        // 绝对值        System.out.println("abs:" + Math.abs(-1));        System.out.println("abs:" + Math.abs(1));        System.out.println("-----------------");        // 向上取整        System.out.println("ceil:" + Math.ceil(12.34));        System.out.println("ceil:" + Math.ceil(12.56));        System.out.println("-----------------");        // 向下取整        System.out.println("floor:" + Math.floor(12.34));        System.out.println("floor:" + Math.floor(12.56));        System.out.println("-----------------");        // 最大最小值        System.out.println("max:" + Math.max(12.34, 56.78));        System.out.println("max:" + Math.max(12.34, Math.max(56.78, 100)));        System.out.println("min:" + Math.min(12.34, 56.78));        System.out.println("-----------------");        // a的b次方        System.out.println("pow:" + Math.pow(2, 10));        System.out.println("-----------------");        // 随机数1~10        System.out.println("random:" + (int) (Math.random() * 10 + 1));        System.out.println("-----------------");        // 四舍五入        System.out.println("round:" + Math.round(12.34));        System.out.println("round:" + Math.round(12.56));        System.out.println("-----------------");        // 获取正平方根        System.out.println("sqrt:" + Math.sqrt(16));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>Java泛型是JavaSE1.5中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type parameter）这种参数类型在定义的时候是宽泛的，而在使用的时候是确定的。可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><h4 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、提高了程序的安全性(类型安全)2、提高了程序的可扩展性、可重用性3、将运行期遇到的问题转移到了编译期4、省去了类型强转的麻烦(Object类对象)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型格式"><a href="#泛型格式" class="headerlink" title="泛型格式"></a>泛型格式</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">泛型标识符：<自定义无意义英文大写单字母占位符>    常用格式：                <T> Type         <E> Element        <K> Key        <V> Value泛型类：把泛型定义在类上    格式:class 类名<泛型类型1,…>        【注意】泛型类型必须是引用类型泛型方法：把泛型定义在方法上    格式:public <泛型类型> 返回类型 方法名(泛型类型 .)泛型接口：把泛型定义在接口上    格式:public  interface 接口名<泛型类型1…><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>案例代码1</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityMethodDemo {    public static void main(String[] args) {        System.out.println(getData(100));        System.out.println(getData("Java"));        System.out.println(getData('A'));        System.out.println(getData(false));    }    /**     * 泛型方法     * 格式：     *         泛型限定符 返回值类型 方法名(泛型类型 参数名) {}     *      * @param <T> 泛型限定符     * @param t 任意类型的参数     * @return 返回任意类型参数     */    public static <T> T getData(T t) {        return t;    } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityMethodDemo2 {    public static void main(String[] args) {        Integer[] intArr = {1, 2, 3};        String[] stringArr = {"4", "5", "6"};        // 自定义学生类，其中包含name和age两个成员变量        Student[] students = {new Student("张三", 1), new Student("李四", 2), new Student("王五", 3)};        printArray(intArr);        printArray(stringArr);        printArray(students);    }    /**     * 遍历任意类型的数组     *      * @param <T> 泛型限定符     * @param t 任意类型的数组     */    public static <T> void printArray(T[] t) {        for (int i = 0; i < t.length; i++) {            System.out.println(t[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、要求形式参数列表中必须有一个参数是当前自定义泛型，因为需要通过参数来约束当前方法运行过程中泛型对应的具体数据类型是哪一个2、返回值类型可以使用自定义泛型，而且是被形式参数列表中传入的泛型对应具体的数据类型控制3、方法体内也可以使用自定义泛型，同时也是被参数当中泛型对应具体数据类型约束监控<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class GenericityClassDemo {    public static void main(String[] args) {        Number<Integer> num1 = new Number<Integer>(100);        Number<String> num2 = new Number<String>("100");        System.out.println(num1.getT());        System.out.println(num2.getT());    }}/** * 泛型类，把泛型定义到类上，整个类内都可以使用。是对泛型方法的封装 * @param <T> 泛型标识符 */class Number<T> {    private T t;    // Constrator、setters、getters}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、类内可以直接使用对应的类名声明泛型2、类内使用的泛型具体数据类型是在创建当前类对象时约束3、在创建当前类对象时没有约束泛型对应的具体数据类型，那么所有使用到泛型的位置都是Object类型，有悖于泛型使用原则4、如果类声明过了泛型，那么类中所有使用此泛型的方法都同时被声明，即无法使用其他类型5、泛型类中定义的静态方法不能直接使用类声明的泛型，因为泛型需要在创建对象时声明，而静态方法在类加载时就加载完成，此时泛型还没有声明。如果静态方法想要使用泛型，只能自己声明自己使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>案例代码1</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface USB {}class Mouse implements USB {}class Keyboard implements USB {}interface PC<T> {    // 接口中的常量不能使用泛型    T use(T t);}/* *  实现类实现接口时不指定泛型类型, *  需要在创建对象时明确 */class MyPC<T> implements PC<T> {    @Override    public T use(T t) {        return t;    }}/* * 实现类实现接口时，接口中泛型的类型已经明确， * 实现的方法也是明确的 */class YourPC implements PC<Mouse> {    @Override    public Mouse use(Mouse t) {        return t;    }}public class GenericityInterfaceDemo {    public static void main(String[] args) {        // 创建对象时明确泛型的类型        MyPC<Keyboard> myPC = new MyPC<Keyboard>();        Keyboard keyboard = myPC.use(new Keyboard());        System.out.println(keyboard);        System.out.println("-----------------");        // 声明类时已经明确泛型的类型，所以这里的类型已经是明确的        YourPC yourPC = new YourPC();        Mouse mouse = yourPC.use(new Mouse());        System.out.println(mouse);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 自定义一个比较器接口 * @param <T> 泛型 */interface Comparable<T> {    /**     * 这是一个比较方法，实现类应该实现这个方法以达到比较的目的     *      * @param t 传入被比较的对象     * @return 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。     */    public abstract int compareTo(T t);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 自定义父类，实现比较器接口 */class Father implements Comparable<Father>{    private String name;    private int age;    // Constrator、setters、getters    @Override    public int compareTo(Father f) {        return this.age - f.age;    }}public class GenericityInterfaceDemo {    public static void main(String[] args) {        Father father1 = new Father("小明父亲", 30);        Father father2 = new Father("小红父亲", 29);        if (father1.compareTo(father2) < 0) {            System.out.println("小红父亲年长：" + father2.getAge());        } else {            System.out.println("小明父亲年长：" + father1.getAge());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、接口中的成员变量不能使用泛型，因为static、final2、泛型接口的实现类可以指定泛型的类型，也可以不指定，如果在实现类中明确了数据类型，创建对象时就不需要再进行明确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><blockquote><p>在泛型中，？ 表示未知类型，被称为通配符。通配符可以在各种情况下使用：可以作为形式参数、成员变量、局部变量的类型，也可以作为返回值类型。但是，通配符不能用于泛型方法调用、泛型类实例创建对象或者父类的类型实际参数</p></blockquote><p>表示全部类型，类似Object。区别于T，T只是占位符，而 ？是数据类型</p><pre class="line-numbers language-lang-java"><code class="language-lang-java"><?><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【使用场景】</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、当一个方法可以用Object类提供的功能来实现时，泛型通配符是使用的2、若代码使用了泛型类中的方法，而这些方法又是不依赖于参数化类型的，可以使用泛型通配符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Grade<T> {    private T t;    // Constructor、setter and getter、toString    public void show() {        System.out.println("show" + this);    }}class School {    // 这里使用泛型通配符，表示可以传入任意类型    public void showGrade(Grade<?> grade) {        grade.show();    }}public class GenericityWildCardDemo {    public static void main(String[] args) {        School school = new School();        school.showGrade(new Grade<Student>(new Student()));        school.showGrade(new Grade<Teacher>(new Teacher()));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型上限"><a href="#泛型上限" class="headerlink" title="泛型上限"></a>泛型上限</h4><p>表示以T为父类的所有子类（包括父类）</p><p><code>&lt;? extends T&gt;</code></p><h4 id="泛型下限"><a href="#泛型下限" class="headerlink" title="泛型下限"></a>泛型下限</h4><p>表示以E为子类的所有父类（包括子类）</p><p><code>&lt;? super E&gt;</code></p><pre><code>class School {    public void showGrade(Grade&lt;?&gt; grade) {        grade.show();    }    // 泛型上限，Person类本身及其子类都可以使用    public void showExtends(Grade&lt;? extends Person&gt; grade) {        System.out.println(grade);    }    // 泛型下限，Person类本身及其父类都可以使用    public void showSuper(Grade&lt;? super Person&gt; grade) {        System.out.println(grade);    }}public class GenericityWildCardDemo {    public static void main(String[] args) {        School school = new School();        school.showGrade(new Grade&lt;Student&gt;(new Student()));        school.showGrade(new Grade&lt;Teacher&gt;(new Teacher()));        // 泛型上限，可以声明子类的类型        school.showExtends(new Grade&lt;Student&gt;());        // 泛型下限，可以声明父类的类型        school.showSuper(new Grade&lt;Object&gt;());    }}</code></pre><h3 id="泛型推断"><a href="#泛型推断" class="headerlink" title="泛型推断"></a>泛型推断</h3><blockquote><p>JDK1.7新特性，可以省略实例化对象时尖括号内的类型</p></blockquote><p>案例代码</p><pre><code>public class GenericityInferDemo {    public static void main(String[] args) {        // 泛型推断        Grade&lt;Student&gt; grade = new Grade&lt;&gt;();        // 得到对应的类型        Student student = grade.getT();    }}</code></pre><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1、泛型就是泛化的类型，本质是参数化类型，是jdk1.5引入的新特性，用在类、接口和方法上，即泛型类，泛型接口和泛型方法</p><p>2、为了解决利用继承Object来实现通用性导致的强制类型转换和可能发生的类型转换异常的问题。</p><p>3、泛型的好处是确保了编译时期的类型安全，和避免了强制类型转换的麻烦</p><p>4、缺陷是因为泛型使用了类型擦除机制，jvm运行之前会将泛型信息擦除掉，这样做是为了兼容jdk1.5之前的代码，但是也会导致通过反射可以跳过泛型的问题，因为运行期间并没有泛型的限制</p><p>5、泛型通配符？代表任意类型，泛型上限&lt;? extends T&gt;，泛型下限&lt;? super T&gt;</p><p>6、jdk1.7新特性泛型推断，声明变量时定义过泛型得话，在实例化对象时可以省略类型，但是还要加&lt;&gt;，否则还是原类型</p></blockquote><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="学习要求-1"><a href="#学习要求-1" class="headerlink" title="学习要求"></a>学习要求</h3><blockquote><p>抄！！！！！！！！！！！！！！！</p></blockquote><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Collection<E> Java中所有集合的总接口--| interface List<E> List接口，数据存储可重复，有序----| class ArrayList<E>     重点 可变长数组----| class LinkedList<E>     重点 双向链表模式----| class Vector<E>    线程安全的可变长数组--| interface Set<E> Set接口，数据存储不可以重复，无序----| class HashSet<E>     底层存储数据的结构是一个哈希表，存储效率，查询效率极高！！！----| class TreeSet<E>     底层存储数据的结构是一个平衡二叉树结构，要求数据必须有比较方式！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201116155514.jpg" alt="集合框架关系图"></p><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><blockquote><p>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些  collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何<em>直接</em>  实现：它提供更具体的子接口（如 <code>Set</code> 和 <code>List</code>）实现。此接口通常用来传递  collection，并在需要最大普遍性的地方操作这些 collection。 </p></blockquote><h3 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean add(E e);    添加当前集合约束的指定数据类型到当前集合中boolean addAll(Collection<? extends E> c);    添加另一个集合到当前集合中，要求添加集合中保存的元素必须是当前集合中保存    元素本身或者其子类对象 【泛型的上限】    class Dog extends Animal    class Cat extends Animal    class Tiger extends Animal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        System.out.println(collection1);    // [Java, Hello]        collection1.addAll(collection2);                System.out.println(collection1);    // [Java, Hello, Java, Hello, World]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean remove(Object obj);    删除集合中的指定元素，删除成功返回true,未找到指定元素，无法删除返回    false，并且在多个元素的情况下，删除找到的第一个元素。boolean removeAll(Collection<?> c);    在当前集合中删除两个集合的交集boolean retainAll(Collection<?> c);    在当前集合中保留两个集合的交集void clear();    清空整个集合中的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestRemove {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        collection1.remove("Hello");        System.out.println(collection1);    // [Java]        collection2.removeAll(collection1);        System.out.println(collection2);    // [Hello, World]        collection1.add("Hello");        collection1.containsAll(collection2);        System.out.println(collection1);    // [Java, Hello]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    有效元素个数boolean isEmpty();    判断当前集合是否为空，是否存在有效元素boolean contains(Object obj);    判断指定元素是否在当前集合中存在boolean containsAll(Collection<?> c);    判断传入的参数集合是不是当前集合的子集合Object[] toArray();    返回集合中所有保存元素的Object类型数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestGet {    public static void main(String[] args) {        Collection<String> collection1 = new ArrayList<String>();        Collection<String> collection2 = new ArrayList<String>();        collection1.add("Java");        collection1.add("Hello");        collection2.add("Java");        collection2.add("Hello");        collection2.add("World");        System.out.println(collection1.size());    // 2        System.out.println(collection1.isEmpty());    // fasle        System.out.println(collection1.contains("Java"));    //true        System.out.println(collection2.containsAll(collection1));    // true        Object[] array = collection1.toArray();        for (int i = 0; i < array.length; i++) {            System.out.println(array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>是用来获取集合中元素的另一种方式（遍历），依赖于集合存在</p><h4 id="获取迭代器的方法"><a href="#获取迭代器的方法" class="headerlink" title="获取迭代器的方法"></a>获取迭代器的方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">Iterator<E> iterator();    获取迭代器对象，泛型对应的具体数据类型和集合中约束的泛型具体数据类型一致。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean hasNext();    判断当前集合中是否可以继续得到元素，(是否可以继续遍历)E next();    1. 获取迭代器当前指向的元素    2. 将迭代器指向下一个元素void remove();    删除通过next方法获取到元素        【注意】        1、remove方法只能删除next方法获取到元素        2、remove方法只能在next方法之后执行，且不能跨过一个next执行        3、没有next不能使用remove<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Collection<String> c = new ArrayList<String>();        c.add("雪花纯生");        c.add("修道院啤酒");        c.add("1664");        c.add("泰山精酿");        c.add("时光精酿");        /*         * 根据当前集合，获取对应的迭代器对象         *          * 得到的迭代器对象会依据，当前集合中的所有元素进行一个规划操作。         * 迭代器对于整个集合中的元素都是存在预期。         */        Iterator<String> iterator = c.iterator();        /*         * 迭代器遍历，利用迭代器的特征进行遍历操作         */        while (iterator.hasNext()) {            // 获取每一个迭代器指向元素，并且展示            String string = iterator.next();            System.out.println(string);            /*             * 通过集合对象本身删除1664，对于迭代器而言，一脸懵逼，原本的规划             * 没有了！！！并且集合没有告知迭代器数据发生了改变，迭代器继续按照             * 原本的规划路径操作，保存！！！             *              * 对于集合在内存中占用的空间而言             *     1. 集合对应的引用数据类型变量可以操作对应空间             *     2. 迭代器可以操作对应的空间             *              * 对于集合和迭代器而言，【集合在内存中占用的空间】共享资源，在操作             * 共享资源过程中，我们要多多考虑共享资源的冲突问题。             * 后面课程中会讲到【多线程】             */            c.remove("1664");        }        /*         Exception in thread "main" java.util.ConcurrentModificationException                at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)                at java.util.ArrayList$Itr.next(ArrayList.java:859)                at com.qfedu.b_iterator.Demo3.main(Demo3.java:30)         */    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>有序的 Collection ，可以根据索引操作元素，数据可重复</p><blockquote><p>ArrayList</p><p>​    可变长数组</p><p>LinkedList</p><p>​    双向链表</p><p>Vector</p><p>​    线程安全的可变长数组</p></blockquote><h3 id="增加方法-1"><a href="#增加方法-1" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean add(E e);        List接口继承Collection接口 add方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】boolean add(int index, E e);    List接口【特有方法】，在指定位置，添加指定元素boolean addAll(Collection<? extends E> c);    List接口继承Collection接口 addAll方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】boolean addAll(int index, Collection<? extends E> c);    List接口【特有方法】，在指定下标位置，添加另一个集合中所有内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        List<String> arrayList = new ArrayList<String>();        arrayList.add("Hello");        arrayList.add("World");        arrayList.add("Android");        arrayList.add(0, "Java");        System.out.println(arrayList);        List<String> al = new ArrayList<String>();        al.add("ArrayList是线程不安全的可变长数组");        al.add("LinkedList是双向链表：增删快，查询慢");        al.addAll(arrayList);        System.out.println(al);        arrayList.addAll(0, al);        System.out.println(arrayList);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">E remove(int index);    List接口【特有方法】，获取指定下标位置的元素并删除boolean remove(Object obj);    List接口继承Collection接口方法。删除集合中的指定元素boolean removeAll(Collection<?> c);    List接口继承Collection接口方法。删除当前集合中和参数集合重复元素boolean retainAll(Collection<?> c);    List接口继承Collection接口方法。保留当前集合中和参数集合重复元素clear();    List接口继承Collection接口方法。清空整个集合中的所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestRemove {    public static void main(String[] args) {        List<Integer> al = new ArrayList<Integer>();        al.add(1);        al.add(2);        al.add(3);        al.add(4);        System.out.println("删除指定下标位置为0的元素： " + al.remove(0));        System.out.println("al : " + al);        List<Integer> al1 = new ArrayList<Integer>();        al1.add(4);        al1.add(5);        al1.add(6);        System.out.println("al.removeAll(al1) : " + al.removeAll(al1));        System.out.println("al : " + al);        List<Integer> al2 = new ArrayList<Integer>();        al2.add(5);        al2.add(7);        al2.add(6);        System.out.println("al1.reatinAll(al2) : " + al1.retainAll(al2));        System.out.println("al1 ： " + al1);        al2.clear();        System.out.println("al2.clear() ： " + al2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">E set(int index, E e);    List接口【特有方法】，使用指定元素替代指定下标的元素，返回值是被替换的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestModify {    public static void main(String[] args) {        List<Character> al = new ArrayList<Character>();        al.add('A');        al.add('B');        al.add('C');        al.set(0, 'M');        System.out.println(al); // [M, B, C]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询方法-1"><a href="#查询方法-1" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    List接口继承Collection接口方法。获取集合中有效元素个数boolean isEmpty();    List接口继承Collection接口方法。判断当前集合是否为空boolean contains(Object obj);    List接口继承Collection接口方法。判断指定元素是否包含在当前集合中boolean containsAll(Collection<?> c);    List接口继承Collection接口方法。判断参数集合是不是当前集合在子集合Object[] toArray();    List接口继承Collection接口方法。获取当前集合中所有元素Object数组E get(int index);    List接口【特有方法】。获取指定下标对应的元素List<E> subList(int fromIndex, int toIndex);    List接口【特有方法】。获取当前集合指定子集合，从fromIndex开始，到toIndex结束。fromIndex <= 范围 < toIndex [)int indexOf(Object obj);    List接口【特有方法】。获取指定元素在集合中第一次出现位置int lastIndexOf(Object o);    List接口【特有方法】。获取指定元素在集合中最后一次出现的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestGet {    public static void main(String[] args) {        List<String> al = new ArrayList<String>();        al.add("Hello");        al.add("World");        al.add("Java");        al.add("Android");        al.add("Hello");        List<String> al2 = new ArrayList<>();        al2.add("Java");        al2.add("Hello");        System.out.println(al.size()); // 4        System.out.println(al.isEmpty()); // false        System.out.println(al.contains("Java")); // true        System.out.println(al.containsAll(al2)); // true        Object[] array = al.toArray();        for (Object str : array) {            System.out.println(str);        }        System.out.println(al.indexOf("World")); // 1        System.out.println(al.lastIndexOf("Hello")); // 4        System.out.println(al.get(0)); // Hello        System.out.println(al.subList(1, 3)); // [World, Java]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">void ensureCapacity(int minCapacity);    如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。trimToSize();    将此 ArrayList 实例的容量调整为列表的当前大小。节省空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><blockquote><p>增删慢，查询快</p></blockquote><pre><code>增删慢    增加慢        1、数组当前容量无法满足添加操作，需要进行grow扩容方法执行，在扩容方法中，存在数组创建，数组数据拷贝。非常浪费时间，而且浪费内存。        2、数组在添加数据的过程中，存在在指定位置添加元素，从指定位置开始，之后的元素整体向后移动。    删除慢        1、删除数据之后，从删除位置开始，之后的元素整体向前移动，移动过程非常浪费时间        2、删除操作会导致数据空间的浪费，内存的浪费    查询快        ArrayList 底层是一个数组结构，在查询操作的过程中，是按照数组+下标的方式来操作对应的元素，数组+下标方式可以直接获取对应的空间首地址，CPU访问效率极高。</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><blockquote><p>底层数据结构是一个双向链表，查询慢，增删快</p></blockquote><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>LinkedList使用的方法都是从List接口实现而来的方法，需要了解的是LinkedList特有方法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void addFirst(E e);    在当前链表开始位置加元素void addLast(E e);    在当前链表末尾添加元素E getFirst();    获取第一个Node节点元素数据E getLast();    获取末尾Node节点元素数据E removeFirst();    删除头节点E removeLast();    删除末尾节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        LinkedList<String> linkedList = new LinkedList<String>();        linkedList.add("Buffer");        linkedList.add("Balance");        linkedList.add("Wizard");        linkedList.add("Blanche");        linkedList.add("Eve");        linkedList.addFirst("Hello");        linkedList.addLast("World");        System.out.println(linkedList.getFirst());    // Buffer        System.out.println(linkedList.getLast());    // Eve        System.out.println(linkedList);    // [Hello, Buffer, Balance, Wizard, Blanche, Eve, World]        System.out.println("移除头元素" + linkedList.removeFirst());    // 移除头元素Hello        System.out.println("移除尾元素" + linkedList.removeLast());    // 移除尾元素World        System.out.println(linkedList);    // [Buffer, Balance, Wizard, Blanche, Eve]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><blockquote><p>一个不包含重复元素的 Collection。存储元素的顺序无序。（注意区分添加顺序和存储顺序）</p></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><blockquote><p>底层数据结构是哈希表，依赖 equals 方法和 hashCode 方法实现不可重复</p></blockquote><p>学生类：需要重写 equals() 和 hashCode()</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    // Construator setter/getter toString    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Set<Student> hashSet = new HashSet<Student>();        hashSet.add(new Student("Buffer", 23));        hashSet.add(new Student("Smoot", 22));        hashSet.add(new Student("Wizard", 23));        hashSet.add(new Student("Buffer", 23));        hashSet.add(new Student("Buffer", 20));        hashSet.add(new Student("Balance", 21));        for (Student student : hashSet) {            System.out.println(student);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Student [name=Smoot, age=22]Student [name=Wizard, age=23]Student [name=Balance, age=21]Student [name=Buffer, age=23]Student [name=Buffer, age=20]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>hashSet底层哈希表结构存储元素时，会首先得到当前元素的哈希值，需要执行调用对应的hashCode方法，hash方法中存在一个【移位运算】，一种特殊运算方式，用于根据当前对象的hashCode结果，计算该元素在底层哈希表中的存储位置。</p><p>【重点】如果元素hashCode值结果一致，那么它们保存对应的位置应该是一致的，会存入同一个空间，但是会进行equals比较，对象相同，【无法添加，对象不同，可以添加，但是需要避免】</p></blockquote><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><blockquote><p>基于 TreeMap 的 NavigableSet  实现，底层数据结构是平衡二叉树。使用元素的自然顺序对元素进行排序（Comparable），或者根据创建 set 时提供的 Comparator  进行排序，具体取决于使用的构造方法。</p></blockquote><p>Person 类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">package code.treeset;public class Person {    private String name;    private int age;    // Constructor setter/getter toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator 接口实现类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyCompare implements Comparator<Person> {    // 通过年龄判断是否为同一个 Person    @Override    public int compare(Person o1, Person o2) {        return o1.getAge() - o2.getAge();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestPerson {    public static void main(String[] args) {        // 创建 TreeSet 集合时传入一个 Comparator 接口的实现类        TreeSet<Person> treeSet = new TreeSet<Person>(new MyCompare());        treeSet.add(new Person("Smoot", 22));        treeSet.add(new Person("Buffer", 23));        treeSet.add(new Person("Wizard", 23));        treeSet.add(new Person("Balance", 21));        System.out.println(treeSet);    // [Person [name=Balance, age=21], Person [name=Smoot, age=22], Person [name=Buffer, age=23]]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>Map 接口允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection  视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap  类。</p><p>【重点】将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public interface Map<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Map<K, V> --| class HashMap<K, V>     重点！！！底层是哈希表--| class TreeMap<K, V>    底层是红黑树<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加方法-2"><a href="#增加方法-2" class="headerlink" title="增加方法"></a>增加方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V put(K key, V value);    添加符合Map要求的键值对存入到双边队列中void putAll(Map<? extends K, ? extends V> map)    添加另一个Map到当前Map中，要求K是当前Map本身对应的K，或者其子类，V是当前Map本身对应的V，或者其子类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-2"><a href="#删除方法-2" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V remove(Object key);     删除对应Key键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修改方法-1"><a href="#修改方法-1" class="headerlink" title="修改方法"></a>修改方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">V put(K key, V value);    使用value修改已存在的key对应的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查询方法-2"><a href="#查询方法-2" class="headerlink" title="查询方法"></a>查询方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">int size();    Map双边队列个数boolean isEmpty();    判断当前Map双边队列中是否为空boolean containsKey(Object key);    判断指定Key是否存在boolean containsValue(Object value);    判断指定Value是否存在Set<K> keySet();    返回Map双边队列中所有Key对应的Set集合Collection<V> values();    返回Map双边队列中所有value对应Collection集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Map-中的-Entry"><a href="#Map-中的-Entry" class="headerlink" title="Map 中的 Entry"></a>Map 中的 Entry</h3><blockquote><p>Map双边队列中把 Key 和 Value 进行一个封装操作，完全按照一个数据类型来处理。是 Map 中的一个成员接口，用于获取对应的键和值（参考Collection中的迭代器）</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">interface Map.Entry<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Set<Map.Entry<K, V>> entrySet();    返回值类型是Entry键值对形式数据的Set集合Set<Map.Entry<K, V>>    Map.Entry<K, V> Map接口的内部接口Entry，使用的泛型 K,V对应Map创建过程中约束的K,V    因为返回值是Set集合，集合带有泛型 Set<Map接口中的内部接口Entry>Entry 对应的方法    K getKey();        返回与此项对应的键    V getValue();        返回与此项对应的值。    V setValue(V value);        用指定的值替换与此项对应的值，返回与此项对应的旧值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestEntry {    public static void main(String[] args) {        Map<String, Integer> map = new HashMap<String, Integer>();        map.put("Buffer", 23);        map.put("Balance", 23);        map.put("Amy", 32);        Set<Entry<String, Integer>> entrySet = map.entrySet();        for (Entry<String, Integer> entry : entrySet) {            System.out.println(entry.getKey() + " setVaule: " + entry.setValue(16));            System.out.println(entry.getKey() + " : " + entry.getValue());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null  键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class HashMap<K,V><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestHashMap {    public static void main(String[] args) {        Map<String, Integer> map = new HashMap<String, Integer>();        map.put("Buffer", 23);        map.put("Balance", 23);        map.put("Amy", 32);        System.out.println(map);        HashMap<String, Integer> hashMap = new HashMap<>();        hashMap.put("Candy", 33);        hashMap.put("David", 29);        hashMap.putAll(map);        System.out.println(hashMap);        hashMap.remove("Balance");        System.out.println(hashMap);        hashMap.put("Buffer", 16);        System.out.println(hashMap);        System.out.println("map.size() :" + map.size());        System.out.println("map.isEmpty() : " + map.isEmpty());        System.out.println("have Buffer : " + map.containsKey("Buffer"));        System.out.println("have Buffer's age : " + hashMap.containsValue(16));        Set<String> keySet = map.keySet();        System.out.println(keySet);        Collection<Integer> values = map.values();        System.out.println(values);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】HashMap 添加自定义数据类型元素时需要重写其 equals 和 hashCode 方法</p></blockquote><p>学生类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    private char sex;    // Constructor setter getter toString equals hashCode}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestMap2 {    public static void main(String[] args) {        Map<Student, Integer> hashMap = new HashMap<Student, Integer>();        hashMap.put(new Student("Buffer", 23, '男'), 1);        hashMap.put(new Student("Balance", 23, '男'), 2);        hashMap.put(new Student("Buffer", 22, '男'), 3);        hashMap.put(new Student("Buffer", 23, '女'), 4);        hashMap.put(new Student("Buffer", 23, '男'), 5);        Set<Entry<Student, Integer>> entrySet = hashMap.entrySet();        for (Entry<Student, Integer> entry : entrySet) {            System.out.println(entry);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">Student [name=Balance, age=23, sex=男]=2Student [name=Buffer, age=23, sex=女]=4Student [name=Buffer, age=22, sex=男]=3Student [name=Buffer, age=23, sex=男]=5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote><p>基于红黑树（Red-Black tree）的 NavigableMap  实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator  进行排序，具体取决于使用的构造方法。 </p></blockquote><p>学生类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Student {    private String name;    private int age;    private char sex;    // Constructor and setter、getter}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Comparator 接口实现类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyCompare implements Comparator<Student> {    /**     * 返回两个学生的年龄差     */    @Override    public int compare(Student o1, Student o2) {        return o1.getAge() - o2.getAge();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><blockquote><p>文件和目录路径名的抽象表示形式，提供了对文件和文件夹的增删改查的方法</p></blockquote><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">File(String pathName);    根据指定的文件路径，或者文件夹路径，创建对应的File类对象。路径可以是相对路径，可以是绝对路径File(String parent, String childName);    根据指定的父目录文件夹路径，和子文件或者子文件夹的名字，创建对应的File类对象File(File parent, String childName);    根据指定的父目录File类对象，和子文件或者子文件夹的名字，创建对应的File类对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】如果是文件必须要有后缀名，否则就是文件夹</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file1 = new File("D:/aaa");        File file2 = new File("D:/aaa", "1.txt");        File file3 = new File(file1, "1.txt");        System.out.println(file1);    // D:\aaa        System.out.println(file2);    // D:\aaa\1.txt        System.out.println(file3);    // D:\aaa\1.txt    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean createNewFile();    通过File类对象调用，创建File类对象中对应地址的普通文件，创建成功返回true，创建失败返回false;    失败原因:        1. 路径不合法，路径不存在，路径错误。        2. 对应文件夹没有写入权限。        3. 对应文件已存在。        4. 磁盘坏道，电脑蓝屏。boolean mkdir();    通过File类对象创建，创建File类对象中对应的文件夹，创建成功返回true，失败返回false    失败原因:        1. 路径不合法，路径不存在，路径错误。        2. 对应文件夹没有写入权限。        3. 对应文件夹已存在。        4. 磁盘坏道，电脑蓝屏。boolean mkdirs();    创建文件夹过程中可以完成中间路径boolean renameTo(File dest);    通过File类对象调用，转为目标dest指定File类对象，可以操作普通文件，可以操作文件夹。移动或者重命名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        File file1 = new File("C:/Users/CJF/Desktop/啥啥啥.txt");        boolean createNewFile = file1.createNewFile();        System.out.println(createNewFile);        File file2 = new File("C:/Users/CJF/Desktop/啥啥啥");        boolean mkdir = file2.mkdir();        System.out.println(mkdir);        File file3 = new File("C:/Users/CJF/Desktop/啥啥啥/afaf/aggr/htedfgb/er");        boolean mkdirs = file3.mkdirs();        System.out.println(mkdirs);        File file4 = new File("C:/Users/CJF/Desktop/什么鬼.txt");        boolean renameTo = file1.renameTo(file4);        System.out.println(renameTo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除方法-3"><a href="#删除方法-3" class="headerlink" title="删除方法"></a>删除方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean delete();    通过File类对象调用，删除File类对象对应的文件或者文件夹。    注意事项:        1. 从磁盘中直接抹掉数据，不经过回收站，慎用        2. 删除操作只针对于空文件夹操作，不能删除非空文件夹void deleteOnExit();    程序退出之后，删除调用该方法File类对象，对应的普通文件或者文件夹。    用于缓冲文件，缓存问题，日志文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        File file = new File("C:/Users/CJF/Desktop/Test.txt");        System.out.println(file.createNewFile());    // true        System.out.println(file.delete());    // true        file.deleteOnExit();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">前三个方法和文件或者文件夹是否存在无关。String getPath();    获取File类对象中保存的路径String getName();    获取File类对象操作对应的文件名或者文件夹名String getParent();    获取File类对象操作文件或者文件夹的上级目录String getAbsolutePath();    获取当前File类对象对应路径的绝对路径long length();    获取当前【文件】的占用磁盘空间字节数    根据不同的系统环境，文件夹调用length方法 0L 或者 4096Llong lastModified();    获取当前文件夹上一次修改时间的【时间戳】    是从计算机元年1970-01-01 00:00:00 到修改时间的秒数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("D:/aaa/bbb/ccc/1.txt");        System.out.println(file.getPath());    // D:\aaa\bbb\ccc\1.txt        System.out.println(file.getParent());    // D:\aaa\bbb\ccc        System.out.println(file.getName());    // 1.txt        System.out.println(file.length());    // 0        System.out.println(file.lastModified());// 0        System.out.println(new File(".").getAbsolutePath());    // D:\Qfeng\day27\.    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean isFile();    判断当前File类对象对应的是不是普通文件。boolean isDirectory();    判断当前File类对象对应的是不是文件夹。boolean exists();    判断当前File类对象对应的内容是否存在。boolean isAbsolute();    判断当前File类对象保存的路径是不是绝对路径。boolean isHidden();    判断当前File类对象对应的文件是不是一个隐藏文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestFileDecide {    public static void main(String[] args) {        File file = new File("D:/Adobe");        System.out.println(file.exists());    // true        System.out.println(file.isFile());    // false        System.out.println(file.isDirectory());    // true        System.out.println(file.isAbsolute());    // true        System.out.println(file.isHidden());    // false    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">static File[] listRoots();        获取Windows操作系统下的所有盘符    Linux中没有什么作用。String[] list();    获取File类对象对应文件夹中所有子文件或者子文件夹名字，String类型数组File[]    listFiles();    获取File类对象对应文件夹中所有子文件或者子文件夹的File类对象数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("C:/Users/CJF/Desktop");        String[] list = file.list();        for (String fileName : list) {            System.out.println(fileName);        }        File[] listFiles = file.listFiles();        for (File file2 : listFiles) {            System.out.println(file2);        }        File[] listRoots = File.listRoots();        for (File file2 : listRoots) {            System.out.print(file2 + "\t"); // C:\ D:\ E:\        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FilenameFilter-文件名过滤器接口"><a href="#FilenameFilter-文件名过滤器接口" class="headerlink" title="FilenameFilter 文件名过滤器接口"></a>FilenameFilter 文件名过滤器接口</h3><p>实现此接口的类实例可用于过滤文件名。</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">boolean accept(File dir, String name);    dir是当前操作获取文件列表的文件夹File类对象    name是当前文件夹下的文件名或者文件夹名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        File file = new File("D:/EclipseWorkSpace/rx1901/src/com/fc/za/file");        String[] fileNameArray = file.list(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return new File(dir, name).isFile() && name.endsWith(".java");            }        });        for (String fileName : fileNameArray) {            System.out.println(fileName);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><blockquote><p>1、IO流用来处理设备之间的数据传输<br>   上传文件和下载文件<br>2、Java对数据的操作是通过流的方式<br>3、Java用于操作流的对象都在IO包中</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">I   input    从硬盘读取数据到内存    read 读O   output    从内存写入数据到硬盘    write 写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">按照数据流向    输入流    读入数据    字节输入流、字符输入流    输出流    写出数据    字节输出流、字符输出流按照数据类型    字节流                字节输入流、字符输出流    字符流                字符输入流、字符输出流class InputStream 字节输入流基类--| class FileInputStream 文件操作字节输入流class OutputStream 字节输出流基类--| class FileOutputStream 文件操作字节输出流class Reader 字符输入流基类--| class FileReader 文件操作字符输入流class Writer 字符输出流基类--| class FileWriter 文件操作字符输出流缓冲流:    BufferedInputStream            字节输入缓冲流    BufferedOutputStream        字节输出缓冲流        BufferedReader            字符输入缓冲流    BufferedWriter            字符输出缓冲流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileInputStream-文件操作字节输入流"><a href="#FileInputStream-文件操作字节输入流" class="headerlink" title="FileInputStream 文件操作字节输入流"></a>FileInputStream 文件操作字节输入流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的文件路径创建对应的FileInputStream，文件操作输入字节流，如果文件不存在，抛出异常FileNotFoundExceptionFileInputStream(String filePath);// 根据用户指定对应文件的File类对象，创建对应的FileInputStream，如果文件不存在，抛出异常FileNotFoundException            FileInputStream(File file);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 从文件中读取一个字节数据返回。如果读取到底末尾，返回-1 EOF End Of Fileint read();// 从文件中读取数据到缓冲数组buf中，返回值类型是从文件中读取到的字节个数，如果读取到文件末尾，返回-1， EOF End Of File 。如果在运行过程中出现了问题，抛出异常IOException       int read(byte[] buf); 【重点，效率高】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确对应文件的路径，可以选择直接给予对应的String类型路径，或者创建对应的File类对象，作为参数2. 创建FileInputStream文件操作字节输入流，打开文件操作管道3. 从FileInputStream对象中使用方法，读取数据4. 关闭资源！！！FileInputStream类对象 ==> 水龙头！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test1 {    public static void main(String[] args) throws IOException {        FileInputStream fileInputStream = new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        int content = fileInputStream.read();        System.out.println((char) content);//        byte[] buf = new byte[1024 * 16];        while (-1 != (content = fileInputStream.read())) {            System.out.print((char)content);        }        fileInputStream.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码二</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test2 {    public static void main(String[] args) throws IOException {        FileInputStream fis = new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        byte[] buf = new byte[1024 * 16];        int count = -1;        while (-1 != (count = fis.read(buf))) {            System.out.println(new String(buf, 0, count));        }        fis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】一般都会使用缓冲数组，因为单个字节读取效率太低了</p></blockquote><h3 id="FileOutputStream-文件操作字节输出流"><a href="#FileOutputStream-文件操作字节输出流" class="headerlink" title="FileOutputStream 文件操作字节输出流"></a>FileOutputStream 文件操作字节输出流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的路径，创建对应的FileOutputStream文件操作输出流对象。如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，再写入数据FileOutputStream(String filePath);// 根据用户指定的File类对象，创建对应FileOutputStream文件操作输出流对象，如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，再写入数据FileOutputStream(File file);// 根据用户指定的路径，创建对应的FileOutputStream文件操作输出流对象。如果路径不合法，抛出异常FileNotFoundException。// append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据FileOutputStream(String filePath, boolean append);// 根据用户指定的File类对象，创建对应FileOutputStream文件操作输出流对象，如果路径不合法，抛出异常FileNotFoundException。// append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据FileOutputStream(File file, boolean append);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 写入一个字节数据写入到文件中void write(int b);// 写入一个字节数组到文件中        void write(byte[] buf);// 写入一个字节数组到文件中，要求从off偏移位置开始，计数count     void write(byte[] buf, int off, int count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确对应文件的路径，可以选择直接给予对应的String类型路径，或者创建对应的File类对象，作为参数2. 创建FileOutputStream文件操作输出字节流，打开文件操作管道3. 使用FileOutputStream对象写入数据到文件中4. 关闭资源！！！【注意】    1. FileOutputStream拥有创建文件的能力，在路径合法，且对应目录有写入权限下可以创建文件    2. 区分删除写和追加写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileOutputStream fos = new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"));        fos.write(97);        System.out.println();        FileOutputStream fos2 = new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"), true);        fos2.write("\n今天是个好天气".getBytes());        fos2.close();        fos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileReader-文件操作字符输入流"><a href="#FileReader-文件操作字符输入流" class="headerlink" title="FileReader 文件操作字符输入流"></a>FileReader 文件操作字符输入流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据指定路径的文件创建对应的文件字符输入流对象，如果文件不存在，抛出异常FileNotFoundExceptionFileReader(String filePath);    // 根据指定路径的File类对象创建文件字符输入流对象，如果文件不存在，抛出异常FileNotFoundExceptionFileReader(File file);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 从文件中读取一个字符数据，返回值为int类型，int类型数据中有且只有低十六位是有效数据，如果读取到文件末尾返回-1 EOF End Of Fileint read();// 从文件中读取数据到char类型缓冲数组buf，返回值是读取到字符个数。如果读取到文件末尾返回-1 EOF End Of Fileint read(char[] buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作流程</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">1. 明确需要读取数据的文件2. 创建FileReader对象，打开文件操作管道3. 使用FileReader类对象方法，读取文件数据4. 关闭资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(new File("C:/Users/CJF/Desktop/Test.txt"));        char[] buf = new char[1024 * 16];        int content = -1;        while (-1 != (content = fr.read(buf))) {            System.out.println(new String(buf, 0, content));        }        fr.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="FileWriter-文件操作字符输出流"><a href="#FileWriter-文件操作字符输出流" class="headerlink" title="FileWriter 文件操作字符输出流"></a>FileWriter 文件操作字符输出流</h3><p>Constructor构造方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 根据用户指定的路径，创建对应的FileWriter文件操作字符输出流对象。如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，在写入数据FileWriter( String filePath);// 根据用户指定的File类对象，创建对应FileWriter文件操作字符输出流对象，如果路径不合法，抛出异常FileNotFoundException。采用写入数据到文件的方式，是【删除写】！！！文件内容清空，在写入数据FileWriter(File file);// 根据用户指定的路径，创建对应的FileWriter文件操作字符输出流对象。如果路径不合法，抛出异常FileNotFoundException。append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据    FileWriter(String filePath, boolean append);// 根据用户指定的File类对象，创建对应FileWriter文件操作字符输出流对象，如果路径不合法，抛出异常FileNotFoundException。append参数是boolean类型，如果传入参数为true，表示【追加写】，在文件末尾写入数据    FileWriter(File file, boolean append);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Method成员方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 写入一个字符数据写入到文件中void write(int ch);// 写入一个字符数组到文件中void write(char[] buf);// 写入一个字符数组到文件中，要求从off偏移位置开始，计数countvoid write(char[] buf, int off, int count);    // 写入一个字符串到文件中void write(String str);// 写入一个字符串到文件中，要求从offset偏移位置开始，计数countvoid write(String str, int offset, int count);【注意】    1. FileWriter拥有创建文件的能力，在路径合法，且对应目录有写入权限下可以创建文件    2. 区分删除写和追加写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        FileWriter fw = new FileWriter(new File("C:/Users/CJF/Desktop/Test.txt"), true);        fw.write("\n今天是520情人节");        fw.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo8 {    public static void main(String[] args) throws IOException {        // 明确操作源文件        File src = new File("D:/EclipseWorkSpace/FC2020/src/com/fc/z/io/a.txt");        // 明确操作源文件        File dest = new File("D:/EclipseWorkSpace/FC2020/src/com/fc/z/io/b.txt");        // 创建读对象        FileInputStream fis = new FileInputStream(src);        // 创建写对象        FileOutputStream fos = new FileOutputStream(dest);        // 缓存        byte[] buf = new byte[1024 * 16];        int content = -1;        // 读取数据并写入        while (-1 != (content = fis.read(buf))) {            fos.write(buf, 0, content);        }        // 关闭资源        fos.close();        fis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h3><blockquote><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、流程是一样的   明确文件   打开管道   操作文件   关闭资源2、核心方法   read 读取，输入   write 写入，输出3、输出流有创建文件的能力。4、 输出流需要注意是删除写还是追加写。5、输入流有缓冲比没有缓冲效率高很多6、一定要注意关闭资源！！！resource7、一般还是用字节流，避免文件损坏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">1、缓冲流是Java中提供的系统缓冲，底层都是一个缓冲数组，根据处理的数据方式不同，提供的数据有字节缓冲数组和字符缓冲数组。2、字节缓冲流，默认的字节数组缓冲区是8KB    byte[] buffer = new byte[1024 * 8];3、字符缓冲流，默认的字符数组缓冲区是16KB   char[] buffer = new char[1024 * 8];4、【重点】   任何一个缓冲流都没有任何操作文件的能力！！！读取文件数据，写入文件数据，都是依赖于对应的字符流或者字节流提供的！！！5、缓冲流使用的方法，也是read write 而且是对应创建当前缓冲流使用的字符流或者字节流的！！！6、缓冲流减少了CPU通过内存访问磁盘或者说文件的次数。极大的提高了开发效率。IO流操作文件内容都是在缓冲流内部的缓冲数组中，也就是内存中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><blockquote><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">BufferedInputStream   字节缓冲输入流BufferedOutputStream   字节缓冲输出流BufferedReader   字符缓冲输入流BufferedWriter   字符缓冲输出流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="BufferedInputStream-字节缓冲输入流"><a href="#BufferedInputStream-字节缓冲输入流" class="headerlink" title="BufferedInputStream 字节缓冲输入流"></a>BufferedInputStream 字节缓冲输入流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedInputStream(InputStream in);    这里需要的参数是字节输入流对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>成员方法 Method </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int read();int read(byte[] buf);其实就是InputStream中使用的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedInputStream bis = new BufferedInputStream(                new FileInputStream(new File("C:/Users/CJF/Desktop/Test.txt")));        byte[] buf = new byte[1024 * 8];        int count = -1;        while (-1 != (count = bis.read(buf))) {            System.out.println(new String(buf, 0, count));        }        bis.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedOutputStream-字节缓冲输出流"><a href="#BufferedOutputStream-字节缓冲输出流" class="headerlink" title="BufferedOutputStream 字节缓冲输出流"></a>BufferedOutputStream 字节缓冲输出流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedOutputStream(OutputStream out);    这里需要一个字节输出流作为方法的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用方法 Method    </p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void write(int b);void write(byte[] buf);void write(byte[] buf, int off, int len);以上方法都是OutputStream提供的方法。所有的数据都是首先都是写入保存到BufferedOutputStream 底层操作的数组中，当数组填满以后，或者执行指定的方法，才会将数据之间写入到内存中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream(new File("C:/Users/CJF/Desktop/Test.txt"), true));        bos.write("\n今天是个好天气".getBytes());        bos.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="效率总结"><a href="#效率总结" class="headerlink" title="效率总结"></a>效率总结</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">1、使用缓冲时间效率是远远高于未使用缓冲情况，这里是一个非常经典的空间换时间概念    缓冲占用内存 16KB 非缓冲 4byte 时间效率大于250倍 空间占用4000倍2、利用代码可以发现，非缓冲IO操作时使用数组作为缓冲区和使用缓冲流操作，时间效率相似。这里还是推荐使用系统提供的缓冲流，更加安全，并且提供了一些其他方法，可以作为一定参考和使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedReader-字符输入缓冲流"><a href="#BufferedReader-字符输入缓冲流" class="headerlink" title="BufferedReader 字符输入缓冲流"></a>BufferedReader 字符输入缓冲流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedReader(Reader in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用方法 Method</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int read();int read(byte[] buf);String readLine(); 【新方法】    从文件中读取一行数据，返回值类型是字符串，如果读取到文件默认，返回null    一行数据??? 结尾标记 \r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new FileReader(new File("C:/Users/CJF/Desktop/Test.txt")));        char[] buf = new char[1024 * 8];        int count = -1;        while (-1 != (count = br.read(buf))) {            System.out.println(new String(buf, 0, count));        }        String content = null;        while (null != (content = br.readLine())) {            System.out.println(content);    // 这里不会再输出，因为上面已经读到文件末尾，即 null == content        }        br.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BufferedWriter-字符输出缓冲流"><a href="#BufferedWriter-字符输出缓冲流" class="headerlink" title="BufferedWriter 字符输出缓冲流"></a>BufferedWriter 字符输出缓冲流</h3><p>构造方法 Constructor</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">BufferedWriter(Writer in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用方法</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">void write(int ch);void write(char[] buf);    void write(char[] buf, int off, int len);    void write(String str);    void write(String str, int off, int len);    void newLine();     换行写操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) throws IOException {        BufferedWriter bw = new BufferedWriter(new FileWriter(new File("C:/Users/CJF/Desktop/Test.txt"), true));        bw.write("\n今天又是个好天气");        bw.newLine();        bw.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><blockquote><p>概述：</p><p>​        正在运行的程序，是系统进行资源分配和调用的独立单位</p><p>​        每一个进程都有它自己的内存空间和系统资源</p><p>例如：</p><p>​        打开任务管理器，可以看到电脑中执行的每一个程序，每一个程序就是一个进程</p><p>特点：</p><p>​        1、独立性</p><p>​        2、动态性</p><p>​        3、并发性</p></blockquote><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>概述：        </p><p>​        是进程中的单个顺序控制流，是一条执行路径</p><p>​        一个进程如果只有一条执行路径，则称为单线程程序</p><p>​        一个进程如果有多条执行路径，则称为多线程程序</p><p>例如：</p><p>​        电脑管家就是一个程序 =&gt; 进程</p><p>​        电脑管家可以同时    病毒查杀，垃圾清理，一键加速等功能</p><p>​        这些每个功能都可以看做是线程，它们是同时进行的</p><p>特点：</p><p>​        1、线程是CPU的最小调度单位，CPU可以很快的在多个线程间实现切换。</p><p>​        2、运行时的线程，随时都可以被CPU给挂起。</p><p>​        3、线程的抢占发生在任意时期</p></blockquote><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><blockquote><p>1、一个进程可以有多个线程。但是必须要有一个主线程</p><p>2、进程间不能共享资源，但是线程间可以共享资源。</p><p>3、Java程序中，最少要有两个线程</p><p>​        1、main线程</p><p>​        2、JVM 的 GC 机制，守护线程</p></blockquote><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><blockquote><p>并发：两个或者两个以上的事务在同一个时间段发生</p><p>并行：两个或者两个以上的事务在同一个时刻发生</p></blockquote><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><blockquote><p>Java中的一个线程类，同时提供了很多线程的操作使用的方法，我们想要操作线程，必须通过Thread类对象去完成。Thread 类实现了 Runnable 接口，其中的 run 方法中就是我们要被运行的代码。可以通过重写 run 方法，并调用线程的 start 使其运行，以达到我们想要的效果</p></blockquote><h4 id="自定义线程三种方式"><a href="#自定义线程三种方式" class="headerlink" title="自定义线程三种方式"></a>自定义线程三种方式</h4><blockquote><p>1、自定义线程类，继承自 Thread，并重写 run 方法</p><p>2、自定义线程类，传入一个实现了 Runnable 接口的参数【重点】</p><p>3、自定义线程类，传入一个实现了 Callable 接口的参数</p></blockquote><h4 id="继承-Thread-类并重写-run-方法"><a href="#继承-Thread-类并重写-run-方法" class="headerlink" title="继承 Thread 类并重写 run 方法"></a>继承 Thread 类并重写 run 方法</h4><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo1 {    public static void main(String[] args) {        Thread1 thread1 = new Thread1();        thread1.start();        System.out.println("main线程");    }}class Thread1 extends Thread {    @Override    public void run() {        System.out.println("测试线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        Thread thread = new Thread(new Thread2());        thread.start();    }}class Thread2 implements Runnable {    @Override    public void run() {        System.out.println("测试线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo2 {    public static void main(String[] args) {        // 使用匿名内部类和匿名对象        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("测试线程");            }        }).start();        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><blockquote><p>可以有返回值</p><p>可以抛出异常</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test3 {    public static void main(String[] args) throws InterruptedException, ExecutionException {        Callable<Integer> cal = new Callable<Integer>() {            int count = 0;            @Override            public Integer call() throws Exception {                count++;                System.out.println(" Test :" + count);    //  Test :1                return count;            }        };        FutureTask<Integer> future = new FutureTask<Integer>(cal);        Thread thread = new Thread(future);        thread.start();        System.out.println("返回值为：" + future.get());    // 返回值为：1    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三种创建方式的区别"><a href="#三种创建方式的区别" class="headerlink" title="三种创建方式的区别"></a>三种创建方式的区别</h4><pre><code>继承 Thread 类：    编写简单、单继承，所以这种类无法再继承其他类、无法实现多个线程的资源共享、扩展性无实现 Runnable 接口：    编写复杂一点，接口可以多实现，可以实现多个线程的资源共享  推荐使用实现 Callable 接口：    编码复杂，可以实现线程执行完之后进行值的返回</code></pre><blockquote><p>【重点】开发中，需要线程返回值，就使用 Callable，不需要返回值的就可以 Runnable ，最常用的是实现 Runnable</p></blockquote><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="分时调度模型"><a href="#分时调度模型" class="headerlink" title="分时调度模型"></a>分时调度模型</h4><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p><h4 id="抢占式调度模型"><a href="#抢占式调度模型" class="headerlink" title="抢占式调度模型"></a>抢占式调度模型</h4><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些</p><blockquote><p>Java 采用的是抢占式调度模型</p></blockquote><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>线程的优先级就是线程获得CPU的概率，优先级越高，获取CPU的概率越大</p><blockquote><p>Java中共有10种优先级，从小到大，1-10之间。10是优先级最高，默认的优先级是5</p></blockquote><h4 id="优先级方法"><a href="#优先级方法" class="headerlink" title="优先级方法"></a>优先级方法</h4><blockquote><p>【注意】即便我们设置了优先级，也只是增加抢占的概率，线程并不一定会严格按照优先级执行</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 获取当前线程的优先级public final int getPriority()// 设置当前线程的优先级public final void setPriority(int newPriority)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo4 {    public static void main(String[] args) {        // 创建两个Runnable接口实现类        Runnable run1 = new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("烤羊排");                }            }        };        Runnable run2 = new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡");                }            }        };        // 创建两个线程        Thread thread1 = new Thread(run1);        Thread thread2 = new Thread(run2);        // 查看优先级        System.out.println(thread1.getPriority());        System.out.println(thread2.getPriority());        // 设置优先级        thread1.setPriority(10);        thread2.setPriority(1);        thread2.start();        thread1.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】设置优先级需要在 start 方法之前设置</p><h3 id="线程状态-生命周期"><a href="#线程状态-生命周期" class="headerlink" title="线程状态(生命周期)"></a>线程状态(生命周期)</h3><h4 id="简单理解生命周期"><a href="#简单理解生命周期" class="headerlink" title="简单理解生命周期"></a>简单理解生命周期</h4><blockquote><p>线程有五大状态，分别是新建、就绪、运行、阻塞、销毁</p></blockquote><p>新建：</p><blockquote><p>当我们实例化线程对象的时候，线程就是新建状态</p></blockquote><p>就绪：</p><blockquote><p>当我们调用线程的start方法之后，线程就会进入就绪状态</p><p>处于该状态的线程，随时都可以获取CPU调度</p></blockquote><p>运行：</p><blockquote><p>线程获取CPU的调度之后，线程抢到了时间片，可以用来运行自己任务</p></blockquote><p>阻塞：</p><blockquote><p>当线程因为资源竞争，或主动方法调用，让线程进入到阻塞。</p><p>常见：sleep、wait、join等等</p></blockquote><p>销毁：</p><blockquote><p>当线程的run方法执行结束之后，就会进入到销毁状态</p></blockquote><p>【注意】程序的结束就是指的内部的所有线程全部进入到了销毁状态</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155140.jpg" alt="线程的生命周期"></p><h4 id="扩展：六种线程状态"><a href="#扩展：六种线程状态" class="headerlink" title="扩展：六种线程状态"></a>扩展：六种线程状态</h4><blockquote><p>如果按照 java.lang.Thread.State 枚举方式，一共提供了6种线程状态</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:left">导致状态的发生条件</th></tr></thead><tbody><tr><td style="text-align:center">NEW(新建)</td><td style="text-align:left">线程刚刚被创建，没有启动，没有调用start方法</td></tr><tr><td style="text-align:center">RUNNABLE(可运行)</td><td style="text-align:left">线程已经可以在JVM中运行，但是是否运行不确定，看当前线程是否拥有CPU执行权</td></tr><tr><td style="text-align:center">BLOCKED(锁阻塞)</td><td style="text-align:left">当前线程进入一个同步代码需要获取对应的锁对象，但是发现当前锁对象被其他线程持有，当前线程会进入一个BLOCKED。如果占用锁对象的线程打开锁对象，当前线程持有对应锁对象，进入Runnable状态</td></tr><tr><td style="text-align:center">WAITING(无限等待)</td><td style="text-align:left">通过一个wait方法线程进入一个无限等待状态，这里需要另外一个线程进行唤醒操作。进入无限等待状态的线程是无法自己回到Runnable状态，需要其他线程通过notify或者notifyAll方法进行唤醒操作</td></tr><tr><td style="text-align:center">TIMED_WAITING(计时等待)</td><td style="text-align:left">当前线程的确是等待状态，但是会在一定时间之后自动回到Runnable状态，例如 Thread.sleep() 或者是Object类内的wait(int ms);</td></tr><tr><td style="text-align:center">TERMINATED(被终止)</td><td style="text-align:left">因为Run方法运行结束正常退出线程，或者说在运行的过程中因为出现异常导致当前线程被销毁</td></tr></tbody></table></div><h5 id="TIMED-WAITING-计时等待"><a href="#TIMED-WAITING-计时等待" class="headerlink" title="TIMED_WAITING(计时等待)"></a>TIMED_WAITING(计时等待)</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在对应线程代码块中，当前线程休眠指定的时间Thread.sleep(int ms);    sleep方法        1. 调用之后休眠指定时间        2. sleep方法必须执行在run方法内，才可以休眠线程        3. sleep不会打卡当前线程占用的锁对象。// 让当前线程进入一个计时等待状态        void wait(long timeout);    Object类内         1. 规定的时间及时完毕，线程回到可运行状态        2. 在等待时间内，通过其他线程被notify或者notifyAll唤醒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155233.png" alt="TIMED_WAITING状态"></p><h5 id="BLOCKED-锁阻塞"><a href="#BLOCKED-锁阻塞" class="headerlink" title="BLOCKED(锁阻塞)"></a>BLOCKED(锁阻塞)</h5><pre><code>线程中有锁存在，线程需要进入带有锁操作的同步代码，如果锁对象被别人持有，只能在锁外等待锁阻塞状态的线程是否能够抢到锁对象有很多因素    1. 优先级问题，非决定因素    2. CPU执行概率问题。后期高并发一定会存在多线程操作锁对象问题，秒杀，抢购...    队列方式来处理</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155311.png" alt="BLOCKED锁阻塞状态"></p><h5 id="线程状态-WAITING-无限等待"><a href="#线程状态-WAITING-无限等待" class="headerlink" title="线程状态 WAITING(无限等待)"></a>线程状态 WAITING(无限等待)</h5><pre class="line-numbers language-lang-java"><code class="language-lang-java">当某一个线程被执行wait()方法，需要等待另外的一个线程进行唤醒操作。public void wait();    在哪一个线程中执行，就会让当前线程进入一个无限等待状态。            1. 所在线程进入无限等待状态            2. 开启【锁对象】public void notify();    唤醒和当前锁对象有关的无限等待线程中的一个，随机选择。            1. 唤醒一个无限等待状态线程            2. 开启【锁对象】public void notifyAll();    唤醒所有和当前锁对象有关的无限等待线程            1. 唤醒所有线程            2. 开启【锁对象】            3. 线程进入锁对象抢占过程，就有可能进入一个锁阻塞状态。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155344.png" alt="无限等待图例"></p><h5 id="线程执行的所有状态分析图"><a href="#线程执行的所有状态分析图" class="headerlink" title="线程执行的所有状态分析图"></a>线程执行的所有状态分析图</h5><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/20201120155420.png" alt="六大线程状态"></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote><p>线程分为：用户线程和守护线程，Java中默认创建的线程就是用户线程</p></blockquote><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><blockquote><p>当守护的用户线程销毁的时候，守护线程也会跟着消亡。无论守护线程是否执行结束都会随着用户线程一起销毁</p></blockquote><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><blockquote><p>1、自动下载</p><p>2、操作日志</p><p>3、操作监控</p></blockquote><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 判断该线程是否为守护线程boolean isDaemon();// 当传入 true 时，将当前线程设置为守护线程：void setDaemon(boolean on)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo5 {    public static void main(String[] args) {        // 创建两个线程        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡");                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                }            }        });        // 查看是否是守护线程        System.out.println(thread2.isDaemon());        // 设置守护线程        thread2.setDaemon(true);        thread1.start();        thread2.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>【注意】主线程和 GC（<strong>garbage collection </strong>垃圾回收机制） 线程就是一对用户线程与守护线程，GC 守护主线程</p></blockquote><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 线程休眠(运行-->阻塞)：static void sleep(long millis);// 线程加入(运行-->阻塞)：void join();// 线程礼让(运行-->就绪)：    void yield();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><blockquote><p>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo6 {    public static void main(String[] args) {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡" + i);                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        thread.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】使用sleep方法需要对其进行异常捕获</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><blockquote><p>在当前线程中，执行另一个线程的join方法，然后当前线程就会阻塞，等待插入的线程执行完毕之后，才会从阻塞状态进入到就绪状态，重新参与CPU抢夺！</p><p>就绪状态的线程的抢占发生在任意时期</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo7 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("烤羊排" + i);                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 10; i++) {                    System.out.println("大盘鸡" + i);                }            }        });        thread2.start();        // 线程加入        thread2.join();        thread1.start();        // 主线程        for (int i = 0; i < 10; i++) {            System.out.println("main线程");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><blockquote><p>可以让当前正在运行的线程暂停，并执行其他线程。但是不会让当前线程阻塞，而且让当前的线程进入到就绪状态。</p><p>实际上：线程执行yield之后，只有比当前线程的优先级更高或者相同的才有机会参与抢夺CPU，而且当前线程也会参与抢夺</p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo8 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("大盘鸡" + i);                    if (i == 5) {                        System.out.println("线程礼让");                        Thread.yield();                    }                }            }        });        thread1.setPriority(9);        thread2.setPriority(1);        thread2.start();        thread1.start();        // 主线程        System.out.println("main线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">static Thread currentThread();    返回对当前正在执行的线程对象的引用long getId();    返回该线程的标识符。线程 ID 是一个正的 long 数，在创建该线程时生成。线程 ID 是唯一的，并终生不变。线程终止时，该线程 ID 可以被重新使用 String getName();    返回该线程的名称void setName(String name);    改变线程名称，使之与参数 name 相同Thread.State getState();    返回该线程的状态boolean isAlive();    测试线程是否处于活动状态boolean isInterrupted();    测试线程是否已经中断void interrupt();    中断线程static boolean interrupted();    判断当前线程是否已经中断。线程的中断状态由该方法清除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo9 {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("烤羊排" + i);                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 100; i++) {                    System.out.println("大盘鸡" + i);                    if (i == 5) {                        System.out.println("线程礼让");                        Thread.yield();                    }                }            }        });//        thread2.start();        thread1.start();        System.out.println("获取当前线程：" + Thread.currentThread());        System.out.println("获取线程1的标识：" + thread1.getId());        System.out.println("获取线程2的标识：" + thread2.getId());        System.out.println("获取当前线程的标识：" + Thread.currentThread().getId());        System.out.println("获取当前线程的名称：" + thread1.getName());        // 设置线程的名称        thread1.setName("线程1");        System.out.println("获取当前线程的名称：" + thread1.getName());        System.out.println("获取当前线程的状态：" + thread1.getState());        System.out.println("获取当前线程是否存活：" + thread1.isAlive());        System.out.println("获取当前线程是否中断：" + thread1.isInterrupted());        // 中断线程        thread1.interrupt();        System.out.println("获取当前线程是否中断：" + thread1.isInterrupted());        System.out.println("获取当前线程是否中断：" + Thread.interrupted());        // 主线程        System.out.println("main线程");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h4><blockquote><p>线程的抢占发生在任意时期</p><p>当多个线程操作同一个数据源的时候吗，并且都涉及到了修改，那么就有可能发生数据重复的问题，这种现象就成为线程安全的问题。</p></blockquote><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo10 {    public static void main(String[] args) {        Thread thread1 = new Thread(new SellTicket(), "淘票票");        Thread thread2 = new Thread(new SellTicket(), "猫眼");        Thread thread3 = new Thread(new SellTicket(), "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket implements Runnable {    // 100张票    private static int ticket = 100;    @Override    public void run() {        // 循环卖票        while (true) {            // 如果当前票数不为0，就卖一张，票数-1，并睡一会儿            if (ticket > 0) {                System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                // 如果当前票数为0，说明票卖完了，需要退出循环            } else {                System.out.println(Thread.currentThread().getName() + "已售罄！！");                break;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="导致线程安全问题的因素"><a href="#导致线程安全问题的因素" class="headerlink" title="导致线程安全问题的因素"></a>导致线程安全问题的因素</h4><blockquote><p>1、多个线程</p><p>2、同时操作临界资源 共享资源</p></blockquote><h4 id="如何解决线程安全的问题-加锁"><a href="#如何解决线程安全的问题-加锁" class="headerlink" title="如何解决线程安全的问题(加锁)"></a>如何解决线程安全的问题(加锁)</h4><h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h5><h6 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h6><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    synchronized (锁对象) {        // 需要被同步的代码;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】同步代码块的锁对象可以是任意对象，但必须是同一个对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo11 {    public static void main(String[] args) {        Thread thread1 = new Thread(new SellTicket1(), "淘票票");        Thread thread2 = new Thread(new SellTicket1(), "猫眼");        Thread thread3 = new Thread(new SellTicket1(), "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket1 implements Runnable {    private static int ticket = 100;    private static final Object obj = new Object();    @Override    public void run() {        while (true) {            synchronized (obj) {                if (ticket > 0) {                    System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else {                    System.out.println(Thread.currentThread().getName() + "已售罄！！");                    break;                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h6><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    synchronized 返回值 方法名(参数列表){        // 需要被同步的代码;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】同步方法的锁对象是 this</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo12 {    public static void main(String[] args) {        SellTicket2 sellTicket2 = new SellTicket2();        Thread thread1 = new Thread(sellTicket2, "淘票票");        Thread thread2 = new Thread(sellTicket2, "猫眼");        Thread thread3 = new Thread(sellTicket2, "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket2 implements Runnable {    private static int ticket = 100;    private synchronized boolean sell() {        if (ticket > 0) {            System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            return true;        } else {            System.out.println(Thread.currentThread().getName() + "已售罄！！");            return false;        }    }    @Override    public void run() {        while (true) {            if (!sell()) {                break;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h6><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    static synchronized 返回值 方法名(参数列表){        // 需要被同步的代码;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】静态同步方法的锁对象是当前类的字节码文件对象，保证唯一性</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo13 {    public static void main(String[] args) {        Thread thread1 = new Thread(new SellTicket3(), "淘票票");        Thread thread2 = new Thread(new SellTicket3(), "猫眼");        Thread thread3 = new Thread(new SellTicket3(), "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket3 implements Runnable {    private static int ticket = 100;    private static synchronized boolean sell() {        if (ticket > 0) {            System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            return true;        } else {            System.out.println(Thread.currentThread().getName() + "已售罄！！");            return false;        }    }    @Override    public void run() {        while (true) {            if (!sell()) {                break;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【注意】</p><blockquote><p>1、锁修饰的内容只能是引用类型对象，一般都是使用this，但是一定保证是同一个类对象，否则this不唯一</p><p>2、锁的位置很关键，一般都是锁定是引起线程安全的部分</p><p>3、锁会自动释放，内部代码执行完毕之后</p><p>4、多个线程必须使用同一把锁</p></blockquote><h6 id="Synchronized-用法的区别"><a href="#Synchronized-用法的区别" class="headerlink" title="Synchronized 用法的区别"></a>Synchronized 用法的区别</h6><blockquote><p>1、同步代码块 锁的粒度可以很小</p><p>锁的粒度来讲：同步代码块 &lt;  同步方法 &lt;  同步静态方法</p><p>粒度 也就是锁的范围  粒度越小越好</p><p>2、同步代码块 锁的对象可以是：引用类型属性、this、字节码对象</p><p>同步方法 锁的对象只能是当前类的实例 this</p><p>3、同步静态方法 锁的对象是当前类的字节码对象</p></blockquote><h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><p>【注意】Lock 锁的性能要比 synchronized 高，但是lock要求必须手动释放锁</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">格式：    private final Lock lock = new ReentrantLock();    public void method() {         lock.lock();  // block until condition holds         try {               // ... method body         } finally {               lock.unlock();         }       }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo14 {    public static void main(String[] args) {        SellTicket4 sellTicket4 = new SellTicket4();        Thread thread1 = new Thread(sellTicket4, "淘票票");        Thread thread2 = new Thread(sellTicket4, "猫眼");        Thread thread3 = new Thread(sellTicket4, "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket4 implements Runnable {    private static int ticket = 100;    private final Lock lock = new ReentrantLock();    @Override    public void run() {        while (true) {            lock.lock();            try {                if (ticket > 0) {                    System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else {                    System.out.println(Thread.currentThread().getName() + "已售罄！！");                    break;                }            } finally {                lock.unlock();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码2</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Demo15 {    public static void main(String[] args) {        Thread thread1 = new Thread(new SellTicket5(), "淘票票");        Thread thread2 = new Thread(new SellTicket5(), "猫眼");        Thread thread3 = new Thread(new SellTicket5(), "美团");        thread1.start();        thread2.start();        thread3.start();    }}class SellTicket5 implements Runnable {    private static int ticket = 100;    private static final Lock lock = new ReentrantLock();    @Override    public void run() {        while (true) {            lock.lock();            try {                if (ticket > 0) {                    System.out.println(Thread.currentThread().getName() + "卖出一张票，当前还剩下" + --ticket + "张票");                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else {                    System.out.println(Thread.currentThread().getName() + "已售罄！！");                    break;                }            } finally {                lock.unlock();            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象</p><h5 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h5><blockquote><p>1、2个以上的线程</p><p>2、2个以上的锁</p><p>3、同步代码块嵌套同步代码块</p></blockquote><p>自定义锁对象</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">class MyLock {    // 第一把锁    public static Object LOCK1 = new Object();    // 第二把锁    public static Object LOCK2 = new Object();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>死锁类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class DeadLock implements Runnable {    boolean flag;    public DeadLock(boolean flag) {        this.flag = flag;    }    @Override    public void run() {        if (flag) {            synchronized (MyLock.LOCK1) {                System.out.println("if LOCK1");                synchronized (MyLock.LOCK2) {                    System.out.println("if LOCK2");                }            }        } else {            synchronized (MyLock.LOCK2) {                System.out.println("else LOCK2");                synchronized (MyLock.LOCK1) {                    System.out.println("else LOCK1");                }            }        }    };}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Test {    public static void main(String[] args) {        Thread th1 = new Thread(new DeadLock(false));        Thread th2 = new Thread(new DeadLock(true));        th1.start();        th2.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>线程通信：有一个缓冲区的仓库，生产者线程，不断往仓库存储内容，消费者线程不断从仓库中获取内容。为了解决生产者和消费者的动态调节的问题，可以使用线程通信机制，来保护生产者和消费中的同步</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待线程状态从 运行 变更为 阻塞void wait();// 唤醒在此对象监视器上等待的单个线程，只能唤醒因为wait阻塞的线程。线程的状态从 阻塞 变更为 就绪void notify();// 唤醒在此对象监视器上等待的所有线程，只能唤醒因为wait阻塞的线程。线程的状态从 阻塞 变更为 就绪        void notifyAll();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>wait、notify、notifyall 都是Object的方法、都需要使用在同步方法中</strong></p></blockquote><pre class="line-numbers language-lang-java"><code class="language-lang-java">class Restaurant {    int count = 0;    public synchronized void make() {        if (count < 10) {            System.out.println(Thread.currentThread().getName() + "做了一道菜，当前还有" + (count + 1) + "道菜");            count++;            notifyAll();        } else {            try {                System.out.println("做完了赶紧卖");                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public synchronized void sell() {        if (count > 0) {            System.out.println(Thread.currentThread().getName() + "卖了一道菜，当前还有" + (count - 1) + "道菜");            count--;            notify();        } else {            try {                System.out.println("卖完了赶紧做");                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}public class TestRestaurant {    public static void main(String[] args) {        Restaurant res = new Restaurant();        Thread th1 = new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    res.make();                    Thread.yield();                }            }        });        Thread th2 = new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    res.make();                    Thread.yield();                }            }        });        Thread th3 = new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    res.sell();                    Thread.yield();                }            }        });        Thread th4 = new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    res.sell();                    Thread.yield();                }            }        });        th1.setName("做饭小伙");        th2.setName("做饭姑娘");        th3.setName("卖饭小伙");        th4.setName("卖饭姑娘");        th1.start();        th2.start();        th3.start();        th4.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池：有效并充分利用线程，合理分配资源</p><blockquote><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池</p><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用</p></blockquote><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><blockquote><p>1、控制线程数量</p><p>2、避免了频繁的创建和销毁线程</p><p>3、对线程进行统一的管理</p></blockquote><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><p>Executors Java封装的创建线程池的工具类  现在已经被淘汰 因为很容易引起 OOM (Out of Memory) 异常</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 创建一个可重用的，具有固定线程数的线程池newFixedThreadPool(int nThreads);  // 创建一个只有单线程的线程池，相当于上个方法的参数是1 newSingleThreadExecutor();// 创建一个没有上限的线程池newCachedThreadPool();// 创建一个固定线程数量的线程池，这个线程池具备延迟、定时重复执行newScheduledThreadPool();// 创建一个抢占式的线程池newWorkStealingPool();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h4><p>目前推荐手动创建线程池</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 用给定的初始参数和默认的线程工厂及被拒绝的执行处理程序创建新的 ThreadPoolExecutorThreadPoolExecutor(int corePoolSize,  int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)参数说明：        corePoolSize - 设置最小线程数量。池中所保存的线程数，包括空闲线程。        maximumPoolSize - 池中允许的最大线程数。        keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。        unit - keepAliveTime 参数的时间单位。        workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行线程池</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">// 执行对应的线程void execute(Runnable command);   // 关闭线程池void shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例代码</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class TestThreadPool {    public static void main(String[] args) {        ThreadPoolExecutor tpe = new ThreadPoolExecutor(3, 5, 1000, TimeUnit.SECONDS,                new ArrayBlockingQueue<Runnable>(10));        tpe.execute(new Runnable() {            int count = 0;            @Override            public void run() {                while (count < 5) {                    try {                        System.out.println("111");                        count++;                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        tpe.execute(new Runnable() {            int count = 0;            @Override            public void run() {                while (count < 5) {                    try {                        System.out.println("222");                        count++;                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        tpe.execute(new Runnable() {            int count = 0;            @Override            public void run() {                while (count < 5) {                    try {                        System.out.println("333");                        count++;                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        tpe.shutdown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商管理系统</title>
      <link href="posts/57339.html"/>
      <url>posts/57339.html</url>
      
        <content type="html"><![CDATA[<h3 id="电商管理系统"><a href="#电商管理系统" class="headerlink" title="电商管理系统"></a>电商管理系统</h3><p>第一步：先创建四大类，分别为 商品类（Article）、商品集合类（ArticleSet）、商品管理类（ArticleManage）、商品测试类（Demo）. </p><p>代码如下：</p><h4 id="商品类"><a href="#商品类" class="headerlink" title="商品类"></a>商品类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 商品类 * */public class Article {    public String name;    public int amount;    public double price;    public int number;    public void print(int index){        System.out.println(index+"\t"+name+"\t"+price+"\t"+amount+"\t"+number);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品集合类"><a href="#商品集合类" class="headerlink" title="商品集合类"></a>商品集合类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * 商品集合类 * */public class ArticleSet {    Article[] articles=new Article[50];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品管理类"><a href="#商品管理类" class="headerlink" title="商品管理类"></a>商品管理类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">import java.util.Scanner;/** * 商品管理类 * */public class ArticleManage {    ArticleSet articleSet=new ArticleSet();    Scanner input=new Scanner(System.in);    /**     * 初始化商品     */    public void initial(){        Article xiaoMi9=new Article();        xiaoMi9.name="小米9";        xiaoMi9.price=2799;        xiaoMi9.amount=60;        xiaoMi9.number=0;        Article xiaoMiMIX3=new Article();        xiaoMiMIX3.name="小米8";        xiaoMiMIX3.price=2049;        xiaoMiMIX3.amount=40;        xiaoMiMIX3.number=0;        Article redMiNote7Pro=new Article();        redMiNote7Pro.name="Redmi7";        redMiNote7Pro.price=699;        redMiNote7Pro.amount=80;        redMiNote7Pro.number=0;        Article xiaoMiPlay=new Article();        xiaoMiPlay.name="小米6x";        xiaoMiPlay.price=749;        xiaoMiPlay.amount=100;        xiaoMiPlay.number=0;        articleSet.articles[0]=xiaoMi9;        articleSet.articles[1]=xiaoMiMIX3;        articleSet.articles[2]=redMiNote7Pro;        articleSet.articles[3]=xiaoMiPlay;    }    public void startMenu(){        boolean flag=true;        do {System.out.println("欢迎使用前程商城后台管理系统");        System.out.println("*****************************************");        System.out.println("1.查看商品信息");        System.out.println("2.新增商品信息");        System.out.println("3.删除商品信息");        System.out.println("4.卖出商品信息");        System.out.println("5.商品销售排行榜");        System.out.println("6.退出");        System.out.println("*****************************************");        Scanner sc=new Scanner(System.in);        System.out.println("请选择要执行的操作：");        int choice=sc.nextInt();        switch (choice) {        case 1:            System.out.println("查看商品信息");            search();            break;        case 2:            System.out.println("新增商品信息");            add();            break;        case 3:            System.out.println("删除商品信息");            delete();            break;        case 4:            System.out.println("卖出商品信息");            sell();            break;        case 5:            System.out.println("商品销售排行榜");            leaderboard();            break;        case 6:            System.out.println("谢谢使用！");            flag=false;            break;        default:            System.out.println("输入不符合请重新输入：");            break;        }        } while (flag);    }    /**     * 查看商品     */    public void search(){        System.out.println("编号\t名称\t价格\t库存\t售出");        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null) {                articleSet.articles[i].print(i+1);            }        }    }    /**     * 新增商品     */    public void add(){        System.out.println("请输入商品名称：");        String name=input.next();        System.out.println("请输入价格：");        int price=input.nextInt();        System.out.println("请输入库存：");        int amount=input.nextInt();        Article article=new Article();        article.name=name;        article.price=price;        article.amount=amount;        article.number=0;        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]==null) {                articleSet.articles[i]=article;                break;            }        }    }    /**     * 删除商品     */    public void delete(){        System.out.println("请输入商品编号：");        boolean flag=true;        int card=input.nextInt();        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null&&(i+1)==card) {                int j=i;                while (articleSet.articles[j+1]!=null) {                    articleSet.articles[j]=articleSet.articles[j+1];                    j++;                }                articleSet.articles[j]=null;                flag=true;                break;            }         }        if (flag) {            System.out.println("删除成功！");        }else {            System.out.println("删除失败，请重新操作！");        }    }    /**     * 销售业务     */    public void sell(){        System.out.println("请输入你要卖出的商品名称：");        String name=input.next();        boolean flag=true;        for (int i = 0; i < articleSet.articles.length; i++) {            if (articleSet.articles[i]!=null&&articleSet.articles[i].name.equals(name)) {                System.out.println("请输入你要卖出的数量");                int number=input.nextInt();                if (number<=articleSet.articles[i].amount) {                    articleSet.articles[i].number=articleSet.articles[i].number+number;                    articleSet.articles[i].amount=articleSet.articles[i].amount-number;                    flag=true;                } else {                    System.out.println("商品数量不够，请抓紧进货！");                    flag=false;                }                break;            }else{                flag=false;            }        }        if (flag) {            System.out.println("卖出商品成功！");        } else {            System.out.println("卖出商品失败！");        }    }    /**     * 商品销售排行榜     */    public void leaderboard() {        Article[] articles = new Article[50];        for (int i = 0; i < articles.length; i++) {            if (articleSet.articles[i]!=null) {                articles[i]=articleSet.articles[i];            }        }        for (int i = 0; i < articles.length-1; i++) {            for (int j = 0; j < articles.length-i-1; j++) {                if (articles[j+1] != null) {                    if (articles[j].number < articles[j+1].number) {                        Article tempArticle = articles[j];                        articles[j]=articles[j+1];                        articles[j+1]=tempArticle;                    }                }            }        }        System.out.println("*************************************");        System.out.println("名次\t销售数量\t商品名称");        for (int i = 0; i < articles.length; i++) {            if (articles[i]!=null) {                System.out.println(i+1+"\t"+articles[i].number+"\t"+articles[i].name);            }        }    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="商品测试类"><a href="#商品测试类" class="headerlink" title="商品测试类"></a>商品测试类</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** *商品测试类 */public class Demo {    public static void main(String[] args) {        ArticleManage articleManage=new ArticleManage();        articleManage.initial();        articleManage.startMenu();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的优化</title>
      <link href="posts/9296.html"/>
      <url>posts/9296.html</url>
      
        <content type="html"><![CDATA[<p>简单写一些关于优化hexo博客的内容，后续陆续补充.</p><hr><h3 id="一-添加动态标题"><a href="#一-添加动态标题" class="headerlink" title="一.添加动态标题"></a>一.添加动态标题</h3><p>在matery/layout/layout.ejs下添加如下内容.</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;            var OriginTitile=document.title,st;             document.addEventListener(&quot;visibilitychange&quot;,function(){                 document.hidden?(document.title=&quot;ヽ(●-`Д´-)ノ你要玩捉迷藏嘛&quot;,clearTimeout(st)):(document.title=&quot;(Ő∀Ő3)ノ好哦！&quot;,st=setTimeout(function(){document.title=OriginTitile},3e3))                 })&lt;/script&gt;</code></pre><h3 id="二-配置音乐播放器"><a href="#二-配置音乐播放器" class="headerlink" title="二.配置音乐播放器"></a>二.配置音乐播放器</h3><p> 要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可： </p><pre><code># 是否在首页显示音乐music:  enable: true  title:             # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: &#39;#42b983&#39;  loop: &#39;all&#39;       # 音频循环播放, 可选值: &#39;all&#39;, &#39;one&#39;, &#39;none&#39;  order: &#39;random&#39;   # 音频循环顺序, 可选值: &#39;list&#39;, &#39;random&#39;  preload: &#39;auto&#39;   # 预加载，可选值: &#39;none&#39;, &#39;metadata&#39;, &#39;auto&#39;  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠</code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p>id获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="三、修改博客每页文章的个数"><a href="#三、修改博客每页文章的个数" class="headerlink" title="三、修改博客每页文章的个数"></a>三、修改博客每页文章的个数</h3><p>如图： per_page: 9  其中的“9”就是每页文章的个数</p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201208173206918.png" alt="image-20201208173206918"></p><p><img src="https://cdn.jsdelivr.net/gh/wind-qin/Picture@master/image-20201208173132818.png" alt="image-20201208173132818"></p><h3 id="其它内容优化："><a href="#其它内容优化：" class="headerlink" title="其它内容优化："></a>其它内容优化：</h3><p>想查看其它优化博客的内容请移步好友的博客：</p><p><a href="https://www.islu.cn/posts/9443.html" target="_blank" rel="noopener">https://www.islu.cn/posts/9443.html</a></p><p>此人博客较为详细</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="posts/38943.html"/>
      <url>posts/38943.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="java语言的特点："><a href="#java语言的特点：" class="headerlink" title="java语言的特点："></a>java语言的特点：</h3><p>​                1.跨平台（一次开发，到处运行）</p><p>​                2.面向对象（万物皆可对象）</p><h3 id="java开发环境："><a href="#java开发环境：" class="headerlink" title="java开发环境："></a>java开发环境：</h3><p>​                jdk：java开发工具包（开发人员必须安装）</p><p>​                jre：java运行环境（运行java程序必须安装）</p><p>​                注意：java程序最终是运行在jvm虚拟机上的，不同的操作系统上可以安装其对应版本的jvm，这样就实现了跨平台</p><h3 id="java类的结构"><a href="#java类的结构" class="headerlink" title="java类的结构"></a>java类的结构</h3><p>​                1.编写源文件（后缀名    .java）</p><p>​                2.编译            （后缀名    .class）</p><p>​                3.运行</p><h3 id="java类的结构-1"><a href="#java类的结构-1" class="headerlink" title="java类的结构"></a>java类的结构</h3><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class 类名{    public static void main(String[] args){    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <code>注意：main方法是java程序的入口</code></p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><p>​    输出语句</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">System.out.print("\n");//输出完之后不会换行System.out.println("\n");//输出完之后换行显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    转义符：</p><p>​    \n    换行，相当于输出完一句话按了回车键</p><p>​    \t    大空格，相当于Tab键</p><p>​    注释：</p><p>​    1.单行注释    //注释的内容</p><p>​    2.多行注释    /<em> 注释内容 </em>/</p><p>​    变量：</p><pre class="line-numbers language-lang-html"><code class="language-lang-html">color=red; 内存中一块储存空间的表示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="变量的数据类型："><a href="#变量的数据类型：" class="headerlink" title="变量的数据类型："></a>变量的数据类型：</h3><p>​    1.基本类型</p><p>​        八种基本数据类型</p><p>​        byte(1个字节) short(2个字节) int(4个字节) long(8个字节) </p><p>​        float(4个字节) double(8个字节) char(2个字节) boolean(1个字节)</p><p>​        自动转换 boolean—&gt;byte—&gt;short—&gt;int—&gt;long—&gt;float—&gt;double</p><p>​        short—&gt;float</p><p>​        自动    小—&gt;大</p><p>​        强制    大—&gt;小</p><p>​        float—&gt;int    强制    （int）12.3f</p><p>​    2.引用类型：</p><p>​        String，数组，对象，除了8种基本数据类型之外的都属于引用数据类型</p><p><strong>注意：比较相等</strong></p><ul><li><p>java基本数据类型（8种）</p><p>​    比较相等用==比较，比较不等！=</p></li><li><p>2.String</p><p>​    比较相等用equals（）方法比较内容是否相同    相同  true</p><p>不同 false，</p><p>方式：！字符串 1.equals（字符串2）</p></li></ul><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><p>​    1.字母，数字，下划线，$,但是不能以数字开头，</p><p>​    2.不能与关键字重名</p><p>​    3.见名知义</p><p>​    4.多个单词组成时，第一个单词小于其余单词开头大写    如：myScore键盘接收</p><p>​        1). 初始化Scanner 对象</p><p>​        <code>Scanner input=new Scanner(System.in);</code></p><p>​        2.)在程序中导入Scanner类  在类的外面写</p><p>​        <code>import java.util.Scanner;</code></p><p>​        3.)从键盘接收数据赋值给变量</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">    String name=input.next();//接收String类型的值    int javaScore=input.nextInt();//接收int类型的值    double height=input.nextDouble();//接收double类型的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><h4 id="声明和使用步骤"><a href="#声明和使用步骤" class="headerlink" title="声明和使用步骤 :"></a>声明和使用步骤 :</h4><p>​            1.声明  2.分配空间  3.赋值  4.使用</p><p>​            注意: </p><p>​                声明同时分配空间: 数据类型[] 数组名=new 数据类型[数组长度];</p><p>​                数组下标从0开始  数组元素最大下标值是 length-1</p><p>​                声明的时候赋值:  数据类型[] 数组名=new 数据类型[]{值1,值2,值3,….} //注意,后面的括号中不能写长度</p><p>​                          数据类型[] 数组名={值1,值2,值3,….}//不可拆分</p><h4 id="遍历数组元素"><a href="#遍历数组元素" class="headerlink" title="遍历数组元素"></a>遍历数组元素</h4><pre class="line-numbers language-lang-java"><code class="language-lang-java"> for(int i=0;i<数组名.length;i++){                System.out.println(数组名[下标]);            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数组的应用"><a href="#数组的应用" class="headerlink" title="数组的应用"></a>数组的应用</h4><p>​            ①    数组排序</p><p>​                            使用Arrays类sort方法排序，默认升序排列</p><p>​                            步骤：</p><p>​                            1）Arrays类导入import java.util.Arrays</p><p>​                            2）Arrays.sort（要排序的数组）；</p><p>​            ②求最大值（打擂台思想）</p><p>​                思路：</p><p>​                        1）.设置数组的一个元素为默认最大值</p><p>​                        2）.循环数组元素依次与最大值比较</p><p>​                关键代码：</p><p>​                                ```</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">int max=数组[0];for(int i=0;i<数组名.lenght;i++){    if(数组名[i]>max){        max=数组名[i];      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            ③向数组中插入元素</p><p>​            实现思路</p><p>​            a)找到待插入元素的下标</p><p>​                            循环数组，当满足待插入元素大于当前数组元素的时候，终止循                环，并用变量保存当前下标</p><p>​            b)给待插入的元素腾位置</p><p>​                    从后往前移动元素    否则会元素覆盖，丢失i=lenght-1；i&gt;找到的小标值；i—    前一个的值赋值给后一个</p><p>​            c）插入元素</p><p>​                        数组名[下标]=元素值；</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符:"></a>运算符:</h3><ol><li><p>赋值运算符</p><p>​    符号:  =  </p></li></ol><p>​            把等号右边的值赋给左边</p><p>​            sum+=i;//sum=sum+i;</p><p>​    2.算数运算符</p><p>​        + - * /(求商)  %(求余数)  ++(自增)  —(自减)</p><p>​    3.关系运算符：</p><p>​        >,&lt; ,&gt;=,&lt;=,  == (比较两个数是否相等)  !=（比较两数是否不等）        </p><p>​            注意:比较的结果用boolean 类型 的数据表示</p><p>​    4.逻辑运算符：</p><p>​         &amp;&amp;　　 ||　　！</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>​    ！＞算术运算符＞关系运算符＞＆＆＞｜｜最高小括号,最低赋值运算符</p><h3 id="二-流程控制语句"><a href="#二-流程控制语句" class="headerlink" title="二.流程控制语句"></a>二.流程控制语句</h3><p>​                    流程图—-&gt;表示程序的运行流程    </p><p>​                           ◇  —-&gt;表示判断</p><p>​                        矩形—-&gt;表示代码块</p><p>​            平行四边形—-&gt;输出语句</p><p>​                圆角矩形 —-&gt;开始或者结束</p><h4 id="1-选择结构"><a href="#1-选择结构" class="headerlink" title="1. 选择结构"></a>1. 选择结构</h4><p>1）简单的if选择结构</p><p>​        语法结构：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">if(boolean类型的值){       //代码块}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）if—else选择结构———用于两种分支判断的情形</p><p>​        语法：</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">if(){    //代码块1}else{    //代码块2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）多重if语句：用于区间连续情形</p><p>5)switch选择结构—-用于判断价值</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">switch(变量){    case    常量1：        //代码块        break;    case    常量2：        //代码块        break;        ...    default:            //代码块            break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>switch小括号里的变量  —-&gt;整型和字符型,jdk版本1.7以上 支持String</li><li><p>2.break可以省略,但是省略之后case之间会贯穿执行,直到遇到break才结束</p><p>3.各个case之间常量值不能重复的</p><p>4.default 总是在最后执行的,当前面所有的case都匹配不上时,位置不固定    </p></li></ol><h4 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2.循环结构"></a>2.循环结构</h4><p>1)while循环——-先判断再执行</p><p>​            初始化循环变量</p><p>​            while(判断条件){</p><p>​                //循环操作  </p><p>​                更新循环变量</p><p>​            }</p><p>2)do-while—-先执行再判断  </p><p>​            //定义循环变量</p><p>​            do{</p><p>​                //循环体</p><p>​                循环变量的更新</p><p>​            }while(判断条件);</p><p>3)for循环—-用于固定循环次数</p><p>​            for(循环变量初始化;条件判断;循环变量更新){</p><p>​                循环体</p><p>​               }</p><p>执行顺序：同while    1.变量初始化    2.条件判断    3.循环体    4.变量更新</p><h6 id="注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较"><a href="#注意：for循环中3个表达式均可省略-但是一般不要省略三种循环比较" class="headerlink" title="注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较"></a>注意：for循环中3个表达式均可省略,但是一般不要省略三种循环比较</h6><p>顺序：</p><p>​                先判断后执行：while for</p><p>​                先执行后判断：do-while</p><h6 id="注意：（1）for循环主要用于循环次数固定"><a href="#注意：（1）for循环主要用于循环次数固定" class="headerlink" title="注意：（1）for循环主要用于循环次数固定"></a>注意：（1）for循环主要用于循环次数固定</h6><h6 id="（2）在循环条件不成立的时候，do-while至少执行一次"><a href="#（2）在循环条件不成立的时候，do-while至少执行一次" class="headerlink" title="（2）在循环条件不成立的时候，do-while至少执行一次"></a>（2）在循环条件不成立的时候，do-while至少执行一次</h6><p>4)二重循环</p><p>​            一个完整的循环结构  再嵌套另一个  </p><p>​            for(){</p><p>​              //循环体</p><p>​              for(){</p><p>​              }</p><p>​            }</p><p>​            外层循环变化一次,内层循环变化一遍</p><h4 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3.流程控制语句"></a>3.流程控制语句</h4><p>break:</p><p>​            1)单层循环中: 终止循环，执行循环外的语句</p><p>​            2)二重循环中:用在内层循环中,只能结束内层循环,执行外层剩下的代码</p><p>continue：  </p><p>​            1)单层循环:跳过本次循环，执行下一次循环</p><p>​            2)结束本层的本次循环 执行本层下一次    </p><h6 id="解决代码中的异常"><a href="#解决代码中的异常" class="headerlink" title="解决代码中的异常:"></a>解决代码中的异常:</h6><h6 id="常见的错误信息"><a href="#常见的错误信息" class="headerlink" title="常见的错误信息:"></a>常见的错误信息:</h6><h6 id="1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用"><a href="#1-The-local-局部的-variable-变量-num-may-not-have-been-可能还没有被-initialized-初始化-gt-变量尚未赋值就已经使用" class="headerlink" title="1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用"></a>1.The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===&gt;变量尚未赋值就已经使用</h6><h6 id="2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明"><a href="#2-num-cannot-be-resolved-to-a-variable-gt-变量没有声明" class="headerlink" title="2.num cannot be resolved to a variable===&gt;变量没有声明"></a>2.num cannot be resolved to a variable===&gt;变量没有声明</h6><h6 id="3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException"><a href="#3-java-util-InputMismatchException-gt-输入类型不匹配4-数组下标越界-java-lang-ArrayIndexOutOfBoundsException" class="headerlink" title="3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException"></a>3.java.util.InputMismatchException  ===&gt;输入类型不匹配4.数组下标越界  java.lang.ArrayIndexOutOfBoundsException</h6><h6 id="当访问超出了数组下标范围"><a href="#当访问超出了数组下标范围" class="headerlink" title="当访问超出了数组下标范围"></a>当访问超出了数组下标范围</h6><h6 id="Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常"><a href="#Array-数组-index-下标-outof-超出了-bounds-边界-Exception-异常" class="headerlink" title="Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常"></a>Array 数组     index 下标   outof 超出了   bounds 边界  Exception 异常</h6><p>简单的异常处理</p><p>​        input.hasNextInt()  判断用户输入的内容是否是合法整数,合法为true,否则为false</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>​    要在变量赋值之前判断</p><p>​    程序调试  程序在我们的控制下一步一步执行</p><p>​     *    1.调试代码之前,要先分析可能出错的位置    </p><p>​     *    2.在可能出错的地方  打断点—-代码执行到断点处会暂停   行号前双击</p><p>​     *    3.以debug模式启动程序  debug as—-java application</p><pre><code> *    4.单步执行,查找错误(F6) {程序运行到断点处才会启动调试模式}</code></pre><p>​     *    5.找到错误,修改代码</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="一-什么叫面向对象"><a href="#一-什么叫面向对象" class="headerlink" title="一.什么叫面向对象"></a>一.什么叫面向对象</h4><p>相对于面向过程</p><p>​    在完成某件事情的时候,找到一个能完成该功能的对象,而不关心内部细节</p><p>​    如:数组排序的时候,我们只是调用了Arrays类的sort()方法就可以完成排序,但是具体是怎么实现的并没有过多的关心</p><h4 id="二-类和对象"><a href="#二-类和对象" class="headerlink" title="二.类和对象"></a>二.类和对象</h4><h5 id="1-现实中各类分类及描述"><a href="#1-现实中各类分类及描述" class="headerlink" title="1.现实中各类分类及描述"></a>1.现实中各类分类及描述</h5><p>手机:</p><p>​            属性(静态特征):    颜色,品牌,内存,处理器  </p><p>​            功能(动态行为): 打电话,发短信,上网</p><p>学生:</p><p>​            属性(静态特征) ;姓名,性别,身高,体重,学号,班级</p><p>​            功能(动态行为):学习,打代码</p><p>电脑:</p><p>​         属性(静态特征):品牌,外观,cpu,硬盘,内存</p><p>​            功能(动态行为); 开机,关机,运行各种软件</p><h5 id="2-怎么用java语言来描述现实生活中的分类"><a href="#2-怎么用java语言来描述现实生活中的分类" class="headerlink" title="2.怎么用java语言来描述现实生活中的分类"></a>2.怎么用java语言来描述现实生活中的分类</h5><p>public class 类名{</p><p>​            //属性——描述类的静态的特征</p><p>​            String 属性名;</p><p>​            int  属性名;</p><p>​            //方法——描述类的动态的行为</p><p>​            public void 方法名(){</p><p>​            }</p><p>​        }</p><h5 id="3-什么是对象"><a href="#3-什么是对象" class="headerlink" title="3.什么是对象"></a>3.什么是对象</h5><p>对象是用来描述客观事物的一个实,是具体的,能够看得见摸得着的</p><p>​            汽车—-类     我家楼下停着的那辆白色的宝马—-对象</p><p>​         *             手机—-类     我的这部手机——对象</p><p>​         *             椅子—-类     我现在正坐的椅子—-对象</p><p>​         *             演员—-类   女演员—-类     年龄是20到30岁之间的女演员 -类   迪丽热巴—对象 </p><p>​         *             作家—类   男作家—-类   郭敬明—对象</p><h5 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4.类和对象的关系"></a>4.类和对象的关系</h5><p>​        类定义了对象将会拥有的特征（属性）和行为（方法）———相当于图纸/模板</p><p>​        类是抽象的,对象是具体的</p><p>​        类是对象的类型,对象是类的实例</p><p>​        Car c=new Car();</p><p>​        int a=19;</p><h5 id="5-如何创建对象"><a href="#5-如何创建对象" class="headerlink" title="5.如何创建对象"></a>5.如何创建对象</h5><p>类名  对象名=new 类名();</p><h5 id="6-调用对象的属性"><a href="#6-调用对象的属性" class="headerlink" title="6.调用对象的属性"></a>6.调用对象的属性</h5><p>​    对象名.属性名;</p><h5 id="7-调用对象的方法"><a href="#7-调用对象的方法" class="headerlink" title="7.调用对象的方法"></a>7.调用对象的方法</h5><p>​    对象名.方法名();</p><h4 id="三-封装"><a href="#三-封装" class="headerlink" title="三.封装"></a>三.封装</h4><p>1.对象同时具有属性和方法两项特性</p><p>2.对象的属性和方法通常被封装在一起，共同体现事物的特性， 二者相辅相承，不能分割 </p><p>​    </p><p>​    如:一辆汽车，有完好的零件和特定的颜色还应具备开动、刹车等方法行为 </p><h4 id="四-面向对象的好处"><a href="#四-面向对象的好处" class="headerlink" title="四.面向对象的好处"></a>四.面向对象的好处</h4><p>​    1.与人类的思维习惯一致`</p><p>​    2.提高了程序的可重用性 </p><p>​    3.信息隐藏，提高了程序的可维护性和安全性  </p><h3 id="五、类的无参方法"><a href="#五、类的无参方法" class="headerlink" title="五、类的无参方法"></a>五、类的无参方法</h3><p>​    定义格式</p><p>​        public  返回值类型  方法名(){</p><p>​            //方法主体</p><p>​        }</p><h4 id="返回值类型的两种情况"><a href="#返回值类型的两种情况" class="headerlink" title="返回值类型的两种情况"></a>返回值类型的两种情况</h4><p>​        1.有具体的返回值类型    方法体最后一句话要添加return语句,返回相应类型的值</p><p>​        2.没有具体返回值类型 void  方法体中,可以不加return语句</p><p>​    注意：1.所有的数据类型,都可以作为方法的返回值类型</p><p>​    </p><p>​    2.调用带有返回值的方法的时候,一定要读返回值有所处理，要定一个相应类型的变量来接收方法的返回值</p><p>​    \3. return 的作用//1.跳出方法(方法执行到return语句就结束了)  2.返回结果</p><p>​    4.方法不能返回多个值</p><p>​    5.多个方法不能嵌套定义</p><p>​    6.方法外面不能写逻辑代码</p><h4 id="方法调用的两种情况"><a href="#方法调用的两种情况" class="headerlink" title="方法调用的两种情况"></a>方法调用的两种情况</h4><p>​    1.同类之间的方法调用  直接通过  方法名()  来调用</p><p>​    2.不同类的方法   先创建对象  通过  对象名.方法名()  来调用</p><p>方法返回值:</p><p>​    有些方法在执行完成之后,要给调用方法的对象返回一个值</p><h3 id="六、变量的分类"><a href="#六、变量的分类" class="headerlink" title="六、变量的分类"></a>六、变量的分类</h3><h4 id="1-成员变量-："><a href="#1-成员变量-：" class="headerlink" title="1.成员变量 ："></a>1.成员变量 ：</h4><p>定义在类中的，属性的位置</p><p>​           本类，其他类都可以访问（现阶段来说）</p><h4 id="2-局部变量："><a href="#2-局部变量：" class="headerlink" title="2.局部变量："></a>2.局部变量：</h4><p>定义在方法中的</p><p>​           只能在  定义的变量的方法  中使用</p><p>​    变量只能在定义它的大括号的范围内使用</p><p>​    区别：</p><h4 id="1-作用范围"><a href="#1-作用范围" class="headerlink" title="1.作用范围"></a>1.作用范围</h4><h4 id="2-初始值："><a href="#2-初始值：" class="headerlink" title="2.初始值："></a>2.初始值：</h4><p>​              成员变量在没有初始值的情况下，java会给默认的初始值</p><p>​              局部变量不会</p><p>​    注意：同一个方法中不能有同名的局部变量，同一个类中也不能有重复的成员变量</p><p>​       不同的方法中可以存在同名的局部变量</p><p>​       成员变量和局部变量能否定义相同的名字，可以的</p><p>​       局部变量和成员变量可以重名，但是局部变量具有更高的优先级</p><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释  /*  /"></a>文档注释  /<em>*  </em>/</h4><p>​    注释：类，属性，方法</p><p>​    可以把注释的内容抽取出来，显示成文档，方便开发人员使用</p><p>​    @version  版本  </p><p>​    @author  作者</p><p>​    @return  返回值</p><p>​    @param  参数</p><p>​    @exception  异常情况</p><h3 id="七、带参方法"><a href="#七、带参方法" class="headerlink" title="七、带参方法"></a><strong>七、带参方法</strong></h3><p>定义</p><p>​        访问修饰符（public）  返回值类型   方法名（数据类型  变量名,数据类型 变量名….）{</p><p>​            </p><p>​        }</p><p>​        注意:方法定义时的参数列表为形参列表,说明了方法调用的时候需要几个,什么类型的参数，逗号分隔</p><p>调用：</p><h4 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h4><p>​            数据类型 变量=对象名.方法名（变量1,变量2,变量3,…..）；</p><p>​        无返回值</p><p>​            对象名.方法名(参数1,参数2,….);</p><p>​        注意:实参是调用方法时小括号里传递的,要和形参列表一一对应</p><p>一个方法可以有无数个参数,一个返回值</p><h4 id="数组当参数的方法"><a href="#数组当参数的方法" class="headerlink" title="数组当参数的方法"></a>数组当参数的方法</h4><p>​    定义:</p><p>​        public  返回值  方法名(数据类型[] 数组名){</p><p>​            return  值;</p><p>​        }</p><h4 id="调用"><a href="#调用" class="headerlink" title="调用:"></a>调用:</h4><p>​        数据类型[] 实参数组名=new 数据类型[长度];</p><p>​        //数组元素的赋值</p><p>​        数据类型  变量= 对象名.方法名(实参数组名);</p><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组:"></a>对象数组:</h4><p>​    定义:</p><p>​        类名[] 数组名=new  类名[数组长度];  如:Student[] stus=new Student[6];</p><p>​    赋值:  1.数组名[下标]=new 类名();      如:stus[0]=new Student();    </p><p>​        数组名[下标].属性</p><p>​        数组名[下标].方法();</p><h4 id="对象作为参数"><a href="#对象作为参数" class="headerlink" title="对象作为参数"></a>对象作为参数</h4><p>​    public  返回值类型  方法名(类名  对象名){</p><p>​    }</p><p>调用:</p><p>​    //创建方法所在类的对象</p><p>​    类名  方法所在类的对象名=new 类名();</p><p>​    </p><p>​    //创建传递参数的对象</p><p>​    类名 对象名=new  类名();</p><p> 方法所在类的对象名.方法名(对象名);</p><h4 id="package-包声明语句"><a href="#package-包声明语句" class="headerlink" title="package 包声明语句"></a>package 包声明语句</h4><p>​    本类所在包的路径,以点号分割</p><p>​    必须是除了注释之外的第一条语句</p><p>import  包导入语句</p><p>​    指明要导入的类的路径,也是以点号分割</p><p>​    包名完整路径.类名 导入某一个类</p><p>​    包名完整路径.*   导入某一个包下面所有的类</p><h4 id="java中包名命名规则"><a href="#java中包名命名规则" class="headerlink" title="java中包名命名规则:"></a>java中包名命名规则:</h4><p>全小写,不能以点号开始或者结束,</p><p>​         有时前面会加上域名和项目组织名称</p><h3 id="八、字符串-String-StringBuffer"><a href="#八、字符串-String-StringBuffer" class="headerlink" title="八、字符串:  String,StringBuffer"></a>八、字符串:  String,StringBuffer</h3><p>调用字符串方法的时候要注意以下几点:</p><p> <strong>1.方法的作用  2.方法的参数  3.方法的返回值</strong></p><p>注意:java jdk 开发工具包中字符串类的定义有final 关键字,final含义是最终的意思,所以字符串对象一经创建,就不能更改</p><p>​        比如:  String s1=”hello”;  s1+=”,world”;  //s1=hello ,world</p><p>​        由于字符串的内容是不能修改的,所以这个例子里面实际上是创建了两个String对象 既:只要对字符串的内容修改一次,就会重新创建一个字符串类的对象</p><h4 id="1-创建字符串对象"><a href="#1-创建字符串对象" class="headerlink" title="1.创建字符串对象"></a><strong>1.创建字符串对象</strong></h4><p>​        String s=””;</p><p>​        String s=new String();</p><p>​        String s=new String(“hello world”);</p><h4 id="2-String类的方法"><a href="#2-String类的方法" class="headerlink" title="2.String类的方法"></a><strong>2.String类的方法</strong></h4><p>​        <strong>调用字符串类的的方法的时候,要注意,方法是否有参数,以及返回值类型</strong></p><p><strong>Ø</strong> 获取字符串长度  返回int类型</p><p>​        </p><p><strong>Ø</strong> <strong><em>equals()</em></strong>:比较字符串内容相等</p><p><strong>注意:如果用”==” 比较字符串的值,实际比较的是两个字符串的地址是否相同</strong></p><p><strong>Ø</strong> <strong><em>equalsIgnoreCase()</em></strong>比较相等时忽略大小写,用法和equals相同</p><p>​        字符串大小写转换</p><p><strong>Ø</strong> <strong><em>toLowerCase()</em></strong> 将字符串全部转化为小写</p><p><strong>Ø</strong> <strong><em>toUpperCase()</em></strong> 将字符串转换成大写</p><p><strong>注意:原来的字符串不会改变,转换之后的会作为返回值返回</strong></p><p>​            <strong>如:</strong></p><p>​            <strong>String name=”tom”;</strong></p><p>​            <strong>String s=name.toUpperCase();</strong></p><p>​            <strong>System.out.println(“name=”+name);// tom</strong></p><p>​            <strong>System.out.println(“s=”+s);//TOM</strong></p><p><strong>Ø</strong> <strong><em>字符串连接的方法</em></strong></p><p><strong></strong> <strong><em>使用”+”拼接字符串</em></strong></p><p><strong>‚</strong> <strong><em>字符串.concat(“”);</em></strong>原来的字符串不会改变,转换之后的会作为返回值返回</p><p>比如:String s=”123”;  String s1= s.concat(“111”);</p><p>​                   输出s的值为  123——&gt;s还是为原来的值,并没有改变</p><p>​                 输出s1的值  123111——-&gt;拼接的结果是作为返回值,接收输出返回值就是拼接之后的值</p><p><strong>Ø</strong> <strong><em>字符串的提取</em></strong></p><p><strong></strong> <strong><em>字符串.indexOf()</em></strong> </p><p>参数:int或者String </p><p>​                返回值:int  代表要查找字符第一次出现的下标位置</p><p><strong>注意:字符串字符下标从0开始</strong></p><p>​                          <strong>如果没有找到,返回值-1</strong></p><p><strong>‚</strong> <strong><em>字符串.lastIndexOf();</em></strong> </p><p>参数:int或者String </p><p>​                最后一次出现的下标</p><p><strong>ƒ</strong> <strong><em>字符串.indexOf(int/String , int fromIndex);</em></strong> </p><p>从fromindex位置开始的第一次出现的下标位置</p><p><strong>„</strong> <strong><em>字符串.charAt(int index)</em></strong> </p><p> 返回值类型:char  </p><p>​               查找返回  对应下标的字符</p><p>截取字符串:</p><p>​            1.substring(开始的下标)  //截取从下标位置开始到字符串结束  部分的内容</p><p>​             例如:</p><p>​                String s=”郑州职业技术学院”;</p><p>​                String s1=s.substring(2);</p><p>​                System.out.println(“截取出来的字符串是:”+s1);//职业技术学院</p><p>​            2.substring(开始的下标,结束下标)  返回值:String  截取之后的</p><p>​                注意:开始下标从0 计算  结束下标从1开始计算</p><p>去前后空格  :trim()  返回值类型:String   注意:原来的字符串不改变,去掉空格的字符串以返回值的形式返回</p><p>​            String str=”  abc  “;</p><p>​            String str_new=str.trim();  或者  str=str.trim();</p><p>​            str还是带有空格的, str_new 去掉前后空格的</p><p>​        分割字符串:</p><p>​            1.split(String regx); 参数:分隔符  返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割</p><p>​            2.split(String regx,int limit); 参数:分隔符,分割之后返回的数组元素的个数   返回值类型:String[] 数组</p><p>​            以分隔符为界限,将字符串分割成limit份</p><p>StringBuffer  :String类的增强版</p><p>​        优势:频繁对字符串的内容进行修改的时候要使用这个类</p><p>​        原因是:String对象一经创建,不能更改,如果修改了String对象的内容,系统会新创建一个对象来存放修改之后的内容</p><p>​            但是StringBuffer 存储的字符串的内容可以更改</p><p>​        方法:</p><p>​            1. toString();将StringBuffer的对象转换成String类型</p><p>​                //StringBuffer 和  String 类型相互转化</p><p>​                StringBuffer sb=new StringBuffer(“123”);</p><p>​                String s=sb.toString();</p><p>​        //String —-&gt;StringBuffer</p><p>​                String str=”123”;</p><p>​                StringBuffer sb1=new StringBuffer(str);</p><p>​            2. append(); 在字符串后面追加内容</p><p>​            3. StringBuffer对象.insert(int index,要插入的内容); 下标从0开始</p><p>​                将str的内容插入 对象中下标是index位置</p><p>​            4.length()  返回字符串对象的长度</p><h6 id="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"><a href="#java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件" class="headerlink" title="java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件"></a>java虚拟机：是一个可以执行java字节码文件的虚拟的进程，java源文件被编译成能被java虚拟机执行的字节码文件</h6>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客</title>
      <link href="posts/56568.html"/>
      <url>posts/56568.html</url>
      
        <content type="html"><![CDATA[<p>此人比较懒惰。未填写内容</p><p>如想详细创建博客请移步另博客，链接如下：</p><p><a href="https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/sunhwee/article/details/100109805?utm_medium=distribute.pc_relevant.none-task-blog-title-2&amp;spm=1001.2101.3001.4242</a></p><p>如想优化博客：</p><p><a href="https://www.islu.cn/posts/9443.html" target="_blank" rel="noopener">https://www.islu.cn/posts/9443.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
